
<!DOCTYPE html>
<html lang="ja">
<head>
   <script type="module">
document.addEventListener('DOMContentLoaded', async () => {
  try {
    const res = await fetch('./systemPrompt.txt');
    if (!res.ok) throw new Error(res.status);
    const prompt = (await res.text()).trim();

    /* ★ 1) 設定に代入  */
    window.state        ??= {};   // state がまだ無い場合に備え
    state.settings      ??= {};
    state.settings.commonSystemPrompt = prompt;          // UI 連動用
    window.commonSystemPrompt        = prompt;           // 必要ならグローバル保持

    /* ★ 2) アプリを初期化（ここで applySettingsToUI が走る） */
    appLogic.initializeApp();
  } catch (e) {
    console.error(e);
    alert('systemPrompt.txt が読み込めませんでした');
  }
});
</script>



    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeminiPWA</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" id="theme-color-meta" content="#4a90e2">
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f0f2f5;
            --bg-tertiary: #fdfdfd;
            --bg-tertiary-rgb: 253, 253, 253;
            --bg-input: #ffffff;
            --bg-user-message: #dcf8c6;
            --bg-model-message: #e5e5ea;
            --bg-system-message: #f0f8ff;
            --bg-error-message: #ffebee;
            --bg-button: #4a90e2;
            --bg-button-rgb: 74, 144, 226;
            --bg-button-hover: #357abd;
            --bg-button-disabled: #a0c3e8;
            --bg-button-action: #777777;
            --bg-button-action-hover: #555555;
            --bg-button-delete: #e53935;
            --bg-button-delete-hover: #c62828;
            --bg-button-retry: #43a047;
            --bg-button-retry-hover: #2e7d32;
            --bg-button-edit: #ff9800;
            --bg-button-edit-hover: #f57c00;
            --bg-button-copy: #e91e63;
            --bg-button-copy-hover: #c2185b;
            --bg-button-paste: #00bcd4;
            --bg-button-paste-hover: #0097a7;
            --bg-button-duplicate: #546e7a;
            --bg-button-duplicate-hover: #37474f;
            --bg-button-export: #1e88e5;
            --bg-button-export-hover: #1565c0;
            --bg-button-save: #30d158;
            --bg-button-save-hover: #24a345;
            --bg-button-cancel: #f44336;
            --bg-button-cancel-hover: #d32f2f;
            --bg-button-update: #1976d2;
            --bg-button-update-hover: #115293;
            --bg-header: #4a90e2;
            --overlay-base-rgb: 255, 255, 255;
            --chat-overlay-alpha: 0.65;
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);
            --bg-button-header-delete: #e53935;
            --bg-button-header-delete-hover: #c62828;
            --bg-button-header-copy: #e91e63;
            --bg-button-header-copy-hover: #c2185b;
            --bg-code-copy-button: var(--bg-button-action);
            --bg-code-copy-button-hover: var(--bg-button-action-hover);
            --text-code-copy-button: var(--text-light);

            --text-primary: #333333;
            --text-secondary: #777777;
            --text-light: #ffffff;
            --text-disabled: #e0e0e0;
            --text-error: #c62828;
            --text-link: #4a90e2;
            --text-placeholder: #999999;
            --text-system: #555;
            --text-memo: #000000;
            --bg-memo: #ffffff;

            --border-primary: #cccccc;
            --border-secondary: #dddddd;
            --border-tertiary: #eeeeee;
            --border-danger: #ffcdd2;
            --border-system: #add8e6;

            --shadow-primary: rgba(0, 0, 0, 0.1);
            --shadow-secondary: rgba(0,0,0,0.1);

            --message-max-width: 85%;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --message-body-font-size: 14px;
            --code-block-font-size: 13px;
            --chat-background-image: none;

            --bg-dialog-file-item: var(--bg-tertiary);
            --border-dialog-file-item: var(--border-secondary);
            --text-dialog-file-name: var(--text-primary);
            --text-dialog-file-size: var(--text-secondary);
            --bg-dialog-button-select: var(--bg-button-action);
            --bg-dialog-button-select-hover: var(--bg-button-action-hover);
            --bg-dialog-button-confirm: var(--bg-button-save);
            --bg-dialog-button-confirm-hover: var(--bg-button-save-hover);
            --bg-dialog-button-cancel: var(--bg-button-cancel);
            --bg-dialog-button-cancel-hover: var(--bg-button-cancel-hover);

            --bg-attachment-details: rgba(0, 0, 0, 0.03);
            --border-attachment-details: var(--border-tertiary);
            --text-attachment-summary: var(--text-secondary);
            --text-attachment-filename: var(--text-primary);

            --badge-color: #ffcc00;
            --badge-size: 12px;

            --memo-height: 300px;
            --clipboard-stack-height: 300px;
            --message-icon-size: 28px;
            --message-icon-offset-y: -10px;
            --icon-name-font-size: 10px;
            --icon-name-offset-y: -10px;

            --bg-toggle-button: var(--bg-button-action);
            --bg-toggle-button-hover: var(--bg-button-action-hover);
            --text-toggle-button: var(--text-light);

            --message-bubble-opacity: 1;
            --header-footer-opacity: 1;

            --bg-button-gold: #FFD700;
            --bg-button-gold-hover: #FFC700;
            --text-button-gold: #ffffff;
            --bg-button-purple: #800080;
            --bg-button-purple-hover: #6A006A;
            --text-button-purple: #ffffff;

            --message-toggle-button-top-width: 6px;
            --message-toggle-button-top-height: 40px;
            --message-toggle-button-top-font-size: 12px;
            --message-toggle-button-top-opacity: 0.6;
            --message-toggle-button-top-text-collapse: "-";
            --message-toggle-button-top-text-expand: "□";

            --message-toggle-button-bottom-font-size: 14px;
            --message-toggle-button-bottom-text-collapse: "非表示";
            --message-toggle-button-bottom-text-expand: "表示";

            --message-actions-base-rgb: 255, 255, 255;
            --message-actions-bg-opacity: 0.8;

            --user-name-bubble-bg: transparent;
            --ai-name-bubble-bg: transparent;
            --user-name-bubble-padding-y: 2px;
            --user-name-bubble-padding-x-ratio: 0.5;
            --user-name-bubble-border-radius: 5px;
            --ai-name-bubble-padding-y: 2px;
            --ai-name-bubble-padding-x-ratio: 0.5;
            --ai-name-bubble-border-radius: 5px;
            --default-user-name-bubble-custom-rgb: 255, 255, 255;
            --default-ai-name-bubble-custom-rgb: 255, 255, 255;

            --thought-summary-opacity: 0.85;
            --thought-summary-font-size: 12px;
        }

        body.dark-mode {
            --bg-primary: #1a1a1a;
            --bg-secondary: #101010;
            --bg-tertiary: #252525;
            --bg-tertiary-rgb: 37, 37, 37;
            --bg-input: #303030;
            --bg-user-message: #056162;
            --bg-model-message: #3a3a3c;
            --bg-system-message: #2a3a4a;
            --bg-error-message: #5c1c1c;
            --bg-button: #007aff;
            --bg-button-rgb: 0, 122, 255;
            --bg-button-hover: #005ecb;
            --bg-button-disabled: #4a5a70;
            --bg-button-action: #666666;
            --bg-button-action-hover: #888888;
            --bg-button-delete: #ff3b30;
            --bg-button-delete-hover: #d12c23;
            --bg-button-retry: #34c759;
            --bg-button-retry-hover: #249a41;
            --bg-button-edit: #ff9500;
            --bg-button-edit-hover: #d17d00;
            --bg-button-copy: #f06292;
            --bg-button-copy-hover: #ec407a;
            --bg-button-paste: #4dd0e1;
            --bg-button-paste-hover: #26c6da;
            --bg-button-duplicate: #8e8e93;
            --bg-button-duplicate-hover: #6b6b70;
            --bg-button-export: #0a84ff;
            --bg-button-export-hover: #0069d1;
            --bg-button-save: #30d158;
            --bg-button-save-hover: #24a345;
            --bg-button-cancel: #ff453a;
            --bg-button-cancel-hover: #d1332b;
            --bg-button-update: #0a84ff;
            --bg-button-update-hover: #0069d1;
            --bg-header: #007aff;
            --overlay-base-rgb: 30, 30, 30;
            --bg-memo: #2c2c2e;
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);
            --bg-button-header-delete: var(--bg-button-delete);
            --bg-button-header-delete-hover: var(--bg-button-delete-hover);
            --bg-button-header-copy: var(--bg-button-copy);
            --bg-button-header-copy-hover: var(--bg-button-copy-hover);
            --bg-code-copy-button: var(--bg-button-action);
            --bg-code-copy-button-hover: var(--bg-button-action-hover);
            --text-code-copy-button: var(--text-light);

            --text-primary: #e0e0e0;
            --text-secondary: #aaaaaa;
            --text-light: #ffffff;
            --text-disabled: #666666;
            --text-error: #ff8a80;
            --text-link: #00aaff;
            --text-placeholder: #777777;
            --text-system: #ccc;
            --text-memo: #e0e0e0;

            --border-primary: #444444;
            --border-secondary: #555555;
            --border-tertiary: #333333;
            --border-danger: #7a2e35;
            --border-system: #4682b4;

            --shadow-primary: rgba(255, 255, 255, 0.1);
            --shadow-secondary: rgba(0, 0, 0, 0.5);

            --bg-toggle-button: var(--bg-button-action);
            --bg-toggle-button-hover: var(--bg-button-action-hover);
            --text-toggle-button: var(--text-light);

            --bg-button-gold: #b8860b;
            --bg-button-gold-hover: #daa520;
            --text-button-gold: #ffffff;
            --bg-button-purple: #6a0dad;
            --bg-button-purple-hover: #8a2be2;
            --text-button-purple: #ffffff;

            --message-actions-base-rgb: 50, 50, 50;
            --default-user-name-bubble-custom-rgb: 50, 50, 50;
            --default-ai-name-bubble-custom-rgb: 50, 50, 50;
        }

        body.pastel-pink-mode {
            --bg-primary: #fff5f8;
            --bg-secondary: #ffe6ea;
            --bg-tertiary: #fff0f3;
            --bg-tertiary-rgb: 255, 240, 243;
            --bg-input: #ffffff;
            --bg-user-message: #ffddee;
            --bg-model-message: #f3e8ff;
            --bg-system-message: #ffeef2;
            --bg-error-message: #ffccd5;
            --bg-button: #ff8fab;
            --bg-button-rgb: 255, 143, 171;
            --bg-button-hover: #ff7096;
            --bg-button-disabled: #fcc2d7;
            --bg-button-action: #ffb3c1;
            --bg-button-action-hover: #ffa8b9;
            --bg-button-delete: #ff6b6b;
            --bg-button-delete-hover: #f06060;
            --bg-button-retry: #a0eade;
            --bg-button-retry-hover: #88d8c0;
            --bg-button-edit: #ffc974;
            --bg-button-edit-hover: #ffbd59;
            --bg-button-copy: #e5a9f0;
            --bg-button-copy-hover: #d998e3;
            --bg-button-paste: #b2e0ff;
            --bg-button-paste-hover: #a1d5f7;
            --bg-button-duplicate: #ffdaab;
            --bg-button-duplicate-hover: #ffce96;
            --bg-button-export: #c8a2c8;
            --bg-button-export-hover: #b991b9;
            --bg-button-save: #90ee90;
            --bg-button-save-hover: #78dd78;
            --bg-button-cancel: #ff9aa2;
            --bg-button-cancel-hover: #ff868e;
            --bg-button-update: #ff9a8b;
            --bg-button-update-hover: #ff8773;
            --bg-header: #ff8fab;
            --overlay-base-rgb: 255, 245, 248;
            --bg-memo: #fffafb;
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);
            --bg-button-header-delete: var(--bg-button-delete);
            --bg-button-header-delete-hover: var(--bg-button-delete-hover);
            --bg-button-header-copy: var(--bg-button-copy);
            --bg-button-header-copy-hover: var(--bg-button-copy-hover);
            --bg-code-copy-button: var(--bg-button-action);
            --bg-code-copy-button-hover: var(--bg-button-action-hover);
            --text-code-copy-button: var(--text-light);

            --text-primary: #5c3c45;
            --text-secondary: #8c6b74;
            --text-light: #ffffff;
            --text-disabled: #d8b8c0;
            --text-error: #c5002f;
            --text-link: #ff69b4;
            --text-placeholder: #b28a94;
            --text-system: #7d5a65;
            --text-memo: #5c3c45;

            --border-primary: #ffc2d7;
            --border-secondary: #ffe0e7;
            --border-tertiary: #fff0f3;
            --border-danger: #ffb3c1;
            --border-system: #ffd1dc;

            --shadow-primary: rgba(200, 150, 160, 0.1);
            --shadow-secondary: rgba(200, 150, 160, 0.1);

            --bg-dialog-file-item: var(--bg-tertiary);
            --border-dialog-file-item: var(--border-secondary);
            --text-dialog-file-name: var(--text-primary);
            --text-dialog-file-size: var(--text-secondary);
            --bg-dialog-button-select: var(--bg-button-action);
            --bg-dialog-button-select-hover: var(--bg-button-action-hover);
            --bg-dialog-button-confirm: var(--bg-button-save);
            --bg-dialog-button-confirm-hover: var(--bg-button-save-hover);
            --bg-dialog-button-cancel: var(--bg-button-cancel);
            --bg-dialog-button-cancel-hover: var(--bg-button-cancel-hover);

            --bg-attachment-details: rgba(255, 230, 234, 0.5);
            --border-attachment-details: var(--border-tertiary);
            --text-attachment-summary: var(--text-secondary);
            --text-attachment-filename: var(--text-primary);

            --bg-toggle-button: var(--bg-button-action);
            --bg-toggle-button-hover: var(--bg-button-action-hover);
            --text-toggle-button: var(--text-light);

            --bg-button-gold: #ffdd77;
            --bg-button-gold-hover: #ffcc55;
            --text-button-gold: #816200;
            --bg-button-purple: #d9a7e0;
            --bg-button-purple-hover: #c790d0;
            --text-button-purple: #ffffff;

            --message-actions-base-rgb: 255, 230, 234;

            --default-user-name-bubble-custom-rgb: 255, 230, 234;
            --default-ai-name-bubble-custom-rgb: 255, 230, 234;
        }

        body.pastel-blue-mode {
            --bg-primary: #f0f8ff;
            --bg-secondary: #e0f0ff;
            --bg-tertiary: #eaf5ff;
            --bg-tertiary-rgb: 234, 245, 255;
            --bg-input: #ffffff;
            --bg-user-message: #cff1ef;
            --bg-model-message: #e0e8ff;
            --bg-system-message: #e6f2ff;
            --bg-error-message: #d1e9ff;
            --bg-button: #87cefa;
            --bg-button-rgb: 135, 206, 250;
            --bg-button-hover: #70b8e8;
            --bg-button-disabled: #b0dfff;
            --bg-button-action: #add8e6;
            --bg-button-action-hover: #9ccce0;
            --bg-button-delete: #ff7f7f;
            --bg-button-delete-hover: #ff6a6a;
            --bg-button-retry: #98fb98;
            --bg-button-retry-hover: #82f082;
            --bg-button-edit: #ffe082;
            --bg-button-edit-hover: #ffda6b;
            --bg-button-copy: #bca0dc;
            --bg-button-copy-hover: #ae8fcf;
            --bg-button-paste: #a0cfd8;
            --bg-button-paste-hover: #8ebfc9;
            --bg-button-duplicate: #c1e1c1;
            --bg-button-duplicate-hover: #add6ad;
            --bg-button-export: #b0c4de;
            --bg-button-export-hover: #a0b7d3;
            --bg-button-save: #90ee90;
            --bg-button-save-hover: #78dd78;
            --bg-button-cancel: #ff94a0;
            --bg-button-cancel-hover: #ff808c;
            --bg-button-update: #89cff0;
            --bg-button-update-hover: #70c0e0;
            --bg-header: #87cefa;
            --overlay-base-rgb: 240, 248, 255;
            --bg-memo: #f5faff;
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);
            --bg-button-header-delete: var(--bg-button-delete);
            --bg-button-header-delete-hover: var(--bg-button-delete-hover);
            --bg-button-header-copy: var(--bg-button-copy);
            --bg-button-header-copy-hover: var(--bg-button-copy-hover);
            --bg-code-copy-button: var(--bg-button-action);
            --bg-code-copy-button-hover: var(--bg-button-action-hover);
            --text-code-copy-button: var(--text-light);

            --text-primary: #3a5679;
            --text-secondary: #6b87a9;
            --text-light: #ffffff;
            --text-disabled: #aec8e1;
            --text-error: #a52a2a;
            --text-link: #5f9ea0;
            --text-placeholder: #9ab0c9;
            --text-system: #5a7698;
            --text-memo: #3a5679;

            --border-primary: #b0dfff;
            --border-secondary: #d5eaff;
            --border-tertiary: #eaf5ff;
            --border-danger: #add8e6;
            --border-system: #c1d8e8;

            --shadow-primary: rgba(150, 180, 200, 0.1);
            --shadow-secondary: rgba(150, 180, 200, 0.1);

            --bg-dialog-file-item: var(--bg-tertiary);
            --border-dialog-file-item: var(--border-secondary);
            --text-dialog-file-name: var(--text-primary);
            --text-dialog-file-size: var(--text-secondary);
            --bg-dialog-button-select: var(--bg-button-action);
            --bg-dialog-button-select-hover: var(--bg-button-action-hover);
            --bg-dialog-button-confirm: var(--bg-button-save);
            --bg-dialog-button-confirm-hover: var(--bg-button-save-hover);
            --bg-dialog-button-cancel: var(--bg-button-cancel);
            --bg-dialog-button-cancel-hover: var(--bg-button-cancel-hover);

            --bg-attachment-details: rgba(224, 240, 255, 0.5);
            --border-attachment-details: var(--border-tertiary);
            --text-attachment-summary: var(--text-secondary);
            --text-attachment-filename: var(--text-primary);

            --bg-toggle-button: var(--bg-button-action);
            --bg-toggle-button-hover: var(--bg-button-action-hover);
            --text-toggle-button: var(--text-light);

            --bg-button-gold: #ffe48c;
            --bg-button-gold-hover: #ffda70;
            --text-button-gold: #7a6200;
            --bg-button-purple: #c1b2d7;
            --bg-button-purple-hover: #b0a0cb;
            --text-button-purple: #ffffff;

            --message-actions-base-rgb: 224, 240, 255;

            --default-user-name-bubble-custom-rgb: 224, 240, 255;
            --default-ai-name-bubble-custom-rgb: 224, 240, 255;
        }

        body.pastel-yellow-mode {
            --bg-primary: #fffefa;
            --bg-secondary: #fffacd;
            --bg-tertiary: #fff8dc;
            --bg-tertiary-rgb: 255, 248, 220;
            --bg-input: #ffffff;
            --bg-user-message: #fff5ba;
            --bg-model-message: #ffe4b5;
            --bg-system-message: #fffbea;
            --bg-error-message: #ffebcd;
            --bg-button: #ffd700;
            --bg-button-rgb: 255, 215, 0;
            --bg-button-hover: #ffc700;
            --bg-button-disabled: #fff0b3;
            --bg-button-action: #ffec8b;
            --bg-button-action-hover: #ffdf60;
            --bg-button-delete: #ffa07a;
            --bg-button-delete-hover: #ff8c69;
            --bg-button-retry: #b0e57c;
            --bg-button-retry-hover: #9acd32;
            --bg-button-edit: #ffa500;
            --bg-button-edit-hover: #ff8c00;
            --bg-button-copy: #ffb6c1;
            --bg-button-copy-hover: #ffaab5;
            --bg-button-paste: #add8e6;
            --bg-button-paste-hover: #9ccce0;
            --bg-button-duplicate: #f0e68c;
            --bg-button-duplicate-hover: #eadc67;
            --bg-button-export: #fff0b3;
            --bg-button-export-hover: #ffe78a;
            --bg-button-save: #98fb98;
            --bg-button-save-hover: #82f082;
            --bg-button-cancel: #ffdab9;
            --bg-button-cancel-hover: #ffceaa;
            --bg-button-update: #ffcc5c;
            --bg-button-update-hover: #ffbf40;
            --bg-header: #ffd700;
            --overlay-base-rgb: 255, 254, 250;
            --bg-memo: #fffef0;
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);
            --bg-button-header-delete: var(--bg-button-delete);
            --bg-button-header-delete-hover: var(--bg-button-delete-hover);
            --bg-button-header-copy: var(--bg-button-copy);
            --bg-button-header-copy-hover: var(--bg-button-copy-hover);
            --bg-code-copy-button: var(--bg-button-action);
            --bg-code-copy-button-hover: var(--bg-button-action-hover);
            --text-code-copy-button: var(--text-light);

            --text-primary: #5d4037;
            --text-secondary: #8d6e63;
            --text-light: #424242;
            --text-disabled: #bcaaa4;
            --text-error: #b71c1c;
            --text-link: #ff8f00;
            --text-placeholder: #a1887f;
            --text-system: #795548;
            --text-memo: #5d4037;

            --border-primary: #fff0b3;
            --border-secondary: #fff5ba;
            --border-tertiary: #fffacd;
            --border-danger: #ffcc80;
            --border-system: #fff9c4;

            --shadow-primary: rgba(200, 180, 130, 0.1);
            --shadow-secondary: rgba(200, 180, 130, 0.1);

            --bg-toggle-button: var(--bg-button-action);
            --bg-toggle-button-hover: var(--bg-button-action-hover);
            --text-toggle-button: var(--text-light);

            --bg-button-gold: var(--bg-button);
            --bg-button-gold-hover: var(--bg-button-hover);
            --text-button-gold: var(--text-light);
            --bg-button-purple: #e6e6fa;
            --bg-button-purple-hover: #d8bfd8;
            --text-button-purple: #4b0082;

            --message-actions-base-rgb: 255, 250, 205;

            --default-user-name-bubble-custom-rgb: 255, 250, 205;
            --default-ai-name-bubble-custom-rgb: 255, 250, 205;
        }

        body.pastel-purple-mode {
            --bg-primary: #f3e5f5;
            --bg-secondary: #e1bee7;
            --bg-tertiary: #ede7f6;
            --bg-tertiary-rgb: 237, 231, 246;
            --bg-input: #ffffff;
            --bg-user-message: #d1c4e9;
            --bg-model-message: #c5cae9;
            --bg-system-message: #f3e8fd;
            --bg-error-message: #f8bbd0;
            --bg-button: #ab47bc;
            --bg-button-rgb: 171, 71, 188;
            --bg-button-hover: #9c27b0;
            --bg-button-disabled: #ce93d8;
            --bg-button-action: #ba68c8;
            --bg-button-action-hover: #a54eb4;
            --bg-button-delete: #ec407a;
            --bg-button-delete-hover: #d81b60;
            --bg-button-retry: #81c784;
            --bg-button-retry-hover: #66bb6a;
            --bg-button-edit: #ffb74d;
            --bg-button-edit-hover: #ffa726;
            --bg-button-copy: #7e57c2;
            --bg-button-copy-hover: #673ab7;
            --bg-button-paste: #64b5f6;
            --bg-button-paste-hover: #42a5f5;
            --bg-button-duplicate: #9575cd;
            --bg-button-duplicate-hover: #7e57c2;
            --bg-button-export: #b39ddb;
            --bg-button-export-hover: #9d80cf;
            --bg-button-save: #a5d6a7;
            --bg-button-save-hover: #81c784;
            --bg-button-cancel: #ef9a9a;
            --bg-button-cancel-hover: #e57373;
            --bg-button-update: #7986cb;
            --bg-button-update-hover: #5c6bc0;
            --bg-header: #ab47bc;
            --overlay-base-rgb: 243, 229, 245;
            --bg-memo: #fbfaff;
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);
            --bg-button-header-delete: var(--bg-button-delete);
            --bg-button-header-delete-hover: var(--bg-button-delete-hover);
            --bg-button-header-copy: var(--bg-button-copy);
            --bg-button-header-copy-hover: var(--bg-button-copy-hover);
            --bg-code-copy-button: var(--bg-button-action);
            --bg-code-copy-button-hover: var(--bg-button-action-hover);
            --text-code-copy-button: var(--text-light);

            --text-primary: #4a148c;
            --text-secondary: #6a1b9a;
            --text-light: #ffffff;
            --text-disabled: #b39ddb;
            --text-error: #c2185b;
            --text-link: #7b1fa2;
            --text-placeholder: #9078a0;
            --text-system: #6a1b9a;
            --text-memo: #4a148c;

            --border-primary: #ce93d8;
            --border-secondary: #e1bee7;
            --border-tertiary: #f3e5f5;
            --border-danger: #f48fb1;
            --border-system: #d1c4e9;

            --shadow-primary: rgba(170, 150, 200, 0.1);
            --shadow-secondary: rgba(170, 150, 200, 0.1);

            --bg-toggle-button: var(--bg-button-action);
            --bg-toggle-button-hover: var(--bg-button-action-hover);
            --text-toggle-button: var(--text-light);

            --bg-button-gold: #ffee58;
            --bg-button-gold-hover: #fdd835;
            --text-button-gold: #424242;
            --bg-button-purple: var(--bg-button);
            --bg-button-purple-hover: var(--bg-button-hover);
            --text-button-purple: var(--text-light);

            --message-actions-base-rgb: 225, 190, 231;

            --default-user-name-bubble-custom-rgb: 225, 190, 231;
            --default-ai-name-bubble-custom-rgb: 225, 190, 231;
        }

        body.pastel-rainbow-mode {
            --bg-primary: #fdfdfd;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #fafafa;
            --bg-tertiary-rgb: 250, 250, 250;
            --bg-input: #ffffff;
            --bg-user-message: #e0fff0;
            --bg-model-message: #e0f0ff;
            --bg-system-message: #fff0f8;
            --bg-error-message: #fff8e0;
            --bg-button: #ff80c0;
            --bg-button-rgb: 255, 128, 192;
            --bg-button-hover: #ff60a0;
            --bg-button-disabled: #ffc0e0;
            --bg-button-action: #80d0ff;
            --bg-button-action-hover: #60b0e0;
            --bg-button-delete: #ff8080;
            --bg-button-delete-hover: #ff6060;
            --bg-button-retry: #80ff80;
            --bg-button-retry-hover: #60e060;
            --bg-button-edit: #ffc080;
            --bg-button-edit-hover: #ffa060;
            --bg-button-copy: #c080ff;
            --bg-button-copy-hover: #a060e0;
            --bg-button-paste: #ffff80;
            --bg-button-paste-hover: #e0e060;
            --bg-button-duplicate: #80ffff;
            --bg-button-duplicate-hover: #60e0e0;
            --bg-button-export: #ff80ff;
            --bg-button-export-hover: #e060e0;
            --bg-button-save: #c0ff80;
            --bg-button-save-hover: #a0e060;
            --bg-button-cancel: #ffc0c0;
            --bg-button-cancel-hover: #ffa0a0;
            --bg-button-update: #80c0ff;
            --bg-button-update-hover: #60a0e0;
            --bg-header: linear-gradient(to right, #ffadad, #ffd6a5, #fdffb6, #caffbf, #9bf6ff, #a0c4ff, #bdb2ff, #ffc6ff, #ffadad);
            --overlay-base-rgb: 253, 253, 253;
            --bg-memo: #f0fff0;
            --bg-code-copy-button: var(--bg-button-action);
            --bg-code-copy-button-hover: var(--bg-button-action-hover);
            --text-code-copy-button: var(--text-light);

            --text-primary: #333;
            --text-secondary: #555;
            --text-light: #fff;
            --text-disabled: #aaa;
            --text-error: #c00;
            --text-link: #007bff;
            --text-placeholder: #888;
            --text-system: #444;
            --text-memo: #333;

            --border-primary: #e0e0e0;
            --border-secondary: #f0f0f0;
            --border-tertiary: #fafafa;
            --border-danger: #ffdddd;
            --border-system: #e0e8f0;

            --bg-button-gold: #ffcc00;
            --text-button-gold: #333;
            --bg-button-purple: #cc99ff;
            --text-button-purple: #fff;

            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);
            --bg-button-header-delete: var(--bg-button-delete);
            --bg-button-header-delete-hover: var(--bg-button-delete-hover);
            --bg-button-header-copy: var(--bg-button-copy);
            --bg-button-header-copy-hover: var(--bg-button-copy-hover);

            --bg-dialog-file-item: var(--bg-tertiary);
            --border-dialog-file-item: var(--border-secondary);
            --text-dialog-file-name: var(--text-primary);
            --text-dialog-file-size: var(--text-secondary);
            --bg-dialog-button-select: var(--bg-button-action);
            --bg-dialog-button-select-hover: var(--bg-button-action-hover);
            --bg-dialog-button-confirm: var(--bg-button-save);
            --bg-dialog-button-confirm-hover: var(--bg-button-save-hover);
            --bg-dialog-button-cancel: var(--bg-button-cancel);
            --bg-dialog-button-cancel-hover: var(--bg-button-cancel-hover);

            --bg-attachment-details: rgba(240, 240, 240, 0.5);
            --border-attachment-details: var(--border-tertiary);
            --text-attachment-summary: var(--text-secondary);
            --text-attachment-filename: var(--text-primary);

            --bg-toggle-button: var(--bg-button-action);
            --bg-toggle-button-hover: var(--bg-button-action-hover);
            --text-toggle-button: var(--text-light);

            --message-actions-base-rgb: 245, 245, 245;

            --default-user-name-bubble-custom-rgb: 245, 245, 245;
            --default-ai-name-bubble-custom-rgb: 245, 245, 245;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            height: 100%;
            font-family: var(--font-family);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            overscroll-behavior-y: contain;
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow: hidden;
            touch-action: manipulation;
        }
        button {
            cursor: pointer;
            padding: 8px 15px;
            border-radius: 5px;
            border: none;
            font-size: 14px;
            background-color: var(--bg-button);
            color: var(--text-light);
            transition: background-color 0.2s ease, color 0.2s ease;
            line-height: 1.4;
        }
        button:hover:not(:disabled) {
            background-color: var(--bg-button-hover);
        }
        button:disabled {
            background-color: var(--bg-button-disabled);
            cursor: not-allowed;
            color: var(--text-disabled);
        }
        input[type="text"],
        input[type="password"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-primary);
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 10px;
            background-color: var(--bg-input);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        textarea {
            min-height: 80px;
            resize: vertical;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 14px;
            color: var(--text-primary);
        }
        ::placeholder { color: var(--text-placeholder); opacity: 1; }
        :-ms-input-placeholder { color: var(--text-placeholder); }
        ::-ms-input-placeholder { color: var(--text-placeholder); }
        .hidden { display: none !important; }
        .layout-hidden { display: none !important; }

        .app-container {
            display: flex;
            position: relative;
            height: 100%;
            max-width: 800px;
            margin: 0 auto;
            background-color: var(--bg-primary);
            box-shadow: 0 0 10px var(--shadow-secondary);
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        .app-header {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background-color: rgba(var(--bg-header-rgb, 74, 144, 226), var(--header-footer-opacity, 1));
            color: var(--text-light);
            flex-shrink: 0;
            position: sticky;
            top: 0;
            z-index: 10;
            transition: background-color 0.3s ease, padding 0.2s ease, gap 0.2s ease, min-height 0.2s ease;
            gap: 8px;
        }
        body.pastel-rainbow-mode .app-header {
            background: var(--bg-header);
        }

        .app-header h1 {
            font-size: 18px;
            font-weight: bold;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            text-align: left;
            margin: 0;
            margin-right: auto;
            flex-shrink: 1;
            min-width: 60px;
            transition: font-size 0.2s ease;
        }
        .header-button {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 20px;
            padding: 5px;
            line-height: 1;
            min-width: 30px;
            flex-shrink: 0;
            transition: padding 0.2s ease, font-size 0.2s ease, min-width 0.2s ease, height 0.2s ease;
        }
        #goto-settings-btn {
            order: 99;
            margin-left: 5px;
        }

        .app-header #toggle-clipboard-stack-btn,
        .app-header #toggle-memo-btn,
        .app-header .scroll-jump-button,
        .app-header #toggle-all-content-btn,
        .app-header .api-provider-toggle-btn {
            background-color: transparent !important;
            color: var(--text-light);
            box-shadow: none !important;
            border: 1px solid transparent;
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
        }
        .app-header #toggle-clipboard-stack-btn:hover,
        .app-header #toggle-memo-btn:hover,
        .app-header .scroll-jump-button:hover,
        .app-header #toggle-all-content-btn:hover,
        .app-header .api-provider-toggle-btn:hover {
            background-color: rgba(255, 255, 255, 0.1) !important;
            border-color: rgba(255, 255, 255, 0.3) !important;
        }
        body.pastel-yellow-mode .app-header #toggle-clipboard-stack-btn,
        body.pastel-yellow-mode .app-header #toggle-memo-btn,
        body.pastel-yellow-mode .app-header .scroll-jump-button,
        body.pastel-yellow-mode .app-header #toggle-all-content-btn,
        body.pastel-yellow-mode .app-header .api-provider-toggle-btn {
            color: #424242;
        }
        body.pastel-yellow-mode .app-header #toggle-clipboard-stack-btn:hover,
        body.pastel-yellow-mode .app-header #toggle-memo-btn:hover,
        body.pastel-yellow-mode .app-header .scroll-jump-button:hover,
        body.pastel-yellow-mode .app-header #toggle-all-content-btn:hover,
        body.pastel-yellow-mode .app-header .api-provider-toggle-btn:hover {
            background-color: rgba(0, 0, 0, 0.05) !important;
            border-color: rgba(0, 0, 0, 0.1) !important;
        }
        body.dark-mode .app-header #toggle-clipboard-stack-btn:hover,
        body.dark-mode .app-header #toggle-memo-btn:hover,
        body.dark-mode .app-header .scroll-jump-button:hover,
        body.dark-mode .app-header #toggle-all-content-btn:hover,
        body.dark-mode .app-header .api-provider-toggle-btn:hover {
            background-color: rgba(255, 255, 255, 0.08) !important;
            border-color: rgba(255, 255, 255, 0.2) !important;
        }

        #history-screen .app-header {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background-color: rgba(var(--bg-header-rgb, 74, 144, 226), var(--header-footer-opacity, 1));
            color: var(--text-light);
            flex-shrink: 0;
            position: sticky;
            top: 0;
            z-index: 10;
            transition: background-color 0.3s ease, padding 0.2s ease, gap 0.2s ease, min-height 0.2s ease;
            gap: 10px;
            flex-direction: row-reverse;
            justify-content: flex-start;
        }
        body.pastel-rainbow-mode #history-screen .app-header {
            background: var(--bg-header);
        }

        #history-screen .app-header h1#history-title {
            font-size: 18px;
            font-weight: bold;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            text-align: right;
            margin: 0;
            margin-left: auto;
            order: 2;
            transition: font-size 0.2s ease;
        }
        #history-screen .app-header #back-to-chat-from-history {
            order: 1;
        }

        #history-screen .app-header #export-all-sessions-btn {
            order: 3;
            padding: 4px 8px;
        }
        #history-screen .app-header #import-all-sessions-btn {
            order: 4;
            padding: 4px 8px;
        }
        #history-screen .app-header #import-history-btn {
            order: 5;
            margin-right: 0;
            padding: 4px 8px;
        }

        .history-action-button.gold {
            background-color: var(--bg-button-gold);
            color: var(--text-button-gold);
        }
        .history-action-button.gold:hover:not(:disabled) {
            background-color: var(--bg-button-gold-hover);
        }
        .history-action-button.purple {
            background-color: var(--bg-button-purple);
            color: var(--text-button-purple);
        }
        .history-action-button.purple:hover:not(:disabled) {
            background-color: var(--bg-button-purple-hover);
        }
        body.dark-mode .history-action-button.gold {
            background-color: var(--bg-button-gold);
            color: var(--text-button-gold);
        }
        body.dark-mode .history-action-button.gold:hover:not(:disabled) {
            background-color: var(--bg-button-gold-hover);
        }
        body.dark-mode .history-action-button.purple {
            background-color: var(--bg-button-purple);
            color: var(--text-button-purple);
        }
        body.dark-mode .history-action-button.purple:hover:not(:disabled) {
            background-color: var(--bg-button-purple-hover);
        }
        body.pastel-pink-mode .history-action-button.gold,
        body.pastel-blue-mode .history-action-button.gold,
        body.pastel-yellow-mode .history-action-button.gold,
        body.pastel-purple-mode .history-action-button.gold,
        body.pastel-rainbow-mode .history-action-button.gold {
            background-color: var(--bg-button-gold);
            color: var(--text-button-gold);
        }
        body.pastel-pink-mode .history-action-button.gold:hover:not(:disabled),
        body.pastel-blue-mode .history-action-button.gold:hover:not(:disabled),
        body.pastel-yellow-mode .history-action-button.gold:hover:not(:disabled),
        body.pastel-purple-mode .history-action-button.gold:hover:not(:disabled),
        body.pastel-rainbow-mode .history-action-button.gold:hover:not(:disabled) {
            background-color: var(--bg-button-gold-hover);
        }
        body.pastel-pink-mode .history-action-button.purple,
        body.pastel-blue-mode .history-action-button.purple,
        body.pastel-yellow-mode .history-action-button.purple,
        body.pastel-purple-mode .history-action-button.purple,
        body.pastel-rainbow-mode .history-action-button.purple {
            background-color: var(--bg-button-purple);
            color: var(--text-button-purple);
        }
        body.pastel-pink-mode .history-action-button.purple:hover:not(:disabled),
        body.pastel-blue-mode .history-action-button.purple:hover:not(:disabled),
        body.pastel-yellow-mode .history-action-button.purple:hover:not(:disabled),
        body.pastel-purple-mode .history-action-button.purple:hover:not(:disabled),
        body.pastel-rainbow-mode .history-action-button.purple:hover:not(:disabled) {
            background-color: var(--bg-button-purple-hover);
        }

        .header-save-button {
            padding: 4px 12px;
            font-size: 13px;
            background-color: var(--bg-button-save);
            color: var(--text-light);
            border-radius: 5px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease, padding 0.2s ease, font-size 0.2s ease, height 0.2s ease;
            flex-shrink: 0;
        }
        .header-save-button:hover:not(:disabled) {
            background-color: var(--bg-button-save-hover);
        }
        body.dark-mode .header-save-button {
             background-color: var(--bg-button-save);
        }
        body.dark-mode .header-save-button:hover:not(:disabled) {
             background-color: var(--bg-button-save-hover);
        }
        .header-notice {
            font-size: 11px;
            font-weight: normal;
            color: rgba(255, 255, 255, 0.8);
            text-align: right;
            white-space: nowrap;
            flex-shrink: 0;
        }
        body.dark-mode .header-notice {
            color: rgba(255, 255, 255, 0.7);
        }
        body.pastel-pink-mode .header-notice,
        body.pastel-blue-mode .header-notice,
        body.pastel-yellow-mode .header-notice,
        body.pastel-purple-mode .header-notice,
        body.pastel-rainbow-mode .header-notice {
            color: var(--text-light);
            opacity: 0.9;
        }
        body.pastel-yellow-mode .header-button,
        body.pastel-yellow-mode .header-notice {
            color: #424242;
        }
        body.pastel-yellow-mode .new-chat-button,
        body.pastel-yellow-mode .app-header .action-button-in-header,
        body.pastel-yellow-mode .header-save-button {
            color: #424242;
        }
        body.pastel-rainbow-mode .header-button,
        body.pastel-rainbow-mode .header-notice,
        body.pastel-rainbow-mode .new-chat-button,
         body.pastel-rainbow-mode .app-header .action-button-in-header,
         body.pastel-rainbow-mode .header-save-button {
             color: var(--text-light);
         }
 
         .new-chat-button {
             font-size: 14px;
             padding: 5px 10px;
             background-color: var(--bg-button-save);
             color: var(--text-light);
             flex-shrink: 0;
             border-radius: 5px;
             border: none;
             cursor: pointer;
             transition: background-color 0.2s ease, padding 0.2s ease, font-size 0.2s ease, height 0.2s ease;
         }
         .new-chat-button:hover {
             background-color: var(--bg-button-save-hover);
         }
         body.dark-mode .new-chat-button {
             background-color: var(--bg-button-save);
         }
         body.dark-mode .new-chat-button:hover {
             background-color: var(--bg-button-save-hover);
         }
+        .home-button {
+            font-size: 16px;
+            padding: 10px;
+            background-color: var(--bg-button);
+            color: var(--text-light);
+            border: none;
+            border-radius: 5px;
+            cursor: pointer;
+            transition: background-color 0.2s ease;
+        }
+        .home-button:hover {
+            background-color: var(--bg-button-hover);
+        }
         .app-header .action-button-in-header {
             padding: 5px 10px;
             font-size: 14px;
             color: var(--text-light);
             border-radius: 5px;
             border: none;
             cursor: pointer;
             transition: background-color 0.2s ease, padding 0.2s ease, font-size 0.2s ease, height 0.2s ease;
             flex-shrink: 0;
         }
         .app-header #delete-session-btn {
             background-color: var(--bg-button-header-delete);
         }
         .app-header #delete-session-btn:hover:not(:disabled) {
             background-color: var(--bg-button-header-delete-hover);
         }
         .app-header #copy-session-btn {
             background-color: var(--bg-button-header-copy);
         }
         .app-header #copy-session-btn:hover:not(:disabled) {
             background-color: var(--bg-button-header-copy-hover);
         }
 
         .main-content {
             flex-grow: 1;
             overflow-y: auto;
             padding: 15px;
             position: relative;
             z-index: 1;
             touch-action: pan-y;
         }
 
         .screen {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             display: flex;
             flex-direction: column;
             transition: transform 0.3s ease-in-out;
             background-color: var(--bg-primary);
             z-index: 0;
         }
         .screen.active {
             transform: translateX(0);
             z-index: 1;
         }
-        #chat-screen { transform: translateX(0); }
-        #history-screen { transform: translateX(-100%); }
-        #settings-screen { transform: translateX(100%); }
 
         #chat-screen {
             position: relative;
             z-index: 0;
             background-image: var(--chat-background-image);
             background-size: cover;
             background-position: center center;
             background-repeat: no-repeat;
             transition: background-image 0.3s ease, transform 0.3s ease-in-out;
         }
 
         #chat-screen::before {
             content: '';
             position: absolute;
             top: 0;
             left: 0;
             right: 0;
             bottom: 0;
             background-color: rgba(var(--overlay-base-rgb), var(--chat-overlay-alpha));
             z-index: 0;
             transition: background-color 0.3s ease;
             pointer-events: none;
         }
 
         #chat-screen .main-content {
diff --git a/index.html b/index.html
index f2d767ea44fe236326e7f18af36dac613b4d93f6..f6985c10205c494796a29b99753f2f6470262490 100644
--- a/index.html
+++ b/index.html
@@ -3209,51 +3219,84 @@ document.addEventListener('DOMContentLoaded', async () => {
             color: var(--text-light);
             border: none;
             border-radius: 5px;
             cursor: pointer;
             transition: background-color 0.2s ease;
         }
         .add-api-key-btn:hover {
             background-color: var(--bg-button-action-hover);
         }
         .add-api-key-btn:disabled {
             background-color: var(--bg-button-disabled);
             cursor: not-allowed;
         }
         #settings-screen.auto-save-mode .app-header #settings-save-notice,
         #settings-screen.auto-save-mode .app-header .js-save-settings-btn {
             display: none !important;
         }
     </style>
     <script src="marked.js"></script>
     <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>
     <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
 </head>
 <body>
     <div class="app-container">
 
-        <div id="chat-screen" class="screen active">
+        <div id="home-screen" class="screen active">
+            <header class="app-header">
+                <h1>ホーム</h1>
+            </header>
+            <main class="main-content" style="display:flex;flex-direction:column;gap:10px;">
+                <button id="home-start-chat-btn" class="home-button">会話を始める</button>
+                <button id="home-write-novel-btn" class="home-button">小説を書く</button>
+                <button id="home-history-btn" class="home-button">履歴から選択</button>
+            </main>
+        </div>
+
+        <div id="prompt-screen" class="screen">
+            <header class="app-header">
+                <button id="back-to-home-from-prompt" class="header-button" aria-label="戻る">＜</button>
+                <h1>プロンプト設定</h1>
+            </header>
+            <main class="main-content" style="display:flex;flex-direction:column;gap:10px;">
+                <textarea id="prompt-textarea" aria-label="キャラクター設定"></textarea>
+                <label>ユーザーとの関係:
+                    <select id="relationship-select">
+                        <option value="">未選択</option>
+                        <option value="初対面">初対面</option>
+                        <option value="友達">友達</option>
+                        <option value="恋人">恋人</option>
+                    </select>
+                </label>
+                <label>ユーザーの名前:
+                    <input type="text" id="user-name-setting" placeholder="任意">
+                </label>
+                <button id="prompt-confirm-btn">開始</button>
+            </main>
+        </div>
+
+        <div id="chat-screen" class="screen">
             <header class="app-header">
                 <button id="goto-history-btn" class="header-button" aria-label="履歴一覧へ">☰</button>
                 <h1 id="chat-title">新規チャット</h1>
                 <button id="new-chat-btn" class="new-chat-button" title="新規チャットを開始">新</button>
                 <button id="delete-session-btn" class="action-button-in-header" title="現在のチャットを削除">削</button>
                 <button id="copy-session-btn" class="action-button-in-header" title="チャット全体をコピー">コ</button>
                 <button id="header-api-provider-toggle-btn" class="header-button api-provider-toggle-btn" title="APIプロバイダー切替"></button>
                 <button id="scroll-to-top-btn" class="header-button scroll-jump-button" aria-label="最上部へスクロール" title="最上部へ">🔼</button>
                 <button id="scroll-to-bottom-btn" class="header-button scroll-jump-button" aria-label="最下部へスクロール" title="最下部へ">🔽</button>
                 <button id="toggle-all-content-btn" class="header-button" aria-label="全メッセージ表示切替" title="全メッセージの表示/非表示を切り替え">🖼️</button>
                 <button id="toggle-clipboard-stack-btn" class="header-button" aria-label="クリップボードスタックを開閉">🗒️</button>
                 <button id="toggle-memo-btn" class="header-button" aria-label="メモを開閉">📝</button>
                 <button id="goto-settings-btn" class="header-button" aria-label="設定へ">⚙</button>
             </header>
 
             <div id="memo-area" class="hidden">
                 <div class="memo-actions-container">
                     <button id="delete-memo-btn" class="delete-memo-btn" title="メモの内容を全て削除">全削除</button>
                     <button id="copy-memo-btn" class="copy-memo-btn" title="メモをコピー">コピー</button>
                     <button id="paste-memo-btn" class="paste-memo-btn" title="メモに貼り付け">貼付け</button>
                 </div>
                 <textarea id="memo-editor" aria-label="メモ入力エリア" placeholder="ここに一時的なメモを入力...（保存されません）"></textarea>
             </div>
 
             <div id="clipboard-stack-area" class="hidden">
diff --git a/index.html b/index.html
index f2d767ea44fe236326e7f18af36dac613b4d93f6..f6985c10205c494796a29b99753f2f6470262490 100644
--- a/index.html
+++ b/index.html
@@ -5172,56 +5215,67 @@ document.addEventListener('DOMContentLoaded', async () => {
             showApiProviderToggleHeaderCheckbox: document.getElementById('show-api-provider-toggle-header'),
             showApiProviderToggleFooterCheckbox: document.getElementById('show-api-provider-toggle-footer'),
             apiProviderCycleGeminiCheckbox: document.getElementById('api-provider-cycle-gemini'),
             apiProviderCycleDeepSeekCheckbox: document.getElementById('api-provider-cycle-deepseek'),
             apiProviderCycleClaudeCheckbox: document.getElementById('api-provider-cycle-claude'),
             apiProviderCycleOpenAICheckbox: document.getElementById('api-provider-cycle-openai'),
             apiProviderCycleXaiCheckbox: document.getElementById('api-provider-cycle-xai'),
             apiProviderCycleLlmAggregatorCheckbox: document.getElementById('api-provider-cycle-llmaggregator'),
             apiProviderCycleDummyCheckbox: document.getElementById('api-provider-cycle-dummy'),
             imagePreviewDialog: document.getElementById('imagePreviewDialog'),
             dummyErrorDebugModeCheckbox: document.getElementById('dummy-error-debug-mode'),
             dummyDummyModelInput: document.getElementById('dummy-dummy-model'),
             dummyEnableDummyModelCheckbox: document.getElementById('dummy-enable-dummy-model'),
             geminiApiKeysList: document.getElementById('gemini-api-keys-list'),
             addGeminiApiKeyBtn: document.getElementById('add-gemini-api-key-btn'),
             deepseekApiKeysList: document.getElementById('deepseek-api-keys-list'),
             addDeepseekApiKeyBtn: document.getElementById('add-deepseek-api-key-btn'),
             claudeApiKeysList: document.getElementById('claude-api-keys-list'),
             addClaudeApiKeyBtn: document.getElementById('add-claude-api-key-btn'),
             openaiApiKeysList: document.getElementById('openai-api-keys-list'),
             addOpenaiApiKeyBtn: document.getElementById('add-openai-api-key-btn'),
             xaiApiKeysList: document.getElementById('xai-api-keys-list'),
             addXaiApiKeyBtn: document.getElementById('add-xai-api-key-btn'),
             llmaggregatorApiKeysList: document.getElementById('llmaggregator-api-keys-list'),
             addLlmaggregatorApiKeyBtn: document.getElementById('add-llmaggregator-api-key-btn'),
+            homeScreen: document.getElementById('home-screen'),
+            promptScreen: document.getElementById('prompt-screen'),
+            homeStartChatBtn: document.getElementById('home-start-chat-btn'),
+            homeWriteNovelBtn: document.getElementById('home-write-novel-btn'),
+            homeHistoryBtn: document.getElementById('home-history-btn'),
+            backToHomeFromPromptBtn: document.getElementById('back-to-home-from-prompt'),
+            promptTextarea: document.getElementById('prompt-textarea'),
+            relationshipSelect: document.getElementById('relationship-select'),
+            userNameSettingInput: document.getElementById('user-name-setting'),
+            promptConfirmBtn: document.getElementById('prompt-confirm-btn'),
         };
 
         const state = {
             db: null,
             currentChatId: null,
             currentMessages: [],
+            promptMode: 'chat',
             settings: {
                 apiKey: '',
                 modelName: DEFAULT_MODEL,
                 additionalModels: '',
                 commonSystemPrompt: '',
                 enableCommonSystemPromptDefault: false,
                 geminiSystemPrompt: '',
                 geminiEnableSystemPromptDefault: true,
                 geminiTemperature: null,
                 geminiMaxTokens: null,
                 geminiTopK: null,
                 geminiTopP: null,
                 geminiPresencePenalty: null,
                 geminiFrequencyPenalty: null,
                 geminiThinkingBudget: null,
                 geminiIncludeThoughts: false,
                 geminiExpandThoughtsByDefault: false,
                 geminiStreamingOutput: true,
                 geminiStreamingSpeed: DEFAULT_STREAMING_SPEED,
                 geminiDummyUser: '',
                 geminiEnableDummyUser: true,
                 geminiDummyModel: '',
                 geminiEnableDummyModel: true,
                 geminiConcatDummyModel: false,
                 geminiPseudoStreaming: false,
diff --git a/index.html b/index.html
index f2d767ea44fe236326e7f18af36dac613b4d93f6..f6985c10205c494796a29b99753f2f6470262490 100644
--- a/index.html
+++ b/index.html
@@ -7985,86 +8039,83 @@ document.addEventListener('DOMContentLoaded', async () => {
             },
             showScreen(screenName, fromPopState = false) {
                 if (state.editingMessageIndex !== null) {
                      const messageElement = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                      if (messageElement) {
                         appLogic.cancelEditMessage(state.editingMessageIndex, messageElement);
                      } else {
                         state.editingMessageIndex = null;
                      }
                 }
                 if (state.isMemoVisible && screenName !== 'chat') {
                      elements.memoArea.classList.add('hidden');
                      state.isMemoVisible = false;
                 }
                 if (state.isClipboardStackVisible && screenName !== 'chat') {
                      elements.clipboardStackArea.classList.add('hidden');
                      state.isClipboardStackVisible = false;
                 }
 
                 if (screenName === state.currentScreen) {
                     if (screenName === 'history') this.updateHistoryHeaderButtonVisibility();
                      if (screenName === 'settings') this.applySettingsUIDetailsOpenStates();
                     return;
                 }
 
-                const allScreens = [elements.chatScreen, elements.historyScreen, elements.settingsScreen];
-                let activeScreen = null;
+                const orderedNames = ['home', 'prompt', 'chat', 'history', 'settings'];
+                const screenMap = {
+                    home: elements.homeScreen,
+                    prompt: elements.promptScreen,
+                    chat: elements.chatScreen,
+                    history: elements.historyScreen,
+                    settings: elements.settingsScreen
+                };
+                const allScreens = orderedNames.map(name => screenMap[name]);
+                let activeScreen = screenMap[screenName];
 
                 if (!fromPopState) {
-                    if (screenName === 'history' || screenName === 'settings') {
-                        history.pushState({ screen: screenName }, '', `#${screenName}`);
-                    } else if (screenName === 'chat') {
-                        history.replaceState({ screen: 'chat' }, '', '#chat');
-                    }
+                    history.pushState({ screen: screenName }, '', `#${screenName}`);
                 }
 
                 allScreens.forEach(screen => {
                     screen.classList.remove('active');
                     screen.inert = true;
                 });
 
+                const activeIndex = orderedNames.indexOf(screenName);
+                allScreens.forEach((screenEl, idx) => {
+                    screenEl.style.transform = `translateX(${(idx - activeIndex) * 100}%)`;
+                });
+
                 if (screenName === 'chat') {
-                    activeScreen = elements.chatScreen;
-                    elements.chatScreen.style.transform = 'translateX(0)';
-                    elements.historyScreen.style.transform = 'translateX(-100%)';
-                    elements.settingsScreen.style.transform = 'translateX(100%)';
                     requestAnimationFrame(() => {
                         this.adjustTextareaHeight();
                         this.updateChatScreenElementVisibility();
                     });
                 } else if (screenName === 'history') {
-                    activeScreen = elements.historyScreen;
-                    elements.chatScreen.style.transform = 'translateX(100%)';
-                    elements.historyScreen.style.transform = 'translateX(0)';
-                    elements.settingsScreen.style.transform = 'translateX(200%)';
                     this.renderHistoryList();
                 } else if (screenName === 'settings') {
-                    activeScreen = elements.settingsScreen;
-                    elements.chatScreen.style.transform = 'translateX(-100%)';
-                    elements.historyScreen.style.transform = 'translateX(-200%)';
-                    elements.settingsScreen.style.transform = 'translateX(0)';
                     this.applySettingsToUI();
                 }
 
                 requestAnimationFrame(() => {
                     allScreens.forEach(screen => {
                         screen.style.transition = 'transform 0.3s ease-in-out';
                     });
                     if (activeScreen) {
                         activeScreen.inert = false;
                         activeScreen.classList.add('active');
                     }
                 });
                 state.currentScreen = screenName;
             },
             setSendingState(sending) {
                 state.isSending = sending;
                 if (sending) {
                     elements.sendButton.textContent = '止';
                     elements.sendButton.classList.add('sending');
                     elements.sendButton.title = "停止";
                     elements.sendButton.disabled = false;
                     elements.userInput.disabled = true;
                     elements.attachFileBtn.disabled = true;
                     elements.pasteToInputBtn.disabled = true;
                     elements.rollDiceBtn.disabled = true;
diff --git a/index.html b/index.html
index f2d767ea44fe236326e7f18af36dac613b4d93f6..f6985c10205c494796a29b99753f2f6470262490 100644
--- a/index.html
+++ b/index.html
@@ -8506,107 +8557,120 @@ document.addEventListener('DOMContentLoaded', async () => {
                         gfm: true,
                         sanitize: false,
                         smartypants: false
                     });
                 }
                 if (typeof mermaid !== 'undefined') {
                     mermaid.initialize({
                         startOnLoad: false,
                         theme: 'default',
                         securityLevel: 'loose',
                         fontFamily: 'var(--font-family)',
                         flowchart: { useMaxWidth: true, htmlLabels: true },
                         sequence: { useMaxWidth: true },
                         gantt: { useMaxWidth: true },
                         journey: { useMaxWidth: true },
                         pie: { useMaxWidth: true }
                     });
                 }
 
                 elements.appVersionSpan.textContent = APP_VERSION;
 
                 window.addEventListener('beforeinstallprompt', (event) => {
                     event.preventDefault();
                 });
 
-                uiUtils.showScreen('chat');
+                uiUtils.showScreen('home');
                 registerServiceWorker();
 
                 try {
                     await dbUtils.openDB();
                     await dbUtils.loadSettings();
                     
                     uiUtils.applyTheme();
                     uiUtils.applyFontFamily();
                     uiUtils.applySidePanelSettingsToUI();
     
                     if (state.settings.backgroundImageBlob instanceof Blob) {
                         uiUtils.revokeExistingObjectUrl();
                         try {
                              state.backgroundImageUrl = URL.createObjectURL(state.settings.backgroundImageBlob);
                              document.documentElement.style.setProperty('--chat-background-image', `url(${state.backgroundImageUrl})`);
                         } catch (e) {
                              document.documentElement.style.setProperty('--chat-background-image', 'none');
                         }
                     } else {
                         document.documentElement.style.setProperty('--chat-background-image', 'none');
                     }
                     if (state.settings.userIconBlob instanceof Blob) {
                         try { state.userIconUrl = URL.createObjectURL(state.settings.userIconBlob); } catch (e) { }
                     }
                     if (state.settings.aiIconBlob instanceof Blob) {
                         try { state.aiIconUrl = URL.createObjectURL(state.settings.aiIconBlob); } catch (e) { }
                     }
     
                     uiUtils.applySettingsToUI();
     
                     const chats = await dbUtils.getAllChats(state.settings.historySortOrder);
                     if (chats && chats.length > 0) {
                         await this.loadChat(chats[0].id);
                     } else {
                         this.startNewChat();
                     }
                     
-                    history.replaceState({ screen: 'chat' }, '', '#chat');
-                    state.currentScreen = 'chat';
+                    history.replaceState({ screen: 'home' }, '', '#home');
+                    state.currentScreen = 'home';
                     
                     updateMessageMaxWidthVar();
                     this.setupEventListeners();
                     this.updateZoomState();
                     uiUtils.adjustTextareaHeight();
                     uiUtils.setSendingState(false);
                     
                     if (state.settings.autoScrollOnNewMessage) {
                         uiUtils.scrollToBottom();
                     }
 
                 } catch (error) {
                     await uiUtils.showCustomAlert(`アプリの初期化に失敗しました: ${error}`);
                     elements.appContainer.innerHTML = `<p style="padding: 20px; text-align: center; color: red;">アプリの起動に失敗しました。</p>`;
                 } 
             },
             setupEventListeners() {
+                elements.homeStartChatBtn.addEventListener('click', () => {
+                    state.promptMode = 'chat';
+                    elements.promptTextarea.value = state.settings.commonSystemPrompt || '';
+                    uiUtils.showScreen('prompt');
+                });
+                elements.homeWriteNovelBtn.addEventListener('click', () => {
+                    state.promptMode = 'novel';
+                    elements.promptTextarea.value = state.settings.commonSystemPrompt || '';
+                    uiUtils.showScreen('prompt');
+                });
+                elements.homeHistoryBtn.addEventListener('click', () => uiUtils.showScreen('history'));
+                elements.backToHomeFromPromptBtn.addEventListener('click', () => history.back());
+                elements.promptConfirmBtn.addEventListener('click', () => this.applyPromptAndStart());
                 elements.gotoHistoryBtn.addEventListener('click', () => uiUtils.showScreen('history'));
                 elements.gotoSettingsBtn.addEventListener('click', () => uiUtils.showScreen('settings'));
                 elements.backToChatFromHistoryBtn.addEventListener('click', () => history.back());
                 elements.backToChatFromSettingsBtn.addEventListener('click', () => history.back());
                 elements.toggleMemoBtn.addEventListener('click', () => this.toggleMemo());
                 elements.copyMemoBtn.addEventListener('click', () => this.copyMemoText());
                 elements.pasteMemoBtn.addEventListener('click', () => this.pasteIntoMemo());
                 elements.deleteMemoBtn.addEventListener('click', () => this.confirmClearMemo());
 
                 elements.toggleClipboardStackBtn.addEventListener('click', () => this.toggleClipboardStack());
                 elements.deleteClipboardStackBtn.addEventListener('click', () => this.confirmClearClipboardStack());
                 elements.copyClipboardStackBtn.addEventListener('click', () => this.copyClipboardStackText());
                 elements.pasteClipboardStackBtn.addEventListener('click', () => this.pasteIntoClipboardStack());
 
                 elements.scrollToTopBtn.addEventListener('click', () => this.scrollToTop());
                 elements.scrollToBottomBtn.addEventListener('click', () => this.scrollToBottom());
                 elements.aiToAiChatBtn.addEventListener('click', () => this.initiateAiToAiStep());
                 elements.pasteToInputBtn.addEventListener('click', () => this.pasteToUserInput());
                 elements.rollDiceBtn.addEventListener('click', () => this.rollDiceAndInput());
 
                 elements.newChatBtn.addEventListener('click', () => {
                     uiUtils.showCustomConfirm("現在のチャットを保存して新規チャットを開始しますか？").then(confirmed => {
                         if (confirmed) this.confirmStartNewChat();
                     });
                 });
diff --git a/index.html b/index.html
index f2d767ea44fe236326e7f18af36dac613b4d93f6..f6985c10205c494796a29b99753f2f6470262490 100644
--- a/index.html
+++ b/index.html
@@ -9134,51 +9198,51 @@ document.addEventListener('DOMContentLoaded', async () => {
                 const saveButtons = document.querySelectorAll('.js-save-settings-btn');
                 if (url && !isAllowedAggregatorDomain(url)) {
                     llmUrlError.textContent = 'このドメインは許可されていません。';
                     saveButtons.forEach(btn => btn.disabled = true);
                 } else {
                     llmUrlError.textContent = '';
                     saveButtons.forEach(btn => btn.disabled = false);
                 }
             };
 
             llmUrlInput.addEventListener('input', validateLlmUrl);
             llmUrlInput.addEventListener('blur', validateLlmUrl);
 
             multiApiKeyUtils.initializeMultiApiKeys();
             elements.geminiApiKeyInput.addEventListener('input', () => multiApiKeyUtils.syncMainApiKeyInput('gemini'));
             elements.deepSeekApiKeyInput.addEventListener('input', () => multiApiKeyUtils.syncMainApiKeyInput('deepseek'));
             elements.claudeApiKeyInput.addEventListener('input', () => multiApiKeyUtils.syncMainApiKeyInput('claude'));
             elements.openaiApiKeyInput.addEventListener('input', () => multiApiKeyUtils.syncMainApiKeyInput('openai'));
             elements.xaiApiKeyInput.addEventListener('input', () => multiApiKeyUtils.syncMainApiKeyInput('xai'));
             elements.llmAggregatorApiKeyInput.addEventListener('input', () => multiApiKeyUtils.syncMainApiKeyInput('llmaggregator'));
             elements.showMultiApiKeysToggle.addEventListener('change', (e) => {
                 uiUtils.toggleMultiApiKeysVisibility(e.target.checked);
             });
         },
         handlePopState(event) {
-            const targetScreen = event.state?.screen || 'chat';
+            const targetScreen = event.state?.screen || 'home';
             uiUtils.showScreen(targetScreen, true);
         },
         updateZoomState() {
             if ('visualViewport' in window) {
                 const newZoomState = window.visualViewport.scale > ZOOM_THRESHOLD;
                 if (state.isZoomed !== newZoomState) {
                     state.isZoomed = newZoomState;
                     document.body.classList.toggle('zoomed', state.isZoomed);
                 }
             }
         },
         handleTouchStart(event) {
             if (!state.settings.enableSwipeNavigation) return;
             if (event.touches.length > 1 || state.isZoomed) {
                 state.touchStartX = 0;
                 state.touchStartY = 0;
                 state.isSwiping = false;
                 return;
             }
             state.touchStartX = event.touches[0].clientX;
             state.touchStartY = event.touches[0].clientY;
             state.isSwiping = false;
             state.touchEndX = state.touchStartX;
             state.touchEndY = state.touchStartY;
         },
diff --git a/index.html b/index.html
index f2d767ea44fe236326e7f18af36dac613b4d93f6..f6985c10205c494796a29b99753f2f6470262490 100644
--- a/index.html
+++ b/index.html
@@ -9531,50 +9595,70 @@ document.addEventListener('DOMContentLoaded', async () => {
             }
             if (state.editingMessageIndex !== null) {
                 const confirmed = await uiUtils.showCustomConfirm("編集中です。変更を破棄して新規チャットを開始しますか？");
                 if (!confirmed) return;
                 const msgEl = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                 this.cancelEditMessage(state.editingMessageIndex, msgEl);
             }
             if (state.pendingAttachments.length > 0) {
                 const confirmedAttach = await uiUtils.showCustomConfirm("添付準備中のファイルがあります。破棄して新規チャットを開始しますか？");
                 if (!confirmedAttach) return;
                 state.pendingAttachments = [];
                 uiUtils.updateAttachmentBadgeVisibility();
             }
 
             if ((state.currentMessages.length > 0) && state.currentChatId) {
                 try {
                     await dbUtils.saveChat();
                 } catch (error) {
                     const conf = await uiUtils.showCustomConfirm("現在のチャットの保存に失敗しました。新規チャットを開始しますか？");
                     if (!conf) return;
                 }
             }
             this.startNewChat();
             uiUtils.showScreen('chat');
         },
+        applyPromptAndStart() {
+            const base = elements.promptTextarea.value.trim();
+            const prefix = state.promptMode === 'novel'
+                ? '下記のキャラクター設定をもとに小説を書いてください'
+                : 'あなたは下記のキャラクターとしてなりきって会話します。';
+            let finalPrompt = prefix + '\n' + base;
+            const rel = elements.relationshipSelect.value;
+            if (rel) finalPrompt += `\nユーザーとの関係は${rel}です`;
+            const uname = elements.userNameSettingInput.value.trim();
+            if (uname) finalPrompt += `\nユーザーの名前は${uname}です`;
+            state.settings.commonSystemPrompt = finalPrompt;
+            state.settings.enableCommonSystemPromptDefault = true;
+            elements.commonSystemPromptDefaultTextarea.value = finalPrompt;
+            elements.enableCommonSystemPromptDefaultCheckbox.checked = true;
+            if (state.settings.autoSaveSettings) {
+                this.saveSettings(false);
+            }
+            this.startNewChat();
+            uiUtils.showScreen('chat');
+        },
         startNewChat() {
             state.currentChatId = null;
             state.currentMessages = [];
             
             if (state.settings.commonSystemPrompt && state.settings.commonSystemPrompt.trim() !== '') {
             }
             
             state.pendingAttachments = [];
             state.isMemoVisible = false;
             elements.memoArea.classList.add('hidden');
             elements.memoEditor.value = '';
             state.isClipboardStackVisible = false;
             elements.clipboardStackArea.classList.add('hidden');
             state.clipboardStackContent = '';
             state.areAllMessagesHidden = false;
             uiUtils.updateToggleAllContentButton();
             state.messageCollapsedStates.clear();
             state.thoughtSummaryOpenStates.clear();
             uiUtils.renderChatMessages();
             uiUtils.updateChatTitle();
             elements.userInput.value = '';
             uiUtils.adjustTextareaHeight();
             uiUtils.setSendingState(false);
             uiUtils.updateAttachmentBadgeVisibility();
             if (state.settings.autoScrollOnNewMessage) {

                uiUtils.scrollToBottom();
            }
        },
        async loadChat(id) {
            let confirmedLoad = true;
            if (state.isSending) {
                if (!state.settings.disableLoadChatConfirmationWhileSending) {
                    confirmedLoad = await uiUtils.showCustomConfirm("送信中です。中断して別のチャットを読み込みますか？");
                }
                if (!confirmedLoad) return;
                this.abortRequest();
            }
            if (state.editingMessageIndex !== null) {
                const confirmedEdit = await uiUtils.showCustomConfirm("編集中です。変更を破棄して別のチャットを読み込みますか？");
                if (!confirmedEdit) return;
                const msgEl = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                this.cancelEditMessage(state.editingMessageIndex, msgEl);
            }
            if (state.pendingAttachments.length > 0) {
                const confirmedAttach = await uiUtils.showCustomConfirm("添付準備中のファイルがあります。破棄して別のチャットを読み込みますか？");
                if (!confirmedAttach) return;
                state.pendingAttachments = [];
                uiUtils.updateAttachmentBadgeVisibility();
            }

            try {
                const chat = await dbUtils.getChat(id);
                if (chat) {
                    state.currentChatId = chat.id;
                    state.currentMessages = chat.messages?.map(msg => ({
                        ...msg,
                        attachments: msg.attachments || [],
                        thoughtSummaryOpen: msg.thoughtSummaryOpen || false,
                    })) || [];

                    let needsSave = false;
                    const groupIds = new Set(state.currentMessages.filter(m => m.siblingGroupId).map(m => m.siblingGroupId));
                    groupIds.forEach(gid => {
                        const siblings = state.currentMessages.filter(m => m.siblingGroupId === gid);
                        const selected = siblings.filter(m => m.isSelected);
                        if (selected.length === 0 && siblings.length > 0) {
                            siblings[siblings.length - 1].isSelected = true;
                            needsSave = true;
                        } else if (selected.length > 1) {
                            selected.slice(0, -1).forEach(m => m.isSelected = false);
                            needsSave = true;
                        }
                    });

                    state.pendingAttachments = [];
                    state.areAllMessagesHidden = false;
                    uiUtils.updateToggleAllContentButton();
                    state.messageCollapsedStates.clear();
                    state.thoughtSummaryOpenStates.clear();
                    if (state.settings.persistMessageCollapseState && chat.collapsedStates) {
                        Object.entries(chat.collapsedStates).forEach(([idx, isCollapsed]) => {
                            state.messageCollapsedStates.set(parseInt(idx, 10), isCollapsed);
                        });
                    }
                     (chat.messages || []).forEach((msg, idx) => {
                        if (msg.thoughtSummaryOpen !== undefined) {
                            state.thoughtSummaryOpenStates.set(idx, msg.thoughtSummaryOpen);
                        }
                    });

                    uiUtils.renderChatMessages();
                    uiUtils.updateChatTitle(chat.title);
                    elements.userInput.value = '';
                    uiUtils.adjustTextareaHeight();
                    uiUtils.setSendingState(false);
                    uiUtils.updateAttachmentBadgeVisibility();
                    elements.memoEditor.value = '';
                    if (needsSave) {
                        await dbUtils.saveChat();
                    }
                    history.replaceState({ screen: 'chat' }, '', '#chat');
                    state.currentScreen = 'chat';
                    if (state.settings.autoScrollOnNewMessage && state.currentMessages.length > 0) {
                        uiUtils.scrollToBottom();
                    }
                } else {
                    await uiUtils.showCustomAlert("チャット履歴が見つかりませんでした。");
                    this.startNewChat();
                    uiUtils.showScreen('chat');
                }
            } catch (error) {
                await uiUtils.showCustomAlert(`チャットの読み込みエラー: ${error}`);
                this.startNewChat();
                uiUtils.showScreen('chat');
            }
        },
        async duplicateChat(id) {
            if (state.isSending) { const conf = await uiUtils.showCustomConfirm("送信中です。中断してチャットを複製しますか？"); if (!conf) return; this.abortRequest(); }
            if (state.editingMessageIndex !== null) { const conf = await uiUtils.showCustomConfirm("編集中です。変更を破棄してチャットを複製しますか？"); if (!conf) return; const msgEl = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`); this.cancelEditMessage(state.editingMessageIndex, msgEl); }
            if ((state.currentMessages.length > 0) && state.currentChatId && state.currentChatId !== id) { try { await dbUtils.saveChat(); } catch (error) { const conf = await uiUtils.showCustomConfirm("現在のチャット保存に失敗しました。複製を続行しますか？"); if (!conf) return; } }
            if (state.pendingAttachments.length > 0) {
                const confirmedAttach = await uiUtils.showCustomConfirm("添付準備中のファイルがあります。破棄してチャットを複製しますか？");
                if (!confirmedAttach) return;
                state.pendingAttachments = [];
            }

            try {
                const chat = await dbUtils.getChat(id);
                if (chat) {
                    const originalTitle = chat.title || "無題のチャット";
                    const newTitle = originalTitle.replace(new RegExp(DUPLICATE_SUFFIX.replace(/([().])/g, '\\$1') + '$'), '').trim() + DUPLICATE_SUFFIX;

                    const groupIdMap = new Map();
                    const duplicatedMessages = [];

                    (chat.messages || []).forEach(msg => {
                        const newMsg = JSON.parse(JSON.stringify(msg));
                        newMsg.attachments = msg.attachments ? JSON.parse(JSON.stringify(msg.attachments)) : [];
                        newMsg.isCascaded = msg.isCascaded ?? false;
                        newMsg.isSelected = msg.isSelected ?? false;
                        newMsg.thoughtSummaryOpen = msg.thoughtSummaryOpen || false;

                        if (msg.siblingGroupId) {
                            if (!groupIdMap.has(msg.siblingGroupId)) {
                                groupIdMap.set(msg.siblingGroupId, `dup-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`);
                            }
                            newMsg.siblingGroupId = groupIdMap.get(msg.siblingGroupId);
                        } else {
                            delete newMsg.siblingGroupId;
                        }
                        duplicatedMessages.push(newMsg);
                    });

                    const newGroupIds = new Set(duplicatedMessages.filter(m => m.siblingGroupId).map(m => m.siblingGroupId));
                    newGroupIds.forEach(gid => {
                        const siblings = duplicatedMessages.filter(m => m.siblingGroupId === gid);
                        siblings.forEach((m, idx) => {
                            m.isSelected = (idx === siblings.length - 1);
                        });
                    });

                    const newChatData = {
                        messages: duplicatedMessages,
                        updatedAt: Date.now(),
                        createdAt: Date.now(),
                        title: newTitle
                    };

                    if (state.settings.persistMessageCollapseState && chat.collapsedStates) {
                        newChatData.collapsedStates = { ...chat.collapsedStates };
                    }

                    const newChatId = await new Promise((resolve, reject) => {
                        const store = dbUtils._getStore(CHATS_STORE, 'readwrite');
                        const request = store.add(newChatData);
                        request.onsuccess = (event) => resolve(event.target.result);
                        request.onerror = (event) => reject(event.target.error);
                    });

                    if (state.currentScreen === 'history') {
                        uiUtils.renderHistoryList();
                    } else {
                        await uiUtils.showCustomAlert(`チャット「${newTitle}」を複製しました。`);
                    }
                } else {
                    await uiUtils.showCustomAlert("複製元のチャットが見つかりません。");
                }
            } catch (error) {
                await uiUtils.showCustomAlert(`チャット複製エラー: ${error}`);
            }
        },
        async exportChat(chatId, chatTitle) {
             const confirmed = await uiUtils.showCustomConfirm(`チャット「${chatTitle || 'この履歴'}」をテキスト出力しますか？`);
             if (!confirmed) return;

             try {
                 const chat = await dbUtils.getChat(chatId);
                 if (!chat || ((!chat.messages || chat.messages.length === 0))) {
                     await uiUtils.showCustomAlert("チャットデータが空です。");
                     return;
                 }

                 let exportText = '';
                 if (chat.messages) {
                     chat.messages.forEach(msg => {
                         if (msg.role === 'user' || msg.role === 'model') {
                             let attributes = '';
                             if (msg.role === 'model') {
                                 if (msg.isCascaded) attributes += ' isCascaded';
                                 if (msg.isSelected) attributes += ' isSelected';
                                 if (msg.thoughtSummaryOpen) attributes += ' thoughtOpen';
                             }
                             if (msg.role === 'user' && msg.attachments && msg.attachments.length > 0) {
                                 const fileNames = msg.attachments.map(a => a.name).join(';');
                                 attributes += ` attachments="${fileNames.replace(/"/g, '"')}"`;
                             }
                             exportText += `<|#|${msg.role}|#|${attributes.trim()}>\n${msg.content}\n<|#|/${msg.role}|#|>\n\n`;
                         }
                     });
                 }

                 const blob = new Blob([exportText.trim()], { type: 'text/plain;charset=utf-8' });
                 const url = URL.createObjectURL(blob);
                 const a = document.createElement('a');
                 const safeTitle = (chatTitle || `chat_${chatId}_export`).replace(/[<>:"/\\|?*\s]/g, '_');
                 a.href = url;
                 a.download = `${safeTitle}.txt`;
                 document.body.appendChild(a);
                 a.click();
                 document.body.removeChild(a);
                 URL.revokeObjectURL(url);
             } catch (error) {
                 await uiUtils.showCustomAlert(`エクスポートエラー: ${error}`);
             }
        },
        async confirmDeleteCurrentSession() {
            if (!state.currentChatId && state.currentMessages.length === 0) {
                await uiUtils.showCustomAlert("削除するチャットがありません（新規チャット状態です）。");
                return;
            }
            if (state.isSending) {
                await uiUtils.showCustomAlert("送信中です。完了後に再度お試しください。");
                return;
            }
            if (state.editingMessageIndex !== null) {
                await uiUtils.showCustomAlert("メッセージ編集中です。完了後に再度お試しください。");
                return;
            }
            const chatTitle = elements.chatTitle.textContent.startsWith("新規チャット") ? "このチャット" : `チャット「${elements.chatTitle.textContent.replace(/^: /, '')}」`;
            const confirmed = await uiUtils.showCustomConfirm(
                `${chatTitle}を完全に削除しますか？\nこの操作は元に戻せません。`
            );
            if (confirmed) {
                await this.deleteCurrentSession();
            }
        },
        async deleteCurrentSession() {
            try {
                if (state.currentChatId) {
                    await dbUtils.deleteChat(state.currentChatId);
                }
                this.startNewChat();
                await uiUtils.showCustomAlert("チャットを削除しました。");
            } catch (error) {
                await uiUtils.showCustomAlert(`チャットの削除中にエラーが発生しました: ${error}`);
            }
        },
        async copyCurrentSessionText() {
            if (state.currentMessages.length === 0) {
                await uiUtils.showCustomAlert("コピーする内容がありません。");
                return;
            }

            let sessionText = "";
            state.currentMessages.forEach(msg => {
                if (msg.role === 'user') {
                    sessionText += `あなた:\n`;
                } else if (msg.role === 'model') {
                    sessionText += `モデル:\n`;
                } else if (msg.role === 'error') {
                    sessionText += `エラー:\n`;
                }
                sessionText += `${msg.content}\n\n`;
                if (msg.attachments && msg.attachments.length > 0) {
                    sessionText += `  [添付ファイル: ${msg.attachments.map(a => a.name).join(', ')}]\n\n`;
                }
            });

            try {
                await navigator.clipboard.writeText(sessionText.trim());
                const buttonElement = elements.copySessionBtn;
                const originalText = buttonElement.textContent;
                buttonElement.textContent = '✓';
                buttonElement.disabled = true;
                setTimeout(() => {
                    buttonElement.textContent = originalText;
                    buttonElement.disabled = false;
                }, 1500);
            } catch (err) {
                await uiUtils.showCustomAlert("クリップボードへのコピーに失敗しました。\nお使いのブラウザが対応していないか、セキュリティ設定が原因の可能性があります。");
                const buttonElement = elements.copySessionBtn;
                const originalText = buttonElement.textContent;
                buttonElement.textContent = 'コピー失敗';
                buttonElement.disabled = true;
                setTimeout(() => {
                    buttonElement.textContent = originalText;
                    buttonElement.disabled = false;
                }, 2000);
            }
        },
        async confirmDeleteChat(id, title) {
             const confirmed = await uiUtils.showCustomConfirm(`「${title || 'この履歴'}」を削除しますか？`);
             if (confirmed) {
                const isDeletingCurrent = state.currentChatId === id;
                const currentScreenBeforeDelete = state.currentScreen;
                try {
                    await dbUtils.deleteChat(id);
                    if (isDeletingCurrent) {
                        this.startNewChat();
                    }
                    if (currentScreenBeforeDelete === 'history') {
                        await uiUtils.renderHistoryList();
                        const listIsEmpty = elements.historyList.querySelectorAll('.history-item:not(.js-history-item-template)').length === 0;
                        if (listIsEmpty) {
                            if (!isDeletingCurrent) {
                                this.startNewChat();
                            }
                        }
                    }
                } catch (error) {
                    await uiUtils.showCustomAlert(`チャット削除エラー: ${error}`);
                    uiUtils.setSendingState(false);
                }
            }
        },
        async editHistoryTitle(chatId, titleElement) {
            const currentTitle = titleElement.textContent;
            const newTitle = await uiUtils.showCustomPrompt("新しいタイトル:", currentTitle);
            const trimmedTitle = (newTitle !== null) ? sanitizeText(newTitle, 100).trim() : '';

            if (newTitle !== '' && trimmedTitle !== '' && trimmedTitle !== currentTitle) {
                const finalTitle = trimmedTitle;
                try {
                    await dbUtils.updateChatTitleDb(chatId, finalTitle);
                    titleElement.textContent = finalTitle;
                    titleElement.title = finalTitle;
                    const dateElement = titleElement.closest('.history-item')?.querySelector('.updated-date');
                    if(dateElement) dateElement.textContent = `更新: ${uiUtils.formatDate(Date.now())}`;

                    if (state.currentChatId === chatId) {
                        uiUtils.updateChatTitle(finalTitle);
                    }
                } catch (error) {
                    await uiUtils.showCustomAlert(`タイトル更新エラー: ${error}`);
                }
            }
        },
        async handleSend(isRetry = false, retryUserMessageIndex = -1, sourceSessionContext = null) {
            const isBackgroundProcess = !!sourceSessionContext;
            const selectedApiProvider = isBackgroundProcess ? (sourceSessionContext.apiProvider || state.settings.apiProvider) : state.settings.apiProvider;

            let text = '';
            let attachmentsToSend = [];
            if (isBackgroundProcess) {
                text = sourceSessionContext.inputText || '';
                attachmentsToSend = sourceSessionContext.attachments ? [...sourceSessionContext.attachments] : [];
            } else if (isRetry) {
                const retryUserMessage = state.currentMessages[retryUserMessageIndex];
                if (!retryUserMessage || retryUserMessage.role !== 'user') {
                    uiUtils.setSendingState(false);
                    return;
                }
                text = retryUserMessage.content || '';
                attachmentsToSend = retryUserMessage.attachments ? [...retryUserMessage.attachments] : [];
            } else {
                text = elements.userInput.value.trim();
                attachmentsToSend = [...state.pendingAttachments];
            }

            if (!isBackgroundProcess) {
                const isInputEmpty = text.trim() === '';
                const hasAttachments = attachmentsToSend.length > 0;
                const isDummyProvider = selectedApiProvider === 'dummy';

                if (state.isSending) {
                    return;
                }

                if (!isDummyProvider && isInputEmpty && !hasAttachments) {
                    return;
                }
            }
            
            if (selectedApiProvider === 'dummy') {
                let dummyResponseContent = '';
                if (state.settings.dummyEnableDummyModel && state.settings.dummyDummyModel) {
                    dummyResponseContent += state.settings.dummyDummyModel;
                }
                if (state.settings.dummyErrorDebugMode) {
                    const errorLog = errorRecovery.getErrorLogAsString();
                    if (dummyResponseContent) {
                        dummyResponseContent += '\n\n';
                    }
                    dummyResponseContent += errorLog;
                }

                if (isBackgroundProcess) {
                    return { content: dummyResponseContent, metadata: { finishReason: 'stop' } };
                }

                uiUtils.setSendingState(true);
                if (isRetry) {
                    if (retryUserMessageIndex + 1 < state.currentMessages.length) {
                        state.currentMessages.splice(retryUserMessageIndex + 1);
                    }
                    uiUtils.renderChatMessages(true);
                } else {
                    const userMessage = {
                        role: 'user', content: text, timestamp: Date.now(),
                        attachments: attachmentsToSend, generatedByApiProvider: null
                    };
                    state.currentMessages.push(userMessage);
                    const userMessageIndex = state.currentMessages.length - 1;
                    uiUtils.appendMessage(userMessage.role, userMessage.content, userMessageIndex, false, null, userMessage.attachments);
                    elements.userInput.value = '';
                    state.pendingAttachments = [];
                    uiUtils.adjustTextareaHeight();
                    uiUtils.updateAttachmentBadgeVisibility();
                }
                await dbUtils.saveChat();
                await sleep(300 + Math.random() * 400);
                
                const modelMessage = {
                    role: 'model', content: dummyResponseContent, timestamp: Date.now(), generatedByApiProvider: 'dummy'
                };
                state.currentMessages.push(modelMessage);
                const modelMessageIndex = state.currentMessages.length - 1;
                uiUtils.appendMessage(modelMessage.role, modelMessage.content, modelMessageIndex);
                await dbUtils.saveChat();
                uiUtils.setSendingState(false);
                if (state.settings.autoScrollOnNewMessage) uiUtils.scrollToBottom();
                return;
            }

            let currentContextSessionId = isBackgroundProcess ? sourceSessionContext.sessionId : state.currentChatId;
            let currentContextMessages = isBackgroundProcess ? [...sourceSessionContext.messages] : [...state.currentMessages];
            let currentContextSystemPrompt = '';

            if (isBackgroundProcess) {
                currentContextSystemPrompt = sourceSessionContext.systemPrompt || '';
            } else {
                let individualPrompt = '';
                let commonPrompt = '';

                if (selectedApiProvider === 'gemini' && state.settings.geminiEnableSystemPromptDefault) {
                    individualPrompt = state.settings.geminiSystemPrompt.trim();
                } else if (selectedApiProvider === 'deepseek' && state.settings.deepSeekEnableSystemPromptDefault) {
                    individualPrompt = state.settings.deepSeekSystemPrompt.trim();
                } else if (selectedApiProvider === 'claude' && state.settings.claudeEnableSystemPromptDefault) {
                    individualPrompt = state.settings.claudeSystemPrompt.trim();
                } else if (selectedApiProvider === 'openai' && state.settings.openaiEnableSystemPromptDefault) {
                    individualPrompt = state.settings.openaiSystemPrompt.trim();
                } else if (selectedApiProvider === 'xai' && state.settings.xaiEnableSystemPromptDefault) {
                    individualPrompt = state.settings.xaiSystemPrompt.trim();
                } else if (selectedApiProvider === 'llmaggregator' && state.settings.llmAggregatorEnableSystemPromptDefault) {
                    individualPrompt = state.settings.llmAggregatorSystemPrompt.trim();
                }
                
                if (state.settings.enableCommonSystemPromptDefault) {
                    commonPrompt = state.settings.commonSystemPrompt.trim();
                }
                
                if (individualPrompt) {
                    currentContextSystemPrompt = individualPrompt;
                } else if (commonPrompt) {
                    currentContextSystemPrompt = commonPrompt;
                } else {
                    currentContextSystemPrompt = '';
                }
            }
            
            let contextTemperature, contextMaxTokens, contextTopP,
                contextPresencePenalty, contextFrequencyPenalty,
                contextStreamingOutput, contextStreamingSpeed,
                contextDummyUser, contextEnableDummyUser,
                contextDummyModel, contextEnableDummyModel, contextConcatDummyModel;

            let contextGeminiTopK, contextGeminiThinkingBudget, contextGeminiIncludeThoughts,
                contextGeminiPseudoStreaming, contextGeminiEnableGrounding;

            let contextDeepSeekIncludeThoughts;

            let contextClaudeTopK, contextClaudeIncludeThoughts, contextClaudeThinkingBudget, contextClaudeExpandThoughtsByDefault;
            
            let contextXaiVisionEnable, contextXaiIncludeThoughts, contextXaiReasoningEffort;
            
            let contextLlmAggregatorTopK;

            if (isBackgroundProcess) {
                const providerForSettingsB = sourceSessionContext.apiProvider || state.settings.apiProvider;
                if (providerForSettingsB === 'gemini') {
                    contextTemperature = sourceSessionContext.temperature ?? state.settings.geminiTemperature;
                    contextMaxTokens = sourceSessionContext.maxTokens ?? state.settings.geminiMaxTokens;
                    contextGeminiTopK = sourceSessionContext.topK ?? state.settings.geminiTopK;
                    contextTopP = sourceSessionContext.topP ?? state.settings.geminiTopP;
                    contextPresencePenalty = sourceSessionContext.presencePenalty ?? state.settings.geminiPresencePenalty;
                    contextFrequencyPenalty = sourceSessionContext.frequencyPenalty ?? state.settings.geminiFrequencyPenalty;
                    contextGeminiThinkingBudget = sourceSessionContext.thinkingBudget ?? state.settings.geminiThinkingBudget;
                    contextGeminiIncludeThoughts = sourceSessionContext.includeThoughts ?? state.settings.geminiIncludeThoughts;
                    contextStreamingOutput = sourceSessionContext.streamingOutput ?? state.settings.geminiStreamingOutput;
                    contextStreamingSpeed = sourceSessionContext.streamingSpeed ?? state.settings.geminiStreamingSpeed;
                    contextDummyUser = sourceSessionContext.dummyUser ?? state.settings.geminiDummyUser;
                    contextEnableDummyUser = sourceSessionContext.enableDummyUser ?? state.settings.geminiEnableDummyUser;
                    contextDummyModel = sourceSessionContext.dummyModel ?? state.settings.geminiDummyModel;
                    contextEnableDummyModel = sourceSessionContext.enableDummyModel ?? state.settings.geminiEnableDummyModel;
                    contextConcatDummyModel = sourceSessionContext.concatDummyModel ?? state.settings.geminiConcatDummyModel;
                    contextGeminiPseudoStreaming = sourceSessionContext.pseudoStreaming ?? state.settings.geminiPseudoStreaming;
                    contextGeminiEnableGrounding = sourceSessionContext.enableGrounding ?? state.settings.geminiEnableGrounding;
                } else if (providerForSettingsB === 'deepseek') {
                    contextTemperature = sourceSessionContext.temperature ?? state.settings.deepSeekTemperature;
                    contextMaxTokens = sourceSessionContext.maxTokens ?? state.settings.deepSeekMaxTokens;
                    contextTopP = sourceSessionContext.topP ?? state.settings.deepSeekTopP;
                    contextPresencePenalty = sourceSessionContext.presencePenalty ?? state.settings.deepSeekPresencePenalty;
                    contextFrequencyPenalty = sourceSessionContext.frequencyPenalty ?? state.settings.deepSeekFrequencyPenalty;
                    contextDeepSeekIncludeThoughts = sourceSessionContext.includeDeepSeekThoughts ?? state.settings.deepSeekIncludeDeepSeekThoughts;
                    contextStreamingOutput = sourceSessionContext.streamingOutput ?? state.settings.deepSeekStreamingOutput;
                    contextStreamingSpeed = sourceSessionContext.streamingSpeed ?? state.settings.deepSeekStreamingSpeed;
                    contextDummyUser = sourceSessionContext.dummyUser ?? state.settings.deepSeekDummyUser;
                    contextEnableDummyUser = sourceSessionContext.enableDummyUser ?? state.settings.deepSeekEnableDummyUser;
                    contextDummyModel = sourceSessionContext.dummyModel ?? state.settings.deepSeekDummyModel;
                    contextEnableDummyModel = sourceSessionContext.enableDummyModel ?? state.settings.deepSeekEnableDummyModel;
                    contextConcatDummyModel = sourceSessionContext.concatDummyModel ?? state.settings.deepSeekConcatDummyModel;
                } else if (providerForSettingsB === 'llmaggregator') {
                    contextTemperature = sourceSessionContext.temperature ?? state.settings.llmAggregatorTemperature;
                    contextMaxTokens = sourceSessionContext.maxTokens ?? state.settings.llmAggregatorMaxTokens;
                    contextTopP = sourceSessionContext.topP ?? state.settings.llmAggregatorTopP;
                    contextLlmAggregatorTopK = sourceSessionContext.topK ?? state.settings.llmAggregatorTopK;
                    contextPresencePenalty = sourceSessionContext.presencePenalty ?? state.settings.llmAggregatorPresencePenalty;
                    contextFrequencyPenalty = sourceSessionContext.frequencyPenalty ?? state.settings.llmAggregatorFrequencyPenalty;
                    contextDeepSeekIncludeThoughts = sourceSessionContext.includeThoughts ?? state.settings.llmAggregatorIncludeThoughts;
                    contextStreamingOutput = sourceSessionContext.streamingOutput ?? state.settings.llmAggregatorStreamingOutput;
                    contextStreamingSpeed = sourceSessionContext.streamingSpeed ?? state.settings.llmAggregatorStreamingSpeed;
                    contextDummyUser = sourceSessionContext.dummyUser ?? state.settings.llmAggregatorDummyUser;
                    contextEnableDummyUser = sourceSessionContext.enableDummyUser ?? state.settings.llmAggregatorEnableDummyUser;
                    contextDummyModel = sourceSessionContext.dummyModel ?? state.settings.llmAggregatorDummyModel;
                    contextEnableDummyModel = sourceSessionContext.enableDummyModel ?? state.settings.llmAggregatorEnableDummyModel;
                    contextConcatDummyModel = sourceSessionContext.concatDummyModel ?? state.settings.llmAggregatorConcatDummyModel;
                } else if (providerForSettingsB === 'claude') {
                    contextTemperature = sourceSessionContext.temperature ?? state.settings.claudeTemperature;
                    contextMaxTokens = sourceSessionContext.maxTokens ?? state.settings.claudeMaxTokens;
                    contextClaudeTopK = sourceSessionContext.topK ?? state.settings.claudeTopK;
                    contextTopP = sourceSessionContext.topP ?? state.settings.claudeTopP;
                    contextStreamingOutput = sourceSessionContext.streamingOutput ?? state.settings.claudeStreamingOutput;
                    contextStreamingSpeed = sourceSessionContext.streamingSpeed ?? state.settings.claudeStreamingSpeed;
                    contextDummyUser = sourceSessionContext.dummyUser ?? state.settings.claudeDummyUser;
                    contextEnableDummyUser = sourceSessionContext.enableDummyUser ?? state.settings.claudeEnableDummyUser;
                    contextDummyModel = sourceSessionContext.dummyModel ?? state.settings.claudeDummyModel;
                    contextEnableDummyModel = sourceSessionContext.enableDummyModel ?? state.settings.claudeEnableDummyModel;
                    contextConcatDummyModel = sourceSessionContext.concatDummyModel ?? state.settings.claudeConcatDummyModel;
                    contextClaudeIncludeThoughts = sourceSessionContext.includeThoughts ?? state.settings.claudeIncludeThoughts;
                    contextClaudeThinkingBudget = sourceSessionContext.thinkingBudget ?? state.settings.claudeThinkingBudget;
                    contextClaudeExpandThoughtsByDefault = sourceSessionContext.expandThoughtsByDefault ?? state.settings.claudeExpandThoughtsByDefault;
                } else if (providerForSettingsB === 'openai') {
                    contextTemperature = sourceSessionContext.temperature ?? state.settings.openaiTemperature;
                    contextMaxTokens = sourceSessionContext.maxTokens ?? state.settings.openaiMaxTokens;
                    contextTopP = sourceSessionContext.topP ?? state.settings.openaiTopP;
                    contextPresencePenalty = sourceSessionContext.presencePenalty ?? state.settings.openaiPresencePenalty;
                    contextFrequencyPenalty = sourceSessionContext.frequencyPenalty ?? state.settings.openaiFrequencyPenalty;
                    contextStreamingOutput = sourceSessionContext.streamingOutput ?? state.settings.openaiStreamingOutput;
                    contextStreamingSpeed = sourceSessionContext.streamingSpeed ?? state.settings.openaiStreamingSpeed;
                    contextDummyUser = sourceSessionContext.dummyUser ?? state.settings.openaiDummyUser;
                    contextEnableDummyUser = sourceSessionContext.enableDummyUser ?? state.settings.openaiEnableDummyUser;
                    contextDummyModel = sourceSessionContext.dummyModel ?? state.settings.openaiDummyModel;
                    contextEnableDummyModel = sourceSessionContext.enableDummyModel ?? state.settings.openaiEnableDummyModel;
                    contextConcatDummyModel = sourceSessionContext.concatDummyModel ?? state.settings.openaiConcatDummyModel;
                } else if (providerForSettingsB === 'xai') {
                    contextTemperature = sourceSessionContext.temperature ?? state.settings.xaiTemperature;
                    contextMaxTokens = sourceSessionContext.maxTokens ?? state.settings.xaiMaxTokens;
                    contextTopP = sourceSessionContext.topP ?? state.settings.xaiTopP;
                    contextPresencePenalty = sourceSessionContext.presencePenalty ?? state.settings.xaiPresencePenalty;
                    contextFrequencyPenalty = sourceSessionContext.frequencyPenalty ?? state.settings.xaiFrequencyPenalty;
                    contextStreamingOutput = sourceSessionContext.streamingOutput ?? state.settings.xaiStreamingOutput;
                    contextStreamingSpeed = sourceSessionContext.streamingSpeed ?? state.settings.xaiStreamingSpeed;
                    contextDummyUser = sourceSessionContext.dummyUser ?? state.settings.xaiDummyUser;
                    contextEnableDummyUser = sourceSessionContext.enableDummyUser ?? state.settings.xaiEnableDummyUser;
                    contextDummyModel = sourceSessionContext.dummyModel ?? state.settings.xaiDummyModel;
                    contextEnableDummyModel = sourceSessionContext.enableDummyModel ?? state.settings.xaiEnableDummyModel;
                    contextConcatDummyModel = sourceSessionContext.concatDummyModel ?? state.settings.xaiConcatDummyModel;
                    contextXaiVisionEnable = sourceSessionContext.visionEnable ?? state.settings.xaiVisionEnable;
                    contextXaiIncludeThoughts = sourceSessionContext.includeThoughts ?? state.settings.xaiIncludeThoughts;
                    contextXaiReasoningEffort = sourceSessionContext.reasoningEffort ?? state.settings.xaiReasoningEffort;
                }
            } else {
                if (selectedApiProvider === 'gemini') {
                    contextTemperature = state.settings.geminiTemperature;
                    contextMaxTokens = state.settings.geminiMaxTokens;
                    contextGeminiTopK = state.settings.geminiTopK;
                    contextTopP = state.settings.geminiTopP;
                    contextPresencePenalty = state.settings.geminiPresencePenalty;
                    contextFrequencyPenalty = state.settings.geminiFrequencyPenalty;
                    contextGeminiThinkingBudget = state.settings.geminiThinkingBudget;
                    contextGeminiIncludeThoughts = state.settings.geminiIncludeThoughts;
                    contextStreamingOutput = state.settings.geminiStreamingOutput;
                    contextStreamingSpeed = state.settings.geminiStreamingSpeed;
                    contextDummyUser = state.settings.geminiDummyUser;
                    contextEnableDummyUser = state.settings.geminiEnableDummyUser;
                    contextDummyModel = state.settings.geminiDummyModel;
                    contextEnableDummyModel = state.settings.geminiEnableDummyModel;
                    contextConcatDummyModel = state.settings.geminiConcatDummyModel;
                    contextGeminiPseudoStreaming = state.settings.geminiPseudoStreaming;
                    contextGeminiEnableGrounding = state.settings.geminiEnableGrounding;
                } else if (selectedApiProvider === 'deepseek') {
                    contextTemperature = state.settings.deepSeekTemperature;
                    contextMaxTokens = state.settings.deepSeekMaxTokens;
                    contextTopP = state.settings.deepSeekTopP;
                    contextPresencePenalty = state.settings.deepSeekPresencePenalty;
                    contextFrequencyPenalty = state.settings.deepSeekFrequencyPenalty;
                    contextDeepSeekIncludeThoughts = state.settings.deepSeekIncludeDeepSeekThoughts;
                    contextStreamingOutput = state.settings.deepSeekStreamingOutput;
                    contextStreamingSpeed = state.settings.deepSeekStreamingSpeed;
                    contextDummyUser = state.settings.deepSeekDummyUser;
                    contextEnableDummyUser = state.settings.deepSeekEnableDummyUser;
                    contextDummyModel = state.settings.deepSeekDummyModel;
                    contextEnableDummyModel = state.settings.deepSeekEnableDummyModel;
                    contextConcatDummyModel = state.settings.deepSeekConcatDummyModel;
                } else if (selectedApiProvider === 'claude') {
                    contextTemperature = state.settings.claudeTemperature;
                    contextMaxTokens = state.settings.claudeMaxTokens;
                    contextClaudeTopK = state.settings.claudeTopK;
                    contextTopP = state.settings.claudeTopP;
                    contextStreamingOutput = state.settings.claudeStreamingOutput;
                    contextStreamingSpeed = state.settings.claudeStreamingSpeed;
                    contextDummyUser = state.settings.claudeDummyUser;
                    contextEnableDummyUser = state.settings.claudeEnableDummyUser;
                    contextDummyModel = state.settings.claudeDummyModel;
                    contextEnableDummyModel = state.settings.claudeEnableDummyModel;
                    contextConcatDummyModel = state.settings.claudeConcatDummyModel;
                    contextClaudeIncludeThoughts = state.settings.claudeIncludeThoughts;
                    contextClaudeThinkingBudget = state.settings.claudeThinkingBudget;
                    contextClaudeExpandThoughtsByDefault = state.settings.claudeExpandThoughtsByDefault;
                } else if (selectedApiProvider === 'openai') {
                    contextTemperature = state.settings.openaiTemperature;
                    contextMaxTokens = state.settings.openaiMaxTokens;
                    contextTopP = state.settings.openaiTopP;
                    contextPresencePenalty = state.settings.openaiPresencePenalty;
                    contextFrequencyPenalty = state.settings.openaiFrequencyPenalty;
                    contextStreamingOutput = state.settings.openaiStreamingOutput;
                    contextStreamingSpeed = state.settings.openaiStreamingSpeed;
                    contextDummyUser = state.settings.openaiDummyUser;
                    contextEnableDummyUser = state.settings.openaiEnableDummyUser;
                    contextDummyModel = state.settings.openaiDummyModel;
                    contextEnableDummyModel = state.settings.openaiEnableDummyModel;
                    contextConcatDummyModel = state.settings.openaiConcatDummyModel;
                } else if (selectedApiProvider === 'xai') {
                    contextTemperature = state.settings.xaiTemperature;
                    contextMaxTokens = state.settings.xaiMaxTokens;
                    contextTopP = state.settings.xaiTopP;
                    contextPresencePenalty = state.settings.xaiPresencePenalty;
                    contextFrequencyPenalty = state.settings.xaiFrequencyPenalty;
                    contextStreamingOutput = state.settings.xaiStreamingOutput;
                    contextStreamingSpeed = state.settings.xaiStreamingSpeed;
                    contextDummyUser = state.settings.xaiDummyUser;
                    contextEnableDummyUser = state.settings.xaiEnableDummyUser;
                    contextDummyModel = state.settings.xaiDummyModel;
                    contextEnableDummyModel = state.settings.xaiEnableDummyModel;
                    contextConcatDummyModel = state.settings.xaiConcatDummyModel;
                    contextXaiVisionEnable = state.settings.xaiVisionEnable;
                    contextXaiIncludeThoughts = state.settings.xaiIncludeThoughts;
                    contextXaiReasoningEffort = state.settings.xaiReasoningEffort;
                } else if (selectedApiProvider === 'llmaggregator') {
                    contextTemperature = state.settings.llmAggregatorTemperature;
                    contextMaxTokens = state.settings.llmAggregatorMaxTokens;
                    contextTopP = state.settings.llmAggregatorTopP;
                    contextLlmAggregatorTopK = state.settings.llmAggregatorTopK;
                    contextPresencePenalty = state.settings.llmAggregatorPresencePenalty;
                    contextFrequencyPenalty = state.settings.llmAggregatorFrequencyPenalty;
                    contextDeepSeekIncludeThoughts = state.settings.llmAggregatorIncludeThoughts;
                    contextStreamingOutput = state.settings.llmAggregatorStreamingOutput;
                    contextStreamingSpeed = state.settings.llmAggregatorStreamingSpeed;
                    contextDummyUser = state.settings.llmAggregatorDummyUser;
                    contextEnableDummyUser = state.settings.llmAggregatorEnableDummyUser;
                    contextDummyModel = state.settings.llmAggregatorDummyModel;
                    contextEnableDummyModel = state.settings.llmAggregatorEnableDummyModel;
                    contextConcatDummyModel = state.settings.llmAggregatorConcatDummyModel;
                }
            }
            
            if ((selectedApiProvider === 'gemini' && !(multiApiKeyUtils.getActiveApiKey('gemini') || state.settings.apiKey)) ||
                (selectedApiProvider === 'deepseek' && !(multiApiKeyUtils.getActiveApiKey('deepseek') || state.settings.deepSeekApiKey)) ||
                (selectedApiProvider === 'claude' && !(multiApiKeyUtils.getActiveApiKey('claude') || state.settings.claudeApiKey)) ||
                (selectedApiProvider === 'openai' && !(multiApiKeyUtils.getActiveApiKey('openai') || state.settings.openaiApiKey)) ||
                (selectedApiProvider === 'xai' && !(multiApiKeyUtils.getActiveApiKey('xai') || state.settings.xaiApiKey)) ||
                (selectedApiProvider === 'llmaggregator' && !(multiApiKeyUtils.getActiveApiKey('llmaggregator') || state.settings.llmAggregatorApiKey))) {
                if (!isBackgroundProcess) {
                    await uiUtils.showCustomAlert(`${selectedApiProvider} APIキーが設定されていません。設定画面を開きます。`);
                    uiUtils.showScreen('settings');
                }
                return "APIキー未設定";
            }
            
            if (selectedApiProvider === 'llmaggregator') {
                if (!isAllowedAggregatorDomain(state.settings.llmAggregatorApiBackend)) {
                    if (!isBackgroundProcess) {
                        await uiUtils.showCustomAlert('LLM AggregatorのバックエンドURLがホワイトリスト外のため、送信できません。設定を確認してください。');
                        uiUtils.showScreen('settings');
                    }
                    return "不正なドメイン";
                }
            }

            if (!isBackgroundProcess) uiUtils.setSendingState(true);
            state.partialStreamContent = '';
            state.partialThoughtStreamContent = '';

            let userMessageIndex = isRetry ? retryUserMessageIndex : -1;
            let existingSiblingGroupId = null;
            let firstResponseIndexForRetry = -1;
            let siblingGroupIdToUse = null;

            if (!isBackgroundProcess && !isRetry) {
                const userMessage = {
                    role: 'user', content: text, timestamp: Date.now(),
                    attachments: attachmentsToSend,
                    generatedByApiProvider: null
                };
                state.currentMessages.push(userMessage);
                userMessageIndex = state.currentMessages.length - 1;
                state.messageCollapsedStates.set(userMessageIndex, false);
                uiUtils.appendMessage(userMessage.role, userMessage.content, userMessageIndex, false, null, userMessage.attachments);
                elements.userInput.value = '';
                state.pendingAttachments = [];
                uiUtils.adjustTextareaHeight();
                uiUtils.updateAttachmentBadgeVisibility();
                currentContextMessages = [...state.currentMessages];
            } else if (isBackgroundProcess && !isRetry) {
                const userMessage = {
                    role: 'user', content: text, timestamp: Date.now(),
                    attachments: attachmentsToSend,
                    generatedByApiProvider: null
                };
                currentContextMessages.push(userMessage);
                userMessageIndex = currentContextMessages.length - 1;
            } else if (isRetry) {
                let siblingStartIndex = userMessageIndex + 1;
                while (siblingStartIndex < currentContextMessages.length && currentContextMessages[siblingStartIndex].role !== 'model') {
                    siblingStartIndex++;
                }
                if (siblingStartIndex < currentContextMessages.length && currentContextMessages[siblingStartIndex].role === 'model') {
                     firstResponseIndexForRetry = siblingStartIndex;
                     const firstResponse = currentContextMessages[firstResponseIndexForRetry];
                     if (firstResponse.isCascaded && firstResponse.siblingGroupId) {
                         existingSiblingGroupId = firstResponse.siblingGroupId;
                         currentContextMessages.forEach(msg => {
                             if (msg.siblingGroupId === existingSiblingGroupId) {
                                 msg.isSelected = false;
                             }
                         });
                         siblingGroupIdToUse = existingSiblingGroupId;
                     }
                }
            }

            const messagesToProcess = isRetry
                ? currentContextMessages.slice(0, userMessageIndex + 1)
                : [...currentContextMessages];

            try {
                let titleToSave = null;
                let isNewChatForDBSave = !currentContextSessionId;
                let existingChatForDBSave = null;

                if (currentContextSessionId && !isBackgroundProcess) {
                    existingChatForDBSave = await dbUtils.getChat(currentContextSessionId);
                    if (existingChatForDBSave) {
                        titleToSave = existingChatForDBSave.title;
                        isNewChatForDBSave = false;
                    } else {
                        isNewChatForDBSave = true;
                        currentContextSessionId = null;
                        state.currentChatId = null;
                    }
                } else if (isBackgroundProcess && sourceSessionContext?.sessionId) {
                     existingChatForDBSave = await dbUtils.getChat(sourceSessionContext.sessionId);
                     if (existingChatForDBSave) {
                        titleToSave = existingChatForDBSave.title;
                        isNewChatForDBSave = false;
                     } else {
                        isNewChatForDBSave = true;
                        sourceSessionContext.sessionId = null;
                     }
                }

                if (isNewChatForDBSave || !titleToSave) {
                    const firstUserMsg = currentContextMessages.find(m => m.role === 'user');
                    titleToSave = firstUserMsg ? firstUserMsg.content.substring(0, 50) : "無題のチャット";
                }

                const chatToSave = {
                    messages: currentContextMessages.map(msg => ({
                        role: msg.role, content: msg.content, timestamp: msg.timestamp,
                        thoughtSummary: msg.thoughtSummary || null,
                        deepSeekThoughtSummary: msg.deepSeekThoughtSummary || null,
                        xaiThoughtSummary: msg.xaiThoughtSummary || null,
                        generatedByApiProvider: msg.generatedByApiProvider || null,
                        ...(msg.finishReason && { finishReason: msg.finishReason }),
                        ...(msg.safetyRatings && { safetyRatings: msg.safetyRatings }),
                        ...(msg.error && { error: msg.error }),
                        ...(msg.isCascaded !== undefined && { isCascaded: msg.isCascaded }),
                        ...(msg.isSelected !== undefined && { isSelected: msg.isSelected }),
                        ...(msg.siblingGroupId !== undefined && { siblingGroupId: msg.siblingGroupId }),
                        ...(msg.groundingMetadata && { groundingMetadata: msg.groundingMetadata }),
                        ...(msg.attachments && msg.attachments.length > 0 && { attachments: msg.attachments.map(att => ({ name: att.name, mimeType: att.mimeType, textData: att.textData })) }),
                        ...(msg.usageMetadata && { usageMetadata: msg.usageMetadata }),
                        ...(msg.thoughtSummaryOpen !== undefined && { thoughtSummaryOpen: msg.thoughtSummaryOpen }),
                    })),
                    updatedAt: Date.now(),
                    title: titleToSave
                };

                if (isNewChatForDBSave) {
                    chatToSave.createdAt = Date.now();
                } else if (existingChatForDBSave) {
                    chatToSave.id = currentContextSessionId || sourceSessionContext?.sessionId;
                    chatToSave.createdAt = existingChatForDBSave.createdAt;
                }

                if (state.settings.persistMessageCollapseState) {
                    if (!isBackgroundProcess) {
                        chatToSave.collapsedStates = Object.fromEntries(state.messageCollapsedStates);
                    } else if (existingChatForDBSave) {
                         chatToSave.collapsedStates = existingChatForDBSave.collapsedStates || {};
                    } else {
                        chatToSave.collapsedStates = {};
                    }
                }

                const savedId = await new Promise((resolve, reject) => {
                    const store = dbUtils._getStore(CHATS_STORE, 'readwrite');
                    const request = chatToSave.id ? store.put(chatToSave) : store.add(chatToSave);
                    request.onsuccess = (event) => resolve(event.target.result || chatToSave.id);
                    request.onerror = (event) => reject(`チャット保存エラー: ${event.target.error.name} - ${event.target.error.message}`);
                });

                if (!isBackgroundProcess && !state.currentChatId && savedId) {
                    state.currentChatId = savedId;
                    uiUtils.updateChatTitle(chatToSave.title);
                } else if (isBackgroundProcess && !sourceSessionContext.sessionId && savedId) {
                    sourceSessionContext.sessionId = savedId;
                }

            } catch (error) {
                if (!isBackgroundProcess) {
                    if(currentContextSessionId){
                         uiUtils.displayError("チャットの保存に失敗しましたが、送信を試みます。", false);
                    }
                }
            }

            const apiMessages = messagesToProcess
                .filter(msg => {
                    if (msg.role === 'user') return true;
                    if (msg.role === 'model') return !msg.isCascaded || (msg.isCascaded && msg.isSelected);
                    return false;
                })
                .map(msg => {
                    const parts = [];
                    if (msg.content && msg.content.trim() !== '') {
                        parts.push({ text: msg.content });
                    }
                    if (msg.role === 'user' && msg.attachments && msg.attachments.length > 0) {
                        msg.attachments.forEach(att => {
                            if (att.textData) {
                                parts.push({ text: att.textData });
                            } else if (att.base64Data) {
                                parts.push({
                                    inlineData: {
                                        mimeType: att.mimeType,
                                        data: att.base64Data
                                    }
                                });
                            }
                        });
                    }
                    return { role: msg.role, parts: parts.length > 0 ? parts : [{text: ''}] };
                });
            const dummyUserTextToUse = contextEnableDummyUser && contextDummyUser?.trim() ? contextDummyUser.trim() : null;
            const dummyModelTextToUse = contextEnableDummyModel && contextDummyModel?.trim() ? contextDummyModel.trim() : null;

            if (dummyUserTextToUse) apiMessages.push({ role: 'user', parts: [{ text: dummyUserTextToUse }] });
            if (dummyModelTextToUse) apiMessages.push({ role: 'model', parts: [{ text: dummyModelTextToUse }] });

            const commonGenerationConfig = {};
            if (contextTemperature !== null) commonGenerationConfig.temperature = contextTemperature;
            if (contextMaxTokens !== null) commonGenerationConfig.maxOutputTokens = contextMaxTokens;
            if (contextTopP !== null) commonGenerationConfig.topP = contextTopP;
            if (contextPresencePenalty !== null) commonGenerationConfig.presencePenalty = contextPresencePenalty;
            if (contextFrequencyPenalty !== null) commonGenerationConfig.frequencyPenalty = contextFrequencyPenalty;

            if (selectedApiProvider === 'gemini') {
                if (contextGeminiTopK !== null) commonGenerationConfig.topK = contextGeminiTopK;
                if (contextGeminiThinkingBudget !== null || contextGeminiIncludeThoughts) {
                    commonGenerationConfig.thinkingConfig = commonGenerationConfig.thinkingConfig || {};
                    if (contextGeminiThinkingBudget !== null && Number.isInteger(contextGeminiThinkingBudget) && contextGeminiThinkingBudget >= 0) {
                        commonGenerationConfig.thinkingConfig.thinkingBudget = contextGeminiThinkingBudget;
                    }
                    if (contextGeminiIncludeThoughts) {
                        commonGenerationConfig.thinkingConfig.includeThoughts = true;
                    }
                     if (Object.keys(commonGenerationConfig.thinkingConfig).length === 0) delete commonGenerationConfig.thinkingConfig;
                }
            } else if (selectedApiProvider === 'claude') {
                if (contextClaudeTopK !== null) commonGenerationConfig.topK = contextClaudeTopK;
                if(contextClaudeIncludeThoughts) {
                    commonGenerationConfig.thinkingConfig = { "type": "enabled" };
                    if (contextClaudeThinkingBudget !== null && Number.isInteger(contextClaudeThinkingBudget) && contextClaudeThinkingBudget >= 1024) {
                        commonGenerationConfig.thinkingConfig.budget_tokens = contextClaudeThinkingBudget;
                    }
                }
            } else if (selectedApiProvider === 'llmaggregator') {
                if (contextLlmAggregatorTopK !== null) commonGenerationConfig.topK = contextLlmAggregatorTopK;
            }

            let systemInstructionForProvider = null;
            const systemPromptTextToUseForApi = currentContextSystemPrompt?.trim() ? currentContextSystemPrompt.trim() : null;

            if (systemPromptTextToUseForApi) {
                if (selectedApiProvider === 'gemini') {
                    systemInstructionForProvider = { role: "system", parts: [{ text: systemPromptTextToUseForApi }] };
                } else if (selectedApiProvider === 'deepseek' || selectedApiProvider === 'claude' || selectedApiProvider === 'openai' || selectedApiProvider === 'xai' || selectedApiProvider === 'llmaggregator') {
                    systemInstructionForProvider = { content: systemPromptTextToUseForApi, parts: [{ text: systemPromptTextToUseForApi }] };
                }
            }

            let modelResponseRawContent = '';
            let modelThoughtSummaryContent = '';
            let modelResponseMetadata = {};
            let currentGroundingMetadata = null;
            let finalUsageMetadataFromStream = null;

            let useStreamingForThisCall = isBackgroundProcess ? false : contextStreamingOutput;
            let usePseudoForThisCall = isBackgroundProcess ? false : (selectedApiProvider === 'gemini' && contextGeminiPseudoStreaming);

            let modelMessageObjectForStream = null;

            try {
                let apiResponseObject;
                if (selectedApiProvider === 'gemini') {
                    apiResponseObject = await apiUtils.callGeminiApi(apiMessages, commonGenerationConfig, systemInstructionForProvider, useStreamingForThisCall, usePseudoForThisCall, contextGeminiEnableGrounding);
                } else if (selectedApiProvider === 'deepseek' || selectedApiProvider === 'llmaggregator') {
                    apiResponseObject = await apiUtils.callDeepSeekApi(apiMessages, commonGenerationConfig, systemInstructionForProvider, useStreamingForThisCall, selectedApiProvider);
                } else if (selectedApiProvider === 'claude') {
                    apiResponseObject = await apiUtils.callClaudeApi(apiMessages, commonGenerationConfig, systemInstructionForProvider, useStreamingForThisCall);
                } else if (selectedApiProvider === 'openai') {
                    const hasImage = apiMessages.some(m => m.parts.some(p => p.inlineData && p.inlineData.mimeType.startsWith('image/')));
                    apiResponseObject = await apiUtils.callOpenAICompatibleApi('openai', apiMessages, commonGenerationConfig, systemInstructionForProvider, useStreamingForThisCall, hasImage);
                } else if (selectedApiProvider === 'xai') {
                    const hasImage = apiMessages.some(m => m.parts.some(p => p.inlineData && p.inlineData.mimeType.startsWith('image/')));
                    const enableVisionForThisCall = contextXaiVisionEnable || hasImage;
                    apiResponseObject = await apiUtils.callXaiApi(apiMessages, commonGenerationConfig, systemInstructionForProvider, useStreamingForThisCall, enableVisionForThisCall);
                } else {
                    throw new Error("不明なAPIプロバイダーが選択されています。");
                }

                const dummyModelPrefix = (contextConcatDummyModel && dummyModelTextToUse) ? dummyModelTextToUse : '';
                 if (!isBackgroundProcess) {
                    state.partialStreamContent = dummyModelPrefix;
                    state.partialThoughtStreamContent = '';
                }

                if (useStreamingForThisCall && !isBackgroundProcess) {
                    const tempPlaceholderIndex = state.currentMessages.length;
                    modelMessageObjectForStream = {
                        role: 'model',
                        content: '',
                        thoughtSummary: null,
                        deepSeekThoughtSummary: null,
                        xaiThoughtSummary: null,
                        timestamp: Date.now(),
                        generatedByApiProvider: selectedApiProvider,
                        thoughtSummaryOpen: (selectedApiProvider === 'gemini' && contextGeminiIncludeThoughts && state.settings.geminiExpandThoughtsByDefault) ||
                                            (selectedApiProvider === 'deepseek' && contextDeepSeekIncludeThoughts && state.settings.deepSeekExpandThoughtsByDefault) ||
                                            (selectedApiProvider === 'claude' && contextClaudeIncludeThoughts && state.settings.claudeExpandThoughtsByDefault) ||
                                            (selectedApiProvider === 'xai' && contextXaiIncludeThoughts && state.settings.xaiExpandThoughtsByDefault) ||
                                            (selectedApiProvider === 'llmaggregator' && state.settings.llmAggregatorIncludeThoughts && state.settings.llmAggregatorExpandThoughtsByDefault),
                    };

                    if (isRetry && firstResponseIndexForRetry !== -1) {
                         if (siblingGroupIdToUse === null) {
                             siblingGroupIdToUse = `gid-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
                         }
                         modelMessageObjectForStream.isCascaded = true;
                         modelMessageObjectForStream.siblingGroupId = siblingGroupIdToUse;
                         modelMessageObjectForStream.isSelected = true;

                         if (state.currentMessages[firstResponseIndexForRetry] && !state.currentMessages[firstResponseIndexForRetry].isCascaded) {
                             state.currentMessages[firstResponseIndexForRetry].isCascaded = true;
                             state.currentMessages[firstResponseIndexForRetry].siblingGroupId = siblingGroupIdToUse;
                             state.currentMessages[firstResponseIndexForRetry].isSelected = false;
                         }
                    }

                    state.currentMessages.push(modelMessageObjectForStream);
                    state.messageCollapsedStates.set(tempPlaceholderIndex, false);
                    uiUtils.appendMessage('model', modelMessageObjectForStream.content, tempPlaceholderIndex, true);
                }

                if (useStreamingForThisCall) {
                    let responseStreamIterator;
                    if (selectedApiProvider === 'gemini') {
                        responseStreamIterator = apiUtils.handleGeminiStreamingResponse(apiResponseObject);
                    } else if (selectedApiProvider === 'deepseek' || selectedApiProvider === 'llmaggregator') {
                        responseStreamIterator = apiUtils.handleDeepSeekStreamingResponse(apiResponseObject);
                    } else if (selectedApiProvider === 'claude') {
                        responseStreamIterator = apiUtils.handleClaudeStreamingResponse(apiResponseObject);
                    } else if (selectedApiProvider === 'openai') {
                        responseStreamIterator = apiUtils.handleOpenAICompatibleStreamingResponse(apiResponseObject, 'openai');
                    } else if (selectedApiProvider === 'xai') {
                        responseStreamIterator = apiUtils.handleOpenAICompatibleStreamingResponse(apiResponseObject, 'xai');
                    }

                    const currentContextStreamSpeed = selectedApiProvider === 'gemini' ? contextStreamingSpeed : 
                                                      selectedApiProvider === 'deepseek' ? state.settings.deepSeekStreamingSpeed :
                                                      selectedApiProvider === 'claude' ? state.settings.claudeStreamingSpeed :
                                                      selectedApiProvider === 'xai' ? state.settings.xaiStreamingSpeed :
                                                      selectedApiProvider === 'llmaggregator' ? state.settings.llmAggregatorStreamingSpeed :
                                                      state.settings.openaiStreamingSpeed;

                    const messageIndexForDisplay = isBackgroundProcess ? -1 : (modelMessageObjectForStream ? state.currentMessages.indexOf(modelMessageObjectForStream) : -1);

                    for await (const streamData of responseStreamIterator) {
                        if (state.abortController?.signal.aborted) {
                            modelResponseMetadata.finishReason = 'ABORTED';
                            throw new Error("リクエストがキャンセルされました。");
                        }

                        if (streamData.type === 'chunk') {
                            if (streamData.thoughtText) {
                                if (isBackgroundProcess) {
                                    modelThoughtSummaryContent += streamData.thoughtText;
                                } else {
                                    for (const char of streamData.thoughtText) {
                                        if (state.abortController?.signal.aborted) break;
                                        state.partialThoughtStreamContent += char;
                                        uiUtils.updateStreamingMessage(messageIndexForDisplay, char, true);
                                        if (currentContextStreamSpeed > 0) await sleep(currentContextStreamSpeed);
                                    }
                                }
                            }
                            if (streamData.contentText) {
                                if (isBackgroundProcess) {
                                    modelResponseRawContent += streamData.contentText;
                                } else {
                                    for (const char of streamData.contentText) {
                                        if (state.abortController?.signal.aborted) break;
                                        state.partialStreamContent += char;
                                        uiUtils.updateStreamingMessage(messageIndexForDisplay, char, false);
                                        if (currentContextStreamSpeed > 0) await sleep(currentContextStreamSpeed);
                                    }
                                }
                            }
                            if (state.abortController?.signal.aborted) {
                                modelResponseMetadata.finishReason = 'ABORTED';
                                throw new Error("リクエストがキャンセルされました。");
                            }
                            if (streamData.groundingMetadata && selectedApiProvider === 'gemini') {
                                currentGroundingMetadata = streamData.groundingMetadata;
                                if (!isBackgroundProcess && modelMessageObjectForStream && state.currentMessages.includes(modelMessageObjectForStream)) {
                                    const msgIndexForGrounding = state.currentMessages.indexOf(modelMessageObjectForStream);
                                    if (state.currentMessages[msgIndexForGrounding]) {
                                        state.currentMessages[msgIndexForGrounding].groundingMetadata = currentGroundingMetadata;
                                    }
                                }
                            }
                            if (streamData.usageMetadata) finalUsageMetadataFromStream = streamData.usageMetadata;
                        } else if (streamData.type === 'metadata') {
                            modelResponseMetadata = {
                                finishReason: streamData.finishReason,
                                safetyRatings: streamData.safetyRatings,
                            };
                            if (selectedApiProvider === 'gemini') {
                                 if (streamData.groundingMetadata) currentGroundingMetadata = streamData.groundingMetadata;
                                 if (streamData.usageMetadata) finalUsageMetadataFromStream = streamData.usageMetadata;
                            } else if (selectedApiProvider === 'deepseek' || selectedApiProvider === 'llmaggregator') {
                                if (streamData.fullReasoningContent && contextDeepSeekIncludeThoughts) {
                                    modelThoughtSummaryContent = streamData.fullReasoningContent;
                                }
                                if (streamData.usageMetadata) finalUsageMetadataFromStream = streamData.usageMetadata;
                            } else if (selectedApiProvider === 'claude' || selectedApiProvider === 'openai' || selectedApiProvider === 'xai') {
                                if (streamData.usageMetadata) finalUsageMetadataFromStream = streamData.usageMetadata;
                            }
                            break;
                        } else if (streamData.type === 'error') {
                            modelResponseMetadata.finishReason = 'ERROR';
                            modelResponseMetadata.error = streamData.error;
                            throw new Error(streamData.message || "ストリーム内でエラーが発生しました。");
                        }
                    }

                    if (!isBackgroundProcess) {
                        modelThoughtSummaryContent = state.partialThoughtStreamContent;
                        modelResponseRawContent = state.partialStreamContent;
                    }

                    if (modelResponseMetadata.finishReason === 'ABORTED' || state.abortController?.signal.aborted) {
                        throw new Error("リクエストがキャンセルされました。");
                    }

                } else {
                    const data = await apiResponseObject.json();
                    if (selectedApiProvider === 'gemini') {
                        const candidate = data.candidates?.[0];
                        let rawContentFromApi = "";
                        if (candidate) {
                            modelResponseMetadata = { finishReason: candidate.finishReason, safetyRatings: candidate.safetyRatings };
                            candidate.content?.parts?.forEach(part => {
                                if (part.thought === true && contextGeminiIncludeThoughts) {
                                    modelThoughtSummaryContent += (part.text || "") + "\n\n";
                                } else if (part.thought !== true){
                                    rawContentFromApi += (part.text || "") + "\n\n";
                                }
                            });
                            modelThoughtSummaryContent = modelThoughtSummaryContent.trim();
                            rawContentFromApi = rawContentFromApi.trim();

                            currentGroundingMetadata = candidate.groundingMetadata || null;
                            finalUsageMetadataFromStream = data.usageMetadata || null;
                            if (candidate.finishReason && candidate.finishReason !== "STOP" && candidate.finishReason !== "MAX_TOKENS") {
                                rawContentFromApi += `\n\n(理由: ${candidate.finishReason})`;
                            }
                            if (!rawContentFromApi && candidate.finishReason === "STOP" && !modelThoughtSummaryContent) {
                                rawContentFromApi = "(応答が空です)";
                            }
                        } else {
                            rawContentFromApi = "応答候補がありません";
                            if(data.promptFeedback) {
                                rawContentFromApi += ` (理由: ${data.promptFeedback.blockReason || '不明'})`;
                                modelResponseMetadata.promptFeedback = data.promptFeedback;
                                modelResponseMetadata.finishReason = data.promptFeedback.blockReason || 'ERROR';
                            } else {
                                modelResponseMetadata.finishReason = 'ERROR';
                            }
                            finalUsageMetadataFromStream = data.usageMetadata || null;
                        }
                         modelResponseRawContent = dummyModelPrefix + rawContentFromApi;
                    } else if (selectedApiProvider === 'deepseek' || selectedApiProvider === 'llmaggregator') {
                        const choice = data.choices?.[0];
                        let rawContentFromApi = "";
                        if (choice) {
                            rawContentFromApi = choice.message?.content || "";
                            modelResponseMetadata = { finishReason: choice.finish_reason };
                            if (data.usage) {
                               finalUsageMetadataFromStream = {
                                    candidatesTokenCount: data.usage.completion_tokens,
                                    totalTokenCount: data.usage.total_tokens,
                                };
                            }
                            if (contextDeepSeekIncludeThoughts && data.parsedReasoningContent) {
                                modelThoughtSummaryContent = data.parsedReasoningContent;
                            }
                        } else {
                            rawContentFromApi = `${selectedApiProvider.toUpperCase()}からの応答がありません。`;
                            modelResponseMetadata = { finishReason: 'ERROR' };
                            if (data.error) rawContentFromApi += ` (エラー: ${data.error.message})`;
                        }
                        modelResponseRawContent = dummyModelPrefix + rawContentFromApi;
                    } else if (selectedApiProvider === 'claude') {
                        let rawContentFromApi = "";
                        if (data.content && data.content.length > 0) {
                            data.content.forEach(block => {
                                if (block.type === 'text') {
                                    rawContentFromApi += block.text;
                                } else if (block.type === 'thinking' && contextClaudeIncludeThoughts) {
                                    modelThoughtSummaryContent += (block.thinking || "") + "\n\n";
                                }
                            });
                            modelThoughtSummaryContent = modelThoughtSummaryContent.trim();
                        }
                        modelResponseMetadata = { finishReason: data.stop_reason || 'stop' };
                        if (data.usage) {
                            finalUsageMetadataFromStream = {
                                candidatesTokenCount: data.usage.output_tokens,
                                totalTokenCount: data.usage.input_tokens + data.usage.output_tokens,
                            };
                        }
                        if (!rawContentFromApi && data.stop_reason === 'end_turn') {
                            rawContentFromApi = "(応答が空です)";
                        }
                        modelResponseRawContent = dummyModelPrefix + rawContentFromApi;
                    } else if (selectedApiProvider === 'openai' || selectedApiProvider === 'xai') {
                        let rawContentFromApi = "";
                        if (data.choices && data.choices.length > 0) {
                            rawContentFromApi = data.choices[0].message?.content || "";
                            modelResponseMetadata = { finishReason: data.choices[0].finish_reason };
                            if(selectedApiProvider === 'xai' && data.choices[0].message.reasoning_content) {
                                modelThoughtSummaryContent = data.choices[0].message.reasoning_content;
                            }
                        }
                        if (data.usage) {
                            let reasoningTokens = 0;
                            if (selectedApiProvider === 'xai' && data.usage.completion_tokens_details?.reasoning_tokens) {
                                reasoningTokens = data.usage.completion_tokens_details.reasoning_tokens;
                            }
                            finalUsageMetadataFromStream = {
                                candidatesTokenCount: data.usage.completion_tokens + reasoningTokens,
                                totalTokenCount: data.usage.prompt_tokens + data.usage.completion_tokens + reasoningTokens
                            };
                        }
                        if (!rawContentFromApi && modelResponseMetadata.finishReason === 'stop') {
                            rawContentFromApi = "(応答が空です)";
                        }
                        modelResponseRawContent = dummyModelPrefix + rawContentFromApi;
                    }
                }

                if (isBackgroundProcess) {
                    if (modelResponseRawContent || modelThoughtSummaryContent || modelResponseMetadata.finishReason) {
                         const bgModelMessage = {
                             role: 'model', content: modelResponseRawContent,
                             timestamp: Date.now(),
                             ...modelResponseMetadata,
                             usageMetadata: finalUsageMetadataFromStream,
                             generatedByApiProvider: selectedApiProvider
                         };
                         if (selectedApiProvider === 'gemini' && contextGeminiIncludeThoughts) {
                             bgModelMessage.thoughtSummary = modelThoughtSummaryContent || null;
                             bgModelMessage.groundingMetadata = currentGroundingMetadata;
                         } else if ((selectedApiProvider === 'deepseek' || selectedApiProvider === 'llmaggregator') && contextDeepSeekIncludeThoughts) {
                             bgModelMessage.deepSeekThoughtSummary = modelThoughtSummaryContent || null;
                         } else if (selectedApiProvider === 'claude' && contextClaudeIncludeThoughts) {
                             bgModelMessage.thoughtSummary = modelThoughtSummaryContent || null;
                         } else if (selectedApiProvider === 'xai' && contextXaiIncludeThoughts) {
                             bgModelMessage.xaiThoughtSummary = modelThoughtSummaryContent || null;
                         }

                          bgModelMessage.thoughtSummaryOpen = (selectedApiProvider === 'gemini' && state.settings.geminiExpandThoughtsByDefault) || 
                                                              (selectedApiProvider === 'deepseek' && state.settings.deepSeekExpandThoughtsByDefault) ||
                                                              (selectedApiProvider === 'claude' && state.settings.claudeExpandThoughtsByDefault) ||
                                                              (selectedApiProvider === 'xai' && state.settings.xaiExpandThoughtsByDefault) ||
                                                              (selectedApiProvider === 'llmaggregator' && state.settings.llmAggregatorExpandThoughtsByDefault);

                         currentContextMessages.push(bgModelMessage);
                         const chatToSaveBg = {
                            messages: currentContextMessages.map(msg => ({
                                role: msg.role, content: msg.content, timestamp: msg.timestamp,
                                thoughtSummary: msg.thoughtSummary || null,
                                deepSeekThoughtSummary: msg.deepSeekThoughtSummary || null,
                                xaiThoughtSummary: msg.xaiThoughtSummary || null,
                                generatedByApiProvider: msg.generatedByApiProvider || null,
                                ...(msg.finishReason && { finishReason: msg.finishReason }),
                                ...(msg.safetyRatings && { safetyRatings: msg.safetyRatings }),
                                ...(msg.error && { error: msg.error }),
                                ...(msg.isCascaded !== undefined && { isCascaded: msg.isCascaded }),
                                ...(msg.isSelected !== undefined && { isSelected: msg.isSelected }),
                                ...(msg.siblingGroupId !== undefined && { siblingGroupId: msg.siblingGroupId }),
                                ...(msg.groundingMetadata && { groundingMetadata: msg.groundingMetadata }),
                                ...(msg.attachments && msg.attachments.length > 0 && { attachments: msg.attachments.map(att => ({ name: att.name, mimeType: att.mimeType, textData: att.textData })) }),
                                ...(msg.usageMetadata && { usageMetadata: msg.usageMetadata }),
                                ...(msg.thoughtSummaryOpen !== undefined && { thoughtSummaryOpen: msg.thoughtSummaryOpen }),
                            })),
                            updatedAt: Date.now(),
                            id: sourceSessionContext.sessionId
                         };
                         const existingChatForBg = await dbUtils.getChat(sourceSessionContext.sessionId);
                         if (existingChatForBg) {
                             chatToSaveBg.createdAt = existingChatForBg.createdAt;
                             chatToSaveBg.title = existingChatForBg.title;
                         }

                         await new Promise((resolve, reject) => {
                            const store = dbUtils._getStore(CHATS_STORE, 'readwrite');
                            const request = store.put(chatToSaveBg);
                            request.onsuccess = () => resolve();
                            request.onerror = (event) => reject(`チャット保存putエラー(BG): ${event.target.error.name} - ${event.target.error.message}`);
                         });
                         return { content: modelResponseRawContent, metadata: modelResponseMetadata };
                    }
                    return { content: "", metadata: modelResponseMetadata };
                }

                if (modelResponseRawContent || modelThoughtSummaryContent || modelResponseMetadata.finishReason) {
                    if (useStreamingForThisCall && modelMessageObjectForStream) {
                        const finalModelMessageIndex = state.currentMessages.indexOf(modelMessageObjectForStream);
                        if (finalModelMessageIndex !== -1) {
                            const msgToUpdate = state.currentMessages[finalModelMessageIndex];
                            msgToUpdate.content = modelResponseRawContent;
                            msgToUpdate.timestamp = Date.now();
                            msgToUpdate.finishReason = modelResponseMetadata.finishReason;
                            msgToUpdate.safetyRatings = modelResponseMetadata.safetyRatings;
                            msgToUpdate.usageMetadata = finalUsageMetadataFromStream;
                            if (selectedApiProvider === 'gemini' && contextGeminiIncludeThoughts) {
                                msgToUpdate.thoughtSummary = modelThoughtSummaryContent || null;
                                msgToUpdate.groundingMetadata = currentGroundingMetadata;
                            } else if ((selectedApiProvider === 'deepseek' || selectedApiProvider === 'llmaggregator') && contextDeepSeekIncludeThoughts && modelThoughtSummaryContent) {
                                msgToUpdate.deepSeekThoughtSummary = modelThoughtSummaryContent || null;
                            } else if (selectedApiProvider === 'claude' && contextClaudeIncludeThoughts && modelThoughtSummaryContent) {
                                msgToUpdate.thoughtSummary = modelThoughtSummaryContent || null;
                            } else if (selectedApiProvider === 'xai' && contextXaiIncludeThoughts && modelThoughtSummaryContent) {
                                msgToUpdate.xaiThoughtSummary = modelThoughtSummaryContent || null;
                            }
                            uiUtils.finalizeStreamingMessage(finalModelMessageIndex);
                            await dbUtils.saveChat();
                        }
                    } else {
                         const newModelMessage = {
                             role: 'model', content: modelResponseRawContent,
                             timestamp: Date.now(),
                             ...modelResponseMetadata,
                             usageMetadata: finalUsageMetadataFromStream,
                             generatedByApiProvider: selectedApiProvider
                         };
                        if (selectedApiProvider === 'gemini' && contextGeminiIncludeThoughts) {
                             newModelMessage.thoughtSummary = modelThoughtSummaryContent || null;
                             newModelMessage.groundingMetadata = currentGroundingMetadata;
                        } else if ((selectedApiProvider === 'deepseek' || selectedApiProvider === 'llmaggregator') && contextDeepSeekIncludeThoughts && modelThoughtSummaryContent) {
                             newModelMessage.deepSeekThoughtSummary = modelThoughtSummaryContent || null;
                        } else if (selectedApiProvider === 'claude' && contextClaudeIncludeThoughts && modelThoughtSummaryContent) {
                             newModelMessage.thoughtSummary = modelThoughtSummaryContent || null;
                        } else if (selectedApiProvider === 'xai' && contextXaiIncludeThoughts && modelThoughtSummaryContent) {
                             newModelMessage.xaiThoughtSummary = modelThoughtSummaryContent || null;
                        }
                        newModelMessage.thoughtSummaryOpen = (selectedApiProvider === 'gemini' && state.settings.geminiExpandThoughtsByDefault) || 
                                                             (selectedApiProvider === 'deepseek' && state.settings.deepSeekExpandThoughtsByDefault) ||
                                                             (selectedApiProvider === 'claude' && state.settings.claudeExpandThoughtsByDefault) ||
                                                             (selectedApiProvider === 'xai' && state.settings.xaiExpandThoughtsByDefault) ||
                                                             (selectedApiProvider === 'llmaggregator' && state.settings.llmAggregatorExpandThoughtsByDefault);

                         const targetUserIndexForCascade = userMessageIndex;
                         if (targetUserIndexForCascade !== -1 && !isBackgroundProcess) {
                             if (siblingGroupIdToUse === null) {
                                 siblingGroupIdToUse = `gid-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
                             }
                             newModelMessage.isCascaded = true;
                             newModelMessage.isSelected = true;
                             newModelMessage.siblingGroupId = siblingGroupIdToUse;

                             if (isRetry && firstResponseIndexForRetry !== -1 && state.currentMessages[firstResponseIndexForRetry] && !state.currentMessages[firstResponseIndexForRetry].isCascaded) {
                                 state.currentMessages[firstResponseIndexForRetry].isCascaded = true;
                                 state.currentMessages[firstResponseIndexForRetry].siblingGroupId = siblingGroupIdToUse;
                             }
                         }

                         const newModelIndex = state.currentMessages.length;
                         state.currentMessages.push(newModelMessage);
                         state.messageCollapsedStates.set(newModelIndex, false);
                         state.thoughtSummaryOpenStates.set(newModelIndex, newModelMessage.thoughtSummaryOpen);
                         uiUtils.renderChatMessages();
                         await dbUtils.saveChat();
                    }
                } else {
                     if (useStreamingForThisCall && !isBackgroundProcess && modelMessageObjectForStream) {
                        const tempPlaceholderIndex = state.currentMessages.indexOf(modelMessageObjectForStream);
                        const placeholderElement = document.getElementById(`streaming-message-${tempPlaceholderIndex}`);
                        if (placeholderElement) placeholderElement.remove();
                        if(tempPlaceholderIndex !== -1) state.currentMessages.splice(tempPlaceholderIndex, 1);
                    }
                }
            } catch (error) {
                const isAbort = error.message === "リクエストがキャンセルされました。" || modelResponseMetadata.finishReason === 'ABORTED';
                const displayErrorMessage = isAbort ? error.message : (error.message || "不明なエラーが発生しました");

                let partialThoughtContentOnError, partialContentOnError;
                partialThoughtContentOnError = state.partialThoughtStreamContent;
                partialContentOnError = state.partialStreamContent;

                if (isBackgroundProcess) {
                     throw error;
                }

                if ((partialContentOnError || partialContentOnError) && useStreamingForThisCall && modelMessageObjectForStream) {
                     const finalPartialContent = partialContentOnError + `\n\n(${isAbort ? '中断されました' : 'エラーが発生しました'})`;
                     let finalPartialThoughtValue = null;
                     if (selectedApiProvider === 'gemini' && partialThoughtContentOnError && contextGeminiIncludeThoughts) {
                         finalPartialThoughtValue = partialThoughtContentOnError + `\n\n(${isAbort ? '中断されました' : 'エラーが発生しました'})`;
                     } else if ((selectedApiProvider === 'deepseek' || selectedApiProvider === 'llmaggregator') && partialThoughtContentOnError && contextDeepSeekIncludeThoughts) {
                         finalPartialThoughtValue = partialThoughtContentOnError + `\n\n(${isAbort ? '中断されました' : 'エラーが発生しました'})`;
                     } else if (selectedApiProvider === 'claude' && partialThoughtContentOnError && contextClaudeIncludeThoughts) {
                         finalPartialThoughtValue = partialThoughtContentOnError + `\n\n(${isAbort ? '中断されました' : 'エラーが発生しました'})`;
                     } else if (selectedApiProvider === 'xai' && partialThoughtContentOnError && contextXaiIncludeThoughts) {
                         finalPartialThoughtValue = partialThoughtContentOnError + `\n\n(${isAbort ? '中断されました' : 'エラーが発生しました'})`;
                     }

                    const streamingMessageIndex = state.currentMessages.indexOf(modelMessageObjectForStream);
                    if (streamingMessageIndex !== -1) {
                        const msgToUpdate = state.currentMessages[streamingMessageIndex];
                        msgToUpdate.content = finalPartialContent;
                        msgToUpdate.timestamp = Date.now();
                        msgToUpdate.error = true;
                        msgToUpdate.finishReason = isAbort ? 'ABORTED' : (modelResponseMetadata.finishReason || 'ERROR');
                        msgToUpdate.safetyRatings = modelResponseMetadata.safetyRatings;
                        msgToUpdate.usageMetadata = finalUsageMetadataFromStream;
                        msgToUpdate.generatedByApiProvider = selectedApiProvider;

                        if (selectedApiProvider === 'gemini') {
                            msgToUpdate.thoughtSummary = finalPartialThoughtValue;
                            msgToUpdate.groundingMetadata = currentGroundingMetadata;
                        } else if (selectedApiProvider === 'deepseek' || selectedApiProvider === 'llmaggregator') {
                            msgToUpdate.deepSeekThoughtSummary = finalPartialThoughtValue;
                        } else if (selectedApiProvider === 'claude') {
                            msgToUpdate.thoughtSummary = finalPartialThoughtValue;
                        } else if (selectedApiProvider === 'xai') {
                            msgToUpdate.xaiThoughtSummary = finalPartialThoughtValue;
                        }

                         try {
                            uiUtils.finalizeStreamingMessage(streamingMessageIndex);
                            await dbUtils.saveChat();
                         } catch (saveError) {
                             uiUtils.displayError(displayErrorMessage, !isAbort);
                         }
                    } else {
                         uiUtils.displayError(displayErrorMessage, !isAbort);
                    }
                } else {
                    if (useStreamingForThisCall && !isAbort && modelMessageObjectForStream) {
                        const tempPlaceholderIndex = state.currentMessages.indexOf(modelMessageObjectForStream);
                        const placeholderElement = document.getElementById(`streaming-message-${tempPlaceholderIndex}`);
                        if (placeholderElement) placeholderElement.remove();
                        if(tempPlaceholderIndex !== -1) state.currentMessages.splice(tempPlaceholderIndex, 1);
                    }
                    uiUtils.displayError(displayErrorMessage, !isAbort);
                }
            } finally {
                if (!isBackgroundProcess) {
                    uiUtils.setSendingState(false);
                    state.abortController = null;
                    state.partialStreamContent = '';
                    state.partialThoughtStreamContent = '';
                    if (state.settings.autoScrollOnNewMessage) {
                        uiUtils.scrollToBottom();
                    }
                    uiUtils.updateAttachmentBadgeVisibility();
                }
            }
            if (isBackgroundProcess) return null;
        },
        async toggleApiProvider() {
            if(state.isSending || state.isAiToAiChatProcessing) {
                await uiUtils.showCustomAlert('現在処理中のため、APIプロバイダーを変更できません。');
                return;
            }
            const providersInCycle = Object.entries(state.settings.apiProviderCycle)
                                            .filter(([, isEnabled]) => isEnabled)
                                            .map(([provider]) => provider);

            if (providersInCycle.length === 0) {
                await uiUtils.showCustomAlert('切り替え可能なAPIプロバイダーが選択されていません。設定を確認してください。');
                return;
            }

            const currentIndex = providersInCycle.indexOf(state.settings.apiProvider);
            const nextIndex = (currentIndex + 1) % providersInCycle.length;
            state.settings.apiProvider = providersInCycle[nextIndex];

            try {
                await dbUtils.saveSetting('apiProvider', state.settings.apiProvider);
                elements.apiProviderSelect.value = state.settings.apiProvider;
                uiUtils.updateChatScreenElementVisibility();
                uiUtils.toggleApiSettingsVisibility(state.settings.apiProvider);
                uiUtils.adjustTextareaHeight();
            } catch (error) {
                await uiUtils.showCustomAlert(`APIプロバイダー設定の保存に失敗しました: ${error.message}`);
                state.settings.apiProvider = providersInCycle[currentIndex >= 0 ? currentIndex : 0];
                elements.apiProviderSelect.value = state.settings.apiProvider;
                uiUtils.updateChatScreenElementVisibility();
            }
        },
        abortRequest() {
            if (state.abortController) {
                state.abortController.abort();
            }
        },
        async handleHistoryImport(file) {
            if (!file || !file.type.startsWith('text/plain')) {
                await uiUtils.showCustomAlert("テキストファイル (.txt) を選択してください。");
                return;
            }
            const reader = new FileReader();
            reader.onload = async (event) => {
                const textContent = event.target.result;
                if (!textContent) {
                    await uiUtils.showCustomAlert("ファイルの内容が空です。");
                    return;
                }
                try {
                    const { messages: importedMessages } = this.parseImportedHistory(textContent);
                    if (importedMessages.length === 0) {
                        await uiUtils.showCustomAlert("ファイルから有効なメッセージまたはシステムプロンプトを読み込めませんでした。形式を確認してください。");
                        return;
                    }

                    let currentGroupId = null;
                    let lastUserIndex = -1;
                    for (let i = 0; i < importedMessages.length; i++) {
                        const msg = importedMessages[i];
                        if (msg.role === 'user') {
                            lastUserIndex = i;
                            currentGroupId = null;
                        } else if (msg.role === 'model' && msg.isCascaded) {
                            if (currentGroupId === null && lastUserIndex !== -1) {
                                currentGroupId = `imp-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
                            }
                            if (currentGroupId) {
                                msg.siblingGroupId = currentGroupId;
                            }
                        } else {
                            currentGroupId = null;
                        }
                    }
                    const groupIds = new Set(importedMessages.filter(m => m.siblingGroupId).map(m => m.siblingGroupId));
                    groupIds.forEach(gid => {
                        const siblings = importedMessages.filter(m => m.siblingGroupId === gid);
                        const selected = siblings.filter(m => m.isSelected);
                        if (selected.length === 0 && siblings.length > 0) {
                            siblings[siblings.length - 1].isSelected = true;
                        } else if (selected.length > 1) {
                            selected.slice(0, -1).forEach(m => m.isSelected = false);
                        }
                    });


                    const fileNameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
                    const titlePrefix = state.settings.addPrefixOnImport ? IMPORT_PREFIX : '';
                    const newTitle = titlePrefix + (fileNameWithoutExt || `Imported_${Date.now()}`);

                    const newChatData = {
                        messages: importedMessages,
                        updatedAt: Date.now(), createdAt: Date.now(),
                        title: newTitle.substring(0, 100)
                    };
                    const newChatId = await new Promise((resolve, reject) => {
                        const store = dbUtils._getStore(CHATS_STORE, 'readwrite');
                        const request = store.add(newChatData);
                        request.onsuccess = (event) => resolve(event.target.result);
                        request.onerror = (event) => reject(event.target.error);
                    });
                    await uiUtils.showCustomAlert(`履歴「${newChatData.title}」をインポートしました。`);
                    uiUtils.renderHistoryList();
                } catch (error) {
                    await uiUtils.showCustomAlert(`履歴のインポート中にエラーが発生しました: ${error.message}`);
                }
            };
            reader.onerror = async (event) => {
                await uiUtils.showCustomAlert("ファイルの読み込みに失敗しました。");
            };
            reader.readAsText(file);
        },
        parseImportedHistory(text) {
            const messages = [];
            const blockRegex = /<\|#\|(system|user|model)\|#\|([^>]*)>([\s\S]*?)<\|#\|\/\1\|#\|>/g;
            let match;

            while ((match = blockRegex.exec(text)) !== null) {
                const role = match[1];
                const attributesString = match[2].trim();
                const content = match[3].trim();

                if ((role === 'user' || role === 'model') && (content || attributesString.includes('attachments'))) {
                    const messageData = {
                        role: role, content: content, timestamp: Date.now(), attachments: []
                    };
                    const attributes = {};
                    attributesString.split(/\s+/).forEach(attr => {
                        const eqIndex = attr.indexOf('=');
                        if (eqIndex > 0) {
                            const key = attr.substring(0, eqIndex);
                            let value = attr.substring(eqIndex + 1);
                            if (value.startsWith('"') && value.endsWith('"')) {
                                value = value.substring(1, value.length - 1);
                            }
                            attributes[key] = value.replace(/&quot;/g, '"');
                        } else if (attr) {
                            attributes[attr] = true;
                        }
                    });

                    if (role === 'model') {
                        messageData.isCascaded = attributes['isCascaded'] === true;
                        messageData.isSelected = attributes['isSelected'] === true;
                        messageData.thoughtSummaryOpen = attributes['thoughtOpen'] === true;
                    }
                    if (role === 'user' && attributes['attachments']) {
                        const fileNames = attributes['attachments'].split(';');
                        messageData.attachments = fileNames.map(name => ({
                            name: name, mimeType: 'unknown/unknown', base64Data: ''
                        }));
                    }
                    messages.push(messageData);
                }
            }
            return { messages };
        },
        async exportAllSessions() {
            const confirmed = await uiUtils.showCustomConfirm("全てのセッションを1つのJSONファイルとしてエクスポートしますか？");
            if (!confirmed) return;

            try {
                const chats = await dbUtils.getAllChats();
                if (!chats || chats.length === 0) {
                    await uiUtils.showCustomAlert("エクスポートするセッションがありません。");
                    return;
                }

                const exportableChats = chats.map(chat => ({
                    title: chat.title,
                    messages: chat.messages.map(msg => {
                        const messageExport = {
                            role: msg.role,
                            content: msg.content,
                            timestamp: msg.timestamp,
                            generatedByApiProvider: msg.generatedByApiProvider || null,
                        };
                        if (msg.isCascaded !== undefined) messageExport.isCascaded = msg.isCascaded;
                        if (msg.isSelected !== undefined) messageExport.isSelected = msg.isSelected;
                        if (msg.siblingGroupId !== undefined) messageExport.siblingGroupId = msg.siblingGroupId;
                        if (msg.groundingMetadata) messageExport.groundingMetadata = msg.groundingMetadata;
                        if (msg.usageMetadata) messageExport.usageMetadata = msg.usageMetadata;
                        if (msg.thoughtSummary) messageExport.thoughtSummary = msg.thoughtSummary;
                        if (msg.deepSeekThoughtSummary) messageExport.deepSeekThoughtSummary = msg.deepSeekThoughtSummary;
                        if (msg.thoughtSummaryOpen !== undefined) messageExport.thoughtSummaryOpen = msg.thoughtSummaryOpen;
                        if (msg.attachments && msg.attachments.length > 0) {
                            messageExport.attachments = msg.attachments.map(att => ({ name: att.name, mimeType: att.mimeType, textData: att.textData }));
                        }
                        return messageExport;
                    }),
                    createdAt: chat.createdAt,
                    updatedAt: chat.updatedAt,
                    ...(state.settings.persistMessageCollapseState && chat.collapsedStates && { collapsedStates: chat.collapsedStates })
                }));

                const jsonString = JSON.stringify(exportableChats, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                a.href = url;
                a.download = `gemini_pwa_all_sessions_${timestamp}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                await uiUtils.showCustomAlert(`${chats.length}件のセッションをエクスポートしました。`);
            } catch (error) {
                await uiUtils.showCustomAlert(`全セッションのエクスポート中にエラーが発生しました: ${error.message || error}`);
            }
        },
        async handleAllSessionsImport(file) {
            if (!file || file.type !== 'application/json') {
                await uiUtils.showCustomAlert("JSONファイル (.json) を選択してください。");
                return;
            }
            const reader = new FileReader();
            reader.onload = async (event) => {
                const textContent = event.target.result;
                if (!textContent) {
                    await uiUtils.showCustomAlert("ファイルの内容が空です。");
                    return;
                }
                try {
                    const importedData = JSON.parse(textContent);
                    if (!Array.isArray(importedData)) {
                        await uiUtils.showCustomAlert("無効なファイル形式です。チャットデータの配列ではありません。");
                        return;
                    }

                    if (importedData.length === 0) {
                        await uiUtils.showCustomAlert("ファイルにインポート対象のセッションデータが含まれていません。");
                        return;
                    }

                    const confirmed = await uiUtils.showCustomConfirm(
                        `${importedData.length}件のセッションをインポートしますか？\n(既存の履歴とタイトルが重複する場合、別履歴として追加されます)`
                    );
                    if (!confirmed) return;

                    let importedCount = 0;
                    let skippedCount = 0;
                    const importTimestamp = Date.now();

                    for (const chatData of importedData) {
                        if (typeof chatData.title !== 'string' || !Array.isArray(chatData.messages)) {
                            skippedCount++;
                            continue;
                        }

                        const titlePrefix = state.settings.addPrefixOnImport ? `${IMPORT_PREFIX}(全) ` : '';
                        const newChat = {
                            title: `${titlePrefix}${chatData.title}`.substring(0,100),
                            messages: (chatData.messages || []).map(msg => ({
                                role: msg.role,
                                content: msg.content || '',
                                timestamp: typeof msg.timestamp === 'number' ? msg.timestamp : importTimestamp,
                                isCascaded: msg.isCascaded === true,
                                isSelected: msg.isSelected === true,
                                siblingGroupId: msg.siblingGroupId || undefined,
                                thoughtSummary: msg.thoughtSummary || undefined,
                                deepSeekThoughtSummary: msg.deepSeekThoughtSummary || undefined,
                                thoughtSummaryOpen: msg.thoughtSummaryOpen || false,
                                generatedByApiProvider: msg.generatedByApiProvider || undefined,
                                attachments: (msg.attachments || []).map(att => ({
                                    name: att.name || 'imported_file',
                                    mimeType: att.mimeType || 'application/octet-stream',
                                    base64Data: '',
                                    textData: att.textData || ''
                                })),
                                groundingMetadata: msg.groundingMetadata || undefined,
                                usageMetadata: msg.usageMetadata || undefined,
                                error: msg.error || undefined,
                            })),
                            createdAt: typeof chatData.createdAt === 'number' ? chatData.createdAt : importTimestamp,
                            updatedAt: typeof chatData.updatedAt === 'number' ? chatData.updatedAt : importTimestamp,
                        };
                        if (state.settings.persistMessageCollapseState && chatData.collapsedStates) {
                            newChat.collapsedStates = { ...chatData.collapsedStates };
                        }

                        const groupIds = new Set(newChat.messages.filter(m => m.siblingGroupId).map(m => m.siblingGroupId));
                        groupIds.forEach(gid => {
                            const siblings = newChat.messages.filter(m => m.siblingGroupId === gid);
                            const selectedSiblings = siblings.filter(m => m.isSelected);
                            if (selectedSiblings.length === 0 && siblings.length > 0) {
                                siblings[siblings.length - 1].isSelected = true;
                            } else if (selectedSiblings.length > 1) {
                                for (let i = 0; i < selectedSiblings.length - 1; i++) {
                                    selectedSiblings[i].isSelected = false;
                                }
                            }
                        });

                        try {
                            await new Promise((resolve, reject) => {
                                const store = dbUtils._getStore(CHATS_STORE, 'readwrite');
                                const request = store.add(newChat);
                                request.onsuccess = () => {
                                    importedCount++;
                                    resolve();
                                };
                                request.onerror = (e) => {
                                    skippedCount++;
                                    resolve();
                                };
                            });
                        } catch (e) {
                            skippedCount++;
                        }
                    }

                    let message = `${importedCount}件のセッションをインポートしました。`;
                    if (skippedCount > 0) {
                        message += ` ${skippedCount}件は形式エラー等でスキップされました。`;
                    }
                    await uiUtils.showCustomAlert(message);
                    if (importedCount > 0) {
                        uiUtils.renderHistoryList();
                    }

                } catch (error) {
                    await uiUtils.showCustomAlert(`全セッションのインポート中にエラーが発生しました: ${error.message || error}`);
                }
            };
            reader.onerror = async () => {
                await uiUtils.showCustomAlert("ファイルの読み込みに失敗しました。");
            };
            reader.readAsText(file);
        },
         async handleBackgroundImageUpload(file) {
             const maxSize = 5 * 1024 * 1024;
             if (file.size > maxSize) {
                 await uiUtils.showCustomAlert(`画像サイズが大きすぎます (${(maxSize / 1024 / 1024).toFixed(1)}MB以下にしてください)`);
                 return;
             }
             if (!file.type.startsWith('image/')) {
                 await uiUtils.showCustomAlert("画像ファイルを選択してください (JPEG, PNG, GIF, WebPなど)");
                 return;
             }

             try {
                 uiUtils.revokeExistingObjectUrl();
                 const blob = file;
                 await dbUtils.saveSetting('backgroundImageBlob', blob);
                 state.settings.backgroundImageBlob = blob;
                 state.backgroundImageUrl = URL.createObjectURL(blob);
                 document.documentElement.style.setProperty('--chat-background-image', `url(${state.backgroundImageUrl})`);
                 uiUtils.updateBackgroundSettingsUI();
             } catch (error) {
                 uiUtils.revokeExistingObjectUrl();
                 document.documentElement.style.setProperty('--chat-background-image', 'none');
                 state.settings.backgroundImageBlob = null;
                 uiUtils.updateBackgroundSettingsUI();
             }
         },
         async confirmDeleteBackgroundImage() {
             const confirmed = await uiUtils.showCustomConfirm("背景画像を削除しますか？");
             if (confirmed) {
                 await this.handleBackgroundImageDelete();
             }
         },
         async handleBackgroundImageDelete() {
             try {
                 uiUtils.revokeExistingObjectUrl();
                 await dbUtils.saveSetting('backgroundImageBlob', null);
                 state.settings.backgroundImageBlob = null;
                 document.documentElement.style.setProperty('--chat-background-image', 'none');
                 uiUtils.updateBackgroundSettingsUI();
             } catch (error) {
             }
         },
        async handleIconUpload(type, file) {
             const maxSize = 1 * 1024 * 1024;
             if (file.size > maxSize) {
                 await uiUtils.showCustomAlert(`画像サイズが大きすぎます (${(maxSize / 1024 / 1024).toFixed(1)}MB以下)。`);
                 return;
             }
             if (!file.type.startsWith('image/')) {
                 await uiUtils.showCustomAlert("画像ファイルを選択してください。");
                 return;
             }

             try {
                 const blob = file;
                 if (type === 'user') {
                     if(state.userIconUrl) URL.revokeObjectURL(state.userIconUrl);
                     await dbUtils.saveSetting('userIconBlob', blob);
                     state.settings.userIconBlob = blob;
                     state.userIconUrl = URL.createObjectURL(blob);
                 } else if (type === 'ai') {
                     if(state.aiIconUrl) URL.revokeObjectURL(state.aiIconUrl);
                     await dbUtils.saveSetting('aiIconBlob', blob);
                     state.settings.aiIconBlob = blob;
                     state.aiIconUrl = URL.createObjectURL(blob);
                 }
                 uiUtils.updateIconSettingsUI();
                 uiUtils.renderChatMessages(true);
             } catch (error) {
                 await uiUtils.showCustomAlert(`${type === 'user' ? 'ユーザー' : 'AI'}アイコンの処理エラー: ${error}`);
             }
        },
        async confirmDeleteIcon(type) {
            const iconName = type === 'user' ? 'ユーザー' : 'AI';
            const confirmed = await uiUtils.showCustomConfirm(`${iconName}アイコンを削除しますか？`);
            if (confirmed) {
                await this.handleIconDelete(type);
            }
        },
        async handleIconDelete(type) {
             try {
                 if (type === 'user') {
                     if (state.userIconUrl) URL.revokeObjectURL(state.userIconUrl);
                     state.userIconUrl = null;
                     state.settings.userIconBlob = null;
                     await dbUtils.saveSetting('userIconBlob', null);
                 } else if (type === 'ai') {
                     if (state.aiIconUrl) URL.revokeObjectURL(state.aiIconUrl);
                     state.aiIconUrl = null;
                     state.settings.aiIconBlob = null;
                     await dbUtils.saveSetting('aiIconBlob', null);
                 }
                 uiUtils.updateIconSettingsUI();
                 uiUtils.renderChatMessages(true);
             } catch (error) {
                 await uiUtils.showCustomAlert(`${type === 'user' ? 'ユーザー' : 'AI'}アイコンの削除エラー: ${error}`);
             }
        },
        async saveSettings(showNotice = true) {
            const newSettings = { ...state.settings };
            newSettings.showMultiApiKeys = elements.showMultiApiKeysToggle.checked;
            newSettings.disableSaveSettingsConfirmation = elements.disableSaveSettingsConfirmationToggle.checked;
            newSettings.autoSaveSettings = elements.autoSaveSettingsToggle.checked;

            if (newSettings.showMultiApiKeys) {
            } else {
                newSettings.apiKey = elements.geminiApiKeyInput.value.trim();
                newSettings.deepSeekApiKey = elements.deepSeekApiKeyInput.value.trim();
                newSettings.claudeApiKey = elements.claudeApiKeyInput.value.trim();
                newSettings.openaiApiKey = elements.openaiApiKeyInput.value.trim();
                newSettings.xaiApiKey = elements.xaiApiKeyInput.value.trim();
                newSettings.llmAggregatorApiKey = elements.llmAggregatorApiKeyInput.value.trim();
            }

             newSettings.apiProvider = elements.apiProviderSelect.value;
             newSettings.modelName = elements.geminiModelNameSelect.value;
             newSettings.additionalModels = elements.geminiAdditionalModelsTextarea.value.trim();
             newSettings.commonSystemPrompt = elements.commonSystemPromptDefaultTextarea.value.trim();
             newSettings.enableCommonSystemPromptDefault = elements.enableCommonSystemPromptDefaultCheckbox.checked;
             
             newSettings.deepSeekModelName = elements.deepSeekModelNameSelect.value;
             newSettings.deepSeekAdditionalModels = elements.deepSeekAdditionalModelsTextarea.value.trim();
             newSettings.deepSeekApiEndpoint = elements.deepSeekApiEndpointInput.value.trim();
             newSettings.claudeModelName = elements.claudeModelNameSelect.value;
             newSettings.claudeAdditionalModels = elements.claudeAdditionalModelsTextarea.value.trim();
             newSettings.openaiModelName = elements.openaiModelNameSelect.value;
             newSettings.openaiAdditionalModels = elements.openaiAdditionalModelsTextarea.value.trim();
             newSettings.xaiModelName = elements.xaiModelNameSelect.value;
             newSettings.xaiAdditionalModels = elements.xaiAdditionalModelsTextarea.value.trim();
             newSettings.llmAggregatorApiBackend = elements.llmAggregatorApiBackendInput.value.trim();
             newSettings.llmAggregatorModelName = elements.llmAggregatorModelNameSelect.value;
             newSettings.llmAggregatorAdditionalModels = elements.llmAggregatorAdditionalModelsTextarea.value.trim();

            newSettings.geminiSystemPrompt = elements.geminiSystemPromptDefaultTextarea.value.trim();
            newSettings.geminiEnableSystemPromptDefault = elements.geminiEnableSystemPromptDefaultCheckbox.checked;
            newSettings.geminiTemperature = elements.geminiTemperatureInput.value === '' ? null : parseFloat(elements.geminiTemperatureInput.value);
            newSettings.geminiMaxTokens = elements.geminiMaxTokensInput.value === '' ? null : parseInt(elements.geminiMaxTokensInput.value);
            newSettings.geminiTopK = elements.geminiTopKInput.value === '' ? null : parseInt(elements.geminiTopKInput.value);
            newSettings.geminiTopP = elements.geminiTopPInput.value === '' ? null : parseFloat(elements.geminiTopPInput.value);
            newSettings.geminiPresencePenalty = elements.geminiPresencePenaltyInput.value === '' ? null : parseFloat(elements.geminiPresencePenaltyInput.value);
            newSettings.geminiFrequencyPenalty = elements.geminiFrequencyPenaltyInput.value === '' ? null : parseFloat(elements.geminiFrequencyPenaltyInput.value);
            newSettings.geminiThinkingBudget = elements.geminiThinkingBudgetInput.value === '' ? null : parseInt(elements.geminiThinkingBudgetInput.value, 10);
            newSettings.geminiIncludeThoughts = elements.geminiIncludeThoughtsToggle.checked;
            newSettings.geminiExpandThoughtsByDefault = elements.geminiExpandThoughtsByDefaultToggle.checked;
            newSettings.geminiStreamingOutput = elements.geminiStreamingOutputCheckbox.checked;
            newSettings.geminiStreamingSpeed = elements.geminiStreamingSpeedInput.value === '' ? DEFAULT_STREAMING_SPEED : parseInt(elements.geminiStreamingSpeedInput.value);
            newSettings.geminiDummyUser = elements.geminiDummyUserInput.value.trim();
            newSettings.geminiEnableDummyUser = elements.geminiEnableDummyUserCheckbox.checked;
            newSettings.geminiDummyModel = elements.geminiDummyModelInput.value.trim();
            newSettings.geminiEnableDummyModel = elements.geminiEnableDummyModelCheckbox.checked;
            newSettings.geminiConcatDummyModel = elements.geminiConcatDummyModelCheckbox.checked;
            newSettings.geminiPseudoStreaming = elements.geminiPseudoStreamingCheckbox.checked;
            newSettings.geminiEnableGrounding = elements.geminiEnableGroundingToggle.checked;

            newSettings.deepSeekSystemPrompt = elements.deepSeekSystemPromptDefaultTextarea.value.trim();
            newSettings.deepSeekEnableSystemPromptDefault = elements.deepSeekEnableSystemPromptDefaultCheckbox.checked;
            newSettings.deepSeekTemperature = elements.deepSeekTemperatureInput.value === '' ? null : parseFloat(elements.deepSeekTemperatureInput.value);
            newSettings.deepSeekMaxTokens = elements.deepSeekMaxTokensInput.value === '' ? null : parseInt(elements.deepSeekMaxTokensInput.value);
            newSettings.deepSeekTopP = elements.deepSeekTopPInput.value === '' ? null : parseFloat(elements.deepSeekTopPInput.value);
            newSettings.deepSeekPresencePenalty = elements.deepSeekPresencePenaltyInput.value === '' ? null : parseFloat(elements.deepSeekPresencePenaltyInput.value);
            newSettings.deepSeekFrequencyPenalty = elements.deepSeekFrequencyPenaltyInput.value === '' ? null : parseFloat(elements.deepSeekFrequencyPenaltyInput.value);
            newSettings.deepSeekIncludeDeepSeekThoughts = elements.deepSeekIncludeThoughtsToggle.checked;
            newSettings.deepSeekExpandThoughtsByDefault = elements.deepSeekExpandThoughtsByDefaultToggle.checked;
            newSettings.deepSeekStreamingOutput = elements.deepSeekStreamingOutputCheckbox.checked;
            newSettings.deepSeekStreamingSpeed = elements.deepSeekStreamingSpeedInput.value === '' ? DEFAULT_STREAMING_SPEED : parseInt(elements.deepSeekStreamingSpeedInput.value);
            newSettings.deepSeekDummyUser = elements.deepSeekDummyUserInput.value.trim();
            newSettings.deepSeekEnableDummyUser = elements.deepSeekEnableDummyUserCheckbox.checked;
            newSettings.deepSeekDummyModel = elements.deepSeekDummyModelInput.value.trim();
            newSettings.deepSeekEnableDummyModel = elements.deepSeekEnableDummyModelCheckbox.checked;
            newSettings.deepSeekConcatDummyModel = elements.deepSeekConcatDummyModelCheckbox.checked;

            newSettings.claudeSystemPrompt = elements.claudeSystemPromptDefaultTextarea.value.trim();
            newSettings.claudeEnableSystemPromptDefault = elements.claudeEnableSystemPromptDefaultCheckbox.checked;
            newSettings.claudeTemperature = elements.claudeTemperatureInput.value === '' ? null : parseFloat(elements.claudeTemperatureInput.value);
            newSettings.claudeMaxTokens = elements.claudeMaxTokensInput.value === '' ? null : parseInt(elements.claudeMaxTokensInput.value);
            newSettings.claudeTopK = elements.claudeTopKInput.value === '' ? null : parseInt(elements.claudeTopKInput.value);
            newSettings.claudeTopP = elements.claudeTopPInput.value === '' ? null : parseFloat(elements.claudeTopPInput.value);
            newSettings.claudeStreamingOutput = elements.claudeStreamingOutputCheckbox.checked;
            newSettings.claudeStreamingSpeed = elements.claudeStreamingSpeedInput.value === '' ? DEFAULT_STREAMING_SPEED : parseInt(elements.claudeStreamingSpeedInput.value);
            newSettings.claudeDummyUser = elements.claudeDummyUserInput.value.trim();
            newSettings.claudeEnableDummyUser = elements.claudeEnableDummyUserCheckbox.checked;
            newSettings.claudeDummyModel = elements.claudeDummyModelInput.value.trim();
            newSettings.claudeEnableDummyModel = elements.claudeEnableDummyModelCheckbox.checked;
            newSettings.claudeConcatDummyModel = elements.claudeConcatDummyModelCheckbox.checked;
            newSettings.claudeIncludeThoughts = elements.claudeIncludeThoughtsToggle.checked;
            newSettings.claudeExpandThoughtsByDefault = elements.claudeExpandThoughtsByDefaultToggle.checked;
            newSettings.claudeThinkingBudget = elements.claudeThinkingBudgetInput.value === '' ? null : parseInt(elements.claudeThinkingBudgetInput.value, 10);

            newSettings.openaiSystemPrompt = elements.openaiSystemPromptDefaultTextarea.value.trim();
            newSettings.openaiEnableSystemPromptDefault = elements.openaiEnableSystemPromptDefaultCheckbox.checked;
            newSettings.openaiTemperature = elements.openaiTemperatureInput.value === '' ? null : parseFloat(elements.openaiTemperatureInput.value);
            newSettings.openaiMaxTokens = elements.openaiMaxTokensInput.value === '' ? null : parseInt(elements.openaiMaxTokensInput.value);
            newSettings.openaiTopP = elements.openaiTopPInput.value === '' ? null : parseFloat(elements.openaiTopPInput.value);
            newSettings.openaiPresencePenalty = elements.openaiPresencePenaltyInput.value === '' ? null : parseFloat(elements.openaiPresencePenaltyInput.value);
            newSettings.openaiFrequencyPenalty = elements.openaiFrequencyPenaltyInput.value === '' ? null : parseFloat(elements.openaiFrequencyPenaltyInput.value);
            newSettings.openaiStreamingOutput = elements.openaiStreamingOutputCheckbox.checked;
            newSettings.openaiStreamingSpeed = elements.openaiStreamingSpeedInput.value === '' ? DEFAULT_STREAMING_SPEED : parseInt(elements.openaiStreamingSpeedInput.value);
            newSettings.openaiDummyUser = elements.openaiDummyUserInput.value.trim();
            newSettings.openaiEnableDummyUser = elements.openaiEnableDummyUserCheckbox.checked;
            newSettings.openaiDummyModel = elements.openaiDummyModelInput.value.trim();
            newSettings.openaiEnableDummyModel = elements.openaiEnableDummyModelCheckbox.checked;
            newSettings.openaiConcatDummyModel = elements.openaiConcatDummyModelCheckbox.checked;
            
            newSettings.xaiSystemPrompt = elements.xaiSystemPromptDefaultTextarea.value.trim();
            newSettings.xaiEnableSystemPromptDefault = elements.xaiEnableSystemPromptDefaultCheckbox.checked;
            newSettings.xaiTemperature = elements.xaiTemperatureInput.value === '' ? null : parseFloat(elements.xaiTemperatureInput.value);
            newSettings.xaiMaxTokens = elements.xaiMaxTokensInput.value === '' ? null : parseInt(elements.xaiMaxTokensInput.value);
            newSettings.xaiTopP = elements.xaiTopPInput.value === '' ? null : parseFloat(elements.xaiTopPInput.value);
            newSettings.xaiPresencePenalty = elements.xaiPresencePenaltyInput.value === '' ? null : parseFloat(elements.xaiPresencePenaltyInput.value);
            newSettings.xaiFrequencyPenalty = elements.xaiFrequencyPenaltyInput.value === '' ? null : parseFloat(elements.xaiFrequencyPenaltyInput.value);
            newSettings.xaiStreamingOutput = elements.xaiStreamingOutputCheckbox.checked;
            newSettings.xaiStreamingSpeed = elements.xaiStreamingSpeedInput.value === '' ? DEFAULT_STREAMING_SPEED : parseInt(elements.xaiStreamingSpeedInput.value);
            newSettings.xaiDummyUser = elements.xaiDummyUserInput.value.trim();
            newSettings.xaiEnableDummyUser = elements.xaiEnableDummyUserCheckbox.checked;
            newSettings.xaiDummyModel = elements.xaiDummyModelInput.value.trim();
            newSettings.xaiEnableDummyModel = elements.xaiEnableDummyModelCheckbox.checked;
            newSettings.xaiConcatDummyModel = elements.xaiConcatDummyModelCheckbox.checked;
            newSettings.xaiVisionEnable = elements.xaiVisionEnableCheckbox.checked;
            newSettings.xaiIncludeThoughts = elements.xaiIncludeThoughtsToggle.checked;
            newSettings.xaiExpandThoughtsByDefault = elements.xaiExpandThoughtsByDefaultToggle.checked;
            newSettings.xaiReasoningEffort = elements.xaiReasoningEffortSelect.value;
            
            newSettings.llmAggregatorSystemPrompt = elements.llmAggregatorSystemPromptDefaultTextarea.value.trim();
            newSettings.llmAggregatorEnableSystemPromptDefault = elements.llmAggregatorEnableSystemPromptDefaultCheckbox.checked;
            newSettings.llmAggregatorTemperature = elements.llmAggregatorTemperatureInput.value === '' ? null : parseFloat(elements.llmAggregatorTemperatureInput.value);
            newSettings.llmAggregatorMaxTokens = elements.llmAggregatorMaxTokensInput.value === '' ? null : parseInt(elements.llmAggregatorMaxTokensInput.value);
            newSettings.llmAggregatorTopP = elements.llmAggregatorTopPInput.value === '' ? null : parseFloat(elements.llmAggregatorTopPInput.value);
            newSettings.llmAggregatorTopK = elements.llmAggregatorTopKInput.value === '' ? null : parseInt(elements.llmAggregatorTopKInput.value);
            newSettings.llmAggregatorPresencePenalty = elements.llmAggregatorPresencePenaltyInput.value === '' ? null : parseFloat(elements.llmAggregatorPresencePenaltyInput.value);
            newSettings.llmAggregatorFrequencyPenalty = elements.llmAggregatorFrequencyPenaltyInput.value === '' ? null : parseFloat(elements.llmAggregatorFrequencyPenaltyInput.value);
            newSettings.llmAggregatorIncludeThoughts = elements.llmAggregatorIncludeThoughtsToggle.checked;
            newSettings.llmAggregatorExpandThoughtsByDefault = elements.llmAggregatorExpandThoughtsByDefaultToggle.checked;
            newSettings.llmAggregatorStreamingOutput = elements.llmAggregatorStreamingOutputCheckbox.checked;
            newSettings.llmAggregatorStreamingSpeed = elements.llmAggregatorStreamingSpeedInput.value === '' ? DEFAULT_STREAMING_SPEED : parseInt(elements.llmAggregatorStreamingSpeedInput.value);
            newSettings.llmAggregatorDummyUser = elements.llmAggregatorDummyUserInput.value.trim();
            newSettings.llmAggregatorEnableDummyUser = elements.llmAggregatorEnableDummyUserCheckbox.checked;
            newSettings.llmAggregatorDummyModel = elements.llmAggregatorDummyModelInput.value.trim();
            newSettings.llmAggregatorEnableDummyModel = elements.llmAggregatorEnableDummyModelCheckbox.checked;
            newSettings.llmAggregatorConcatDummyModel = elements.llmAggregatorConcatDummyModelCheckbox.checked;

             newSettings.enterToSend = elements.enterToSendCheckbox.checked;
             newSettings.autoScrollOnNewMessage = elements.autoScrollOnNewMessageCheckbox.checked;
             newSettings.autoScrollOnThought = elements.autoScrollOnThoughtCheckbox.checked;
             newSettings.historySortOrder = elements.historySortOrderSelect.value;
             newSettings.theme = elements.themeSelect.value;
             newSettings.enableSessionLinking = elements.enableSessionLinkingCheckbox.checked;
             newSettings.fontFamily = elements.fontFamilyInput.value.trim();
             newSettings.messageBodyFontSize = elements.messageBodyFontSizeInput.value === '' ? null : parseInt(elements.messageBodyFontSizeInput.value, 10);
             newSettings.codeBlockFontSize = elements.codeBlockFontSizeInput.value === '' ? null : parseInt(elements.codeBlockFontSizeInput.value, 10);
             newSettings.thoughtSummaryFontSize = elements.thoughtSummaryFontSizeInput.value === '' ? null : parseInt(elements.thoughtSummaryFontSizeInput.value, 10);
             newSettings.enableSwipeNavigation = elements.swipeNavigationToggle.checked;
             newSettings.preventZoom = elements.preventZoomToggle.checked;
             newSettings.minimizeHeaderFooter = document.getElementById('minimize-header-footer-toggle').checked;
             newSettings.showSessionLinkingSettings = elements.showSessionLinkingSettingsToggle.checked;
             newSettings.showChatTitle = elements.showChatTitleToggle.checked;
             newSettings.showNewChatButton = elements.showNewChatButtonToggle.checked;
             newSettings.showDeleteSessionButton = elements.showDeleteSessionButtonToggle.checked;
             newSettings.showCopySessionButton = elements.showCopySessionButtonToggle.checked;
             newSettings.showScrollToTopButton = elements.showScrollToTopButtonToggle.checked;
             newSettings.showScrollToBottomButton = elements.showScrollToBottomButtonToggle.checked;
             newSettings.showToggleAllContentButton = elements.showToggleAllContentButtonToggle.checked;
             newSettings.showBulkHistoryActions = elements.showBulkHistoryActionsToggle.checked;
             newSettings.showPasteButtonInFooter = elements.showPasteButtonInFooterToggle.checked;
             newSettings.showPasteButtonInEdit = elements.showPasteButtonInEditToggle.checked;
             newSettings.showDiceButton = elements.showDiceButtonToggle.checked;
             newSettings.diceMinValue = elements.diceMinValueInput.value === '' ? null : parseInt(elements.diceMinValueInput.value, 10);
             newSettings.diceMaxValue = elements.diceMaxValueInput.value === '' ? null : parseInt(elements.diceMaxValueInput.value, 10);
             newSettings.showMemoButton = elements.showMemoButtonToggle.checked;
             newSettings.memoHeight = elements.memoHeightInput.value.trim() || DEFAULT_MEMO_HEIGHT;
             newSettings.showClipboardStackButton = elements.showClipboardStackButtonToggle.checked;
             newSettings.clipboardStackHeight = state.settings.clipboardStackHeight;
             newSettings.showUserIcon = elements.showUserIconToggle.checked;
             newSettings.showUserName = elements.showUserNameToggle.checked;
             newSettings.userName = elements.userNameInput.value.trim() || DEFAULT_USER_NAME;
             newSettings.showAiIcon = elements.showAiIconToggle.checked;
             newSettings.showAiName = elements.showAiNameToggle.checked;
             newSettings.aiName = elements.aiNameInput.value.trim() || DEFAULT_AI_NAME;
             newSettings.iconNameFontSize = parseInt(elements.iconNameFontSizeInput.value, 10) || DEFAULT_ICON_NAME_FONT_SIZE;
             newSettings.iconNameOffsetY = (elements.iconNameOffsetYInput.value === '' ? DEFAULT_ICON_NAME_OFFSET_Y : parseInt(elements.iconNameOffsetYInput.value, 10) * -1);
             newSettings.messageIconSize = parseInt(elements.messageIconSizeInput.value, 10) || DEFAULT_MESSAGE_ICON_SIZE;
             newSettings.messageIconOffsetY = (elements.messageIconOffsetYInput.value === '' ? DEFAULT_MESSAGE_ICON_OFFSET_Y : parseInt(elements.messageIconOffsetYInput.value, 10) * -1);
             newSettings.showUserNameBubble = elements.userNameBubbleToggle.checked;
             newSettings.userNameBubbleUseThemeColor = elements.userNameBubbleUseThemeColorToggle.checked;
             newSettings.userNameBubbleColor = elements.userNameBubbleColorInput.value.trim() || DEFAULT_USER_NAME_BUBBLE_COLOR;
             newSettings.userNameBubbleOpacity = elements.userNameBubbleOpacityInput.value === '' ? DEFAULT_USER_NAME_BUBBLE_OPACITY : parseFloat(elements.userNameBubbleOpacityInput.value);
             newSettings.showAiNameBubble = elements.aiNameBubbleToggle.checked;
             newSettings.aiNameBubbleUseThemeColor = elements.aiNameBubbleUseThemeColorToggle.checked;
             newSettings.aiNameBubbleColor = elements.aiNameBubbleColorInput.value.trim() || DEFAULT_AI_NAME_BUBBLE_COLOR;
             newSettings.aiNameBubbleOpacity = elements.aiNameBubbleOpacityInput.value === '' ? DEFAULT_AI_NAME_BUBBLE_OPACITY : parseFloat(elements.aiNameBubbleOpacityInput.value);
             newSettings.disableRetryConfirmation = elements.disableRetryConfirmationToggle.checked;
             newSettings.disableLoadChatConfirmationWhileSending = elements.disableLoadChatConfirmationWhileSendingToggle.checked;
             newSettings.disableDeleteMessageConfirmation = elements.disableDeleteMessageConfirmationToggle.checked;
             newSettings.disableAttachmentConfirmation = elements.disableAttachmentConfirmationToggle.checked;
             newSettings.addPrefixOnImport = elements.addPrefixOnImportToggle.checked;
             newSettings.showTopCollapseButton = elements.showTopCollapseButtonToggle.checked;
             newSettings.showBottomCollapseButton = elements.showBottomCollapseButtonToggle.checked;
             newSettings.persistMessageCollapseState = elements.persistMessageCollapseStateCheckbox.checked;
             newSettings.messageBubbleOpacity = elements.messageBubbleOpacityInput.value === '' ? DEFAULT_MESSAGE_BUBBLE_OPACITY : parseFloat(elements.messageBubbleOpacityInput.value);
             newSettings.chatOverlayOpacity = elements.chatOverlayOpacityInput.value === '' ? DEFAULT_CHAT_OVERLAY_OPACITY : parseFloat(elements.chatOverlayOpacityInput.value);
             newSettings.headerFooterOpacity = elements.headerFooterOpacityInput.value === '' ? DEFAULT_HEADER_FOOTER_OPACITY : parseFloat(elements.headerFooterOpacityInput.value);
             newSettings.messageActionsBackgroundOpacity = elements.messageActionsBackgroundOpacityInput.value === '' ? DEFAULT_MESSAGE_ACTIONS_BACKGROUND_OPACITY : parseFloat(elements.messageActionsBackgroundOpacityInput.value);
             newSettings.toggleButtonTopWidth = parseInt(elements.toggleButtonTopWidthInput.value, 10) || DEFAULT_TOGGLE_BUTTON_TOP_WIDTH;
             newSettings.toggleButtonTopHeight = parseInt(elements.toggleButtonTopHeightInput.value, 10) || DEFAULT_TOGGLE_BUTTON_TOP_HEIGHT;
             newSettings.toggleButtonTopFontSize = parseInt(elements.toggleButtonTopFontSizeInput.value, 10) || DEFAULT_TOGGLE_BUTTON_TOP_FONT_SIZE;
             newSettings.toggleButtonTopOpacity = elements.toggleButtonTopOpacityInput.value === '' ? DEFAULT_TOGGLE_BUTTON_TOP_OPACITY : parseFloat(elements.toggleButtonTopOpacityInput.value);
             newSettings.toggleButtonTopTextCollapse = elements.toggleButtonTopTextCollapseInput.value.trim() || DEFAULT_TOGGLE_BUTTON_TOP_TEXT_COLLAPSE;
             newSettings.toggleButtonTopTextExpand = elements.toggleButtonTopTextExpandInput.value.trim() || DEFAULT_TOGGLE_BUTTON_TOP_TEXT_EXPAND;
             newSettings.toggleButtonBottomFontSize = parseInt(elements.toggleButtonBottomFontSizeInput.value, 10) || DEFAULT_TOGGLE_BUTTON_BOTTOM_FONT_SIZE;
             newSettings.toggleButtonBottomTextCollapse = elements.toggleButtonBottomTextCollapseInput.value.trim() || DEFAULT_TOGGLE_BUTTON_BOTTOM_TEXT_COLLAPSE;
             newSettings.toggleButtonBottomTextExpand = elements.toggleButtonBottomTextExpandInput.value.trim() || DEFAULT_TOGGLE_BUTTON_BOTTOM_TEXT_EXPAND;
             newSettings.thoughtSummaryOpacity = elements.thoughtSummaryOpacityInput.value === '' ? DEFAULT_THOUGHT_SUMMARY_OPACITY : parseFloat(elements.thoughtSummaryOpacityInput.value);
             newSettings.showApiProviderToggleHeader = elements.showApiProviderToggleHeaderCheckbox.checked;
             newSettings.showApiProviderToggleFooter = elements.showApiProviderToggleFooterCheckbox.checked;
             newSettings.apiProviderCycle = {
                 gemini: elements.apiProviderCycleGeminiCheckbox.checked,
                 deepseek: elements.apiProviderCycleDeepSeekCheckbox.checked,
                 claude: elements.apiProviderCycleClaudeCheckbox.checked,
                 openai: elements.apiProviderCycleOpenAICheckbox.checked,
                 xai: elements.apiProviderCycleXaiCheckbox.checked,
                 llmaggregator: elements.apiProviderCycleLlmAggregatorCheckbox.checked,
                 dummy: elements.apiProviderCycleDummyCheckbox.checked,
             };
             newSettings.dummyErrorDebugMode = elements.dummyErrorDebugModeCheckbox.checked;
             newSettings.dummyDummyModel = elements.dummyDummyModelInput.value.trim();
             newSettings.dummyEnableDummyModel = elements.dummyEnableDummyModelCheckbox.checked;

            const validateNumeric = (value, defaultValue, min, max, isInteger = false) => {
                let num = isInteger ? parseInt(value, 10) : parseFloat(value);
                if (value === '' || value === null) return null;
                if (isNaN(num)) return defaultValue;
                if (min !== undefined && num < min) return defaultValue;
                if (max !== undefined && num > max) return defaultValue;
                return num;
            };

            const providers = ['gemini', 'deepSeek', 'claude', 'openai', 'xai', 'llmaggregator'];
            providers.forEach(provider => {
                const prefix = provider;
                const streamingSpeedKey = `${prefix}StreamingSpeed`;
                newSettings[streamingSpeedKey] = validateNumeric(newSettings[streamingSpeedKey], DEFAULT_STREAMING_SPEED, 0, Infinity, true);
                const tempKey = `${prefix}Temperature`;
                newSettings[tempKey] = validateNumeric(newSettings[tempKey], null, 0, 2);
                const maxTokensKey = `${prefix}MaxTokens`;
                newSettings[maxTokensKey] = validateNumeric(newSettings[maxTokensKey], null, 1, Infinity, true);
                const topPKey = `${prefix}TopP`;
                newSettings[topPKey] = validateNumeric(newSettings[topPKey], null, 0, 1);
                const presencePenaltyKey = `${prefix}PresencePenalty`;
                newSettings[presencePenaltyKey] = validateNumeric(newSettings[presencePenaltyKey], null, -2.0, 2.0);
                const frequencyPenaltyKey = `${prefix}FrequencyPenalty`;
                newSettings[frequencyPenaltyKey] = validateNumeric(newSettings[frequencyPenaltyKey], null, -2.0, 2.0);

                if (provider === 'gemini') {
                    newSettings.geminiTopK = validateNumeric(newSettings.geminiTopK, null, 1, Infinity, true);
                    newSettings.geminiThinkingBudget = validateNumeric(newSettings.geminiThinkingBudget, null, 0, Infinity, true);
                } else if (provider === 'claude') {
                    newSettings.claudeTopK = validateNumeric(newSettings.claudeTopK, null, 1, Infinity, true);
                    newSettings.claudeThinkingBudget = validateNumeric(newSettings.claudeThinkingBudget, null, 1024, Infinity, true);
                } else if (provider === 'llmaggregator') {
                    newSettings.llmAggregatorTopK = validateNumeric(newSettings.llmAggregatorTopK, null, 1, Infinity, true);
                }
            });

             newSettings.messageBodyFontSize = validateNumeric(newSettings.messageBodyFontSize, null, 1, 100, true);
             newSettings.codeBlockFontSize = validateNumeric(newSettings.codeBlockFontSize, null, 1, 100, true);
             newSettings.thoughtSummaryFontSize = validateNumeric(newSettings.thoughtSummaryFontSize, null, 1, 100, true);
             newSettings.messageIconSize = validateNumeric(newSettings.messageIconSize, DEFAULT_MESSAGE_ICON_SIZE, 1, 300, true);
             newSettings.messageIconOffsetY = validateNumeric(newSettings.messageIconOffsetY, DEFAULT_MESSAGE_ICON_OFFSET_Y, -200, 200, true);
             newSettings.iconNameFontSize = validateNumeric(newSettings.iconNameFontSize, DEFAULT_ICON_NAME_FONT_SIZE, 1, 46, true);
             newSettings.iconNameOffsetY = validateNumeric(newSettings.iconNameOffsetY, DEFAULT_ICON_NAME_OFFSET_Y, -200, 200, true);

             if (!/^#([0-9A-Fa-f]{3}){1,2}$/.test(newSettings.userNameBubbleColor)) {
                newSettings.userNameBubbleColor = DEFAULT_USER_NAME_BUBBLE_COLOR;
             }
             newSettings.userNameBubbleOpacity = validateNumeric(newSettings.userNameBubbleOpacity, DEFAULT_USER_NAME_BUBBLE_OPACITY, 0, 1);
             if (!/^#([0-9A-Fa-f]{3}){1,2}$/.test(newSettings.aiNameBubbleColor)) {
                newSettings.aiNameBubbleColor = DEFAULT_AI_NAME_BUBBLE_COLOR;
             }
             newSettings.aiNameBubbleOpacity = validateNumeric(newSettings.aiNameBubbleOpacity, DEFAULT_AI_NAME_BUBBLE_OPACITY, 0, 1);

             newSettings.messageBubbleOpacity = validateNumeric(newSettings.messageBubbleOpacity, DEFAULT_MESSAGE_BUBBLE_OPACITY, 0, 1);
             newSettings.chatOverlayOpacity = validateNumeric(newSettings.chatOverlayOpacity, DEFAULT_CHAT_OVERLAY_OPACITY, 0, 1);
             newSettings.headerFooterOpacity = validateNumeric(newSettings.headerFooterOpacity, DEFAULT_HEADER_FOOTER_OPACITY, 0, 1);
             newSettings.messageActionsBackgroundOpacity = validateNumeric(newSettings.messageActionsBackgroundOpacity, DEFAULT_MESSAGE_ACTIONS_BACKGROUND_OPACITY, 0, 1);
             newSettings.toggleButtonTopWidth = validateNumeric(newSettings.toggleButtonTopWidth, DEFAULT_TOGGLE_BUTTON_TOP_WIDTH, 1, 100, true);
             newSettings.toggleButtonTopHeight = validateNumeric(newSettings.toggleButtonTopHeight, DEFAULT_TOGGLE_BUTTON_TOP_HEIGHT, 1, 100, true);
             newSettings.toggleButtonTopFontSize = validateNumeric(newSettings.toggleButtonTopFontSize, DEFAULT_TOGGLE_BUTTON_TOP_FONT_SIZE, 1, 50, true);
             newSettings.toggleButtonBottomFontSize = validateNumeric(newSettings.toggleButtonBottomFontSize, DEFAULT_TOGGLE_BUTTON_BOTTOM_FONT_SIZE, 1, 34, true);

             newSettings.diceMinValue = validateNumeric(newSettings.diceMinValue, null, 0, Infinity, true);
             newSettings.diceMaxValue = validateNumeric(newSettings.diceMaxValue, null, 0, Infinity, true);
             if (newSettings.diceMinValue !== null && newSettings.diceMaxValue !== null && newSettings.diceMinValue > newSettings.diceMaxValue) {
                newSettings.diceMaxValue = newSettings.diceMinValue;
             }
             document.querySelectorAll('#settings-screen details[id]').forEach(details => {
                newSettings.settingsUIDetailsOpenStates[details.id] = details.open;
             });
             if (!newSettings.apiProviderCycle[newSettings.apiProvider]) {
                const enabledProvider = Object.entries(newSettings.apiProviderCycle)
                    .find(([provider, enabled]) => enabled)?.[0];
                if (enabledProvider) {
                    newSettings.apiProvider = enabledProvider;
                    elements.apiProviderSelect.value = enabledProvider;
                }
            }

             try {
                 const oldSortOrder = state.settings.historySortOrder;
                 const { backgroundImageBlob, userIconBlob, aiIconBlob, ...settingsToSave } = newSettings;

                 const promises = Object.entries(settingsToSave).map(([key, value]) =>
                     dbUtils.saveSetting(key, value)
                 );

                 const currentSettingsFromDB = await dbUtils.loadSettings();
                 if (state.settings.backgroundImageBlob !== currentSettingsFromDB.backgroundImageBlob) {
                     promises.push(dbUtils.saveSetting('backgroundImageBlob', state.settings.backgroundImageBlob));
                 }
                 if (state.settings.userIconBlob !== currentSettingsFromDB.userIconBlob) {
                     promises.push(dbUtils.saveSetting('userIconBlob', state.settings.userIconBlob));
                 }
                  if (state.settings.aiIconBlob !== currentSettingsFromDB.aiIconBlob) {
                     promises.push(dbUtils.saveSetting('aiIconBlob', state.settings.aiIconBlob));
                 }

                 await Promise.all(promises);

                 state.settings.disableSaveSettingsConfirmation = newSettings.disableSaveSettingsConfirmation;
                 state.settings.autoSaveSettings = newSettings.autoSaveSettings;
                 
                 const currentBgBlob = state.settings.backgroundImageBlob;
                 const currentUserIconBlob = state.settings.userIconBlob;
                 const currentAiIconBlob = state.settings.aiIconBlob;

                 state.settings = { ...state.settings, ...settingsToSave };

                 state.settings.backgroundImageBlob = currentBgBlob;
                 state.settings.userIconBlob = currentUserIconBlob;
                 state.settings.aiIconBlob = currentAiIconBlob;

                 if (!state.isSending && !state.isAiToAiChatProcessing) {
                    uiUtils.applySettingsToUI();
                    uiUtils.renderChatMessages(true);
                } else {
                    uiUtils.applyTheme();
                    uiUtils.applyFontFamily();
                    uiUtils.applySidePanelSettingsToUI();
                    uiUtils.updateChatScreenElementVisibility();
                    uiUtils.updateHistoryHeaderButtonVisibility();
                    uiUtils.toggleApiSettingsVisibility(state.settings.apiProvider);
                    uiUtils.applySettingsUIDetailsOpenStates();
                }

                 if (showNotice && !state.settings.disableSaveSettingsConfirmation) {
                     await uiUtils.showCustomAlert("設定を保存しました。");
                 }

                 if (newSettings.historySortOrder !== oldSortOrder && state.currentScreen === 'history') {
                     uiUtils.renderHistoryList();
                 }
             } catch (error) {
                 await uiUtils.showCustomAlert(`設定の保存中にエラーが発生しました: ${error}`);
             }
        },
        async updateApp() {
            if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {
                await uiUtils.showCustomAlert("Service Workerが検出されませんでした。ページをリロードしてから再試行してください。");
                return;
            }
            const confirmed = await uiUtils.showCustomConfirm("アプリのキャッシュをクリアして最新版を再取得しますか？ (ページがリロードされます)");
            if (confirmed) {
                navigator.serviceWorker.ready.then(reg => {
                    if (reg.active) {
                        reg.active.postMessage({ action: 'clearCache' });
                    } else {
                        uiUtils.showCustomAlert("アクティブなService Workerが見つかりません。手動でリロードが必要かもしれません。");
                    }
                }).catch(async err => {
                    await uiUtils.showCustomAlert("Service Workerの準備中にエラーが発生しました。");
                });
            }
        },
        async confirmClearAllData() {
            const confirmed = await uiUtils.showCustomConfirm("本当にすべてのデータ（チャット履歴と設定）を削除しますか？この操作は元に戻せません。");
            if (confirmed) {
                try {
                    uiUtils.revokeExistingObjectUrl();
                    uiUtils.revokeExistingIconUrls();
                    await dbUtils.clearAllData();
                    await uiUtils.showCustomAlert("すべてのデータが削除されました。アプリをリセットします。");

                    state.currentChatId = null;
                    state.currentMessages = [];
                    state.pendingAttachments = [];
                    state.isMemoVisible = false;
                    elements.memoArea.classList.add('hidden');
                    elements.memoEditor.value = '';
                    state.isClipboardStackVisible = false;
                    elements.clipboardStackArea.classList.add('hidden');
                    state.clipboardStackContent = '';
                    state.linkedSessionIds = [];

                    const defaultSettingsCopy = JSON.parse(JSON.stringify(state.settings));
                    Object.keys(defaultSettingsCopy).forEach(key => {
                        if (key.startsWith('gemini') || key.startsWith('deepSeek') || key.startsWith('claude') || key.startsWith('openai') || key.startsWith('xai') || key.startsWith('llmaggregator')) {
                            if(key.toLowerCase().includes('systemprompt')) defaultSettingsCopy[key] = '';
                            else if(key.toLowerCase().includes('enablesystempromptdefault')) defaultSettingsCopy[key] = true;
                            else if(key.toLowerCase().includes('temperature') || key.toLowerCase().includes('maxtokens') || key.toLowerCase().includes('topk') || key.toLowerCase().includes('topp') || key.toLowerCase().includes('penalty') || key.toLowerCase().includes('budget')) defaultSettingsCopy[key] = null;
                            else if(key.toLowerCase().includes('streamingoutput')) defaultSettingsCopy[key] = true;
                            else if(key.toLowerCase().includes('streamingspeed')) defaultSettingsCopy[key] = DEFAULT_STREAMING_SPEED;
                            else if(key.toLowerCase().includes('dummyuser') || key.toLowerCase().includes('dummymodel')) defaultSettingsCopy[key] = '';
                            else if(key.toLowerCase().includes('enabledummyuser') || key.toLowerCase().includes('enabledummymodel')) defaultSettingsCopy[key] = true;
                            else if(key.toLowerCase().includes('concatdummymodel')) defaultSettingsCopy[key] = false;
                            else if(key === 'geminiIncludeThoughts') defaultSettingsCopy[key] = false;
                            else if(key === 'geminiExpandThoughtsByDefault') defaultSettingsCopy[key] = false;
                            else if(key === 'geminiPseudoStreaming') defaultSettingsCopy[key] = false;
                            else if(key === 'geminiEnableGrounding') defaultSettingsCopy[key] = false;
                            else if(key === 'deepSeekIncludeDeepSeekThoughts' || key === 'llmAggregatorIncludeThoughts') defaultSettingsCopy[key] = false;
                            else if(key === 'deepSeekExpandThoughtsByDefault' || key === 'llmAggregatorExpandThoughtsByDefault') defaultSettingsCopy[key] = false;
                            else if(key === 'claudeIncludeThoughts') defaultSettingsCopy[key] = false;
                            else if(key === 'claudeExpandThoughtsByDefault') defaultSettingsCopy[key] = false;
                            else if(key === 'claudeThinkingBudget') defaultSettingsCopy[key] = null;
                            else if(key === 'xaiVisionEnable') defaultSettingsCopy[key] = false;
                            else if(key === 'xaiIncludeThoughts') defaultSettingsCopy[key] = false;
                            else if(key === 'xaiExpandThoughtsByDefault') defaultSettingsCopy[key] = false;
                            else if(key === 'xaiReasoningEffort') defaultSettingsCopy[key] = 'low';
                        }
                    });
                    defaultSettingsCopy.apiKey = '';
                    defaultSettingsCopy.modelName = DEFAULT_MODEL;
                    defaultSettingsCopy.additionalModels = '';
                    defaultSettingsCopy.commonSystemPrompt = '';
                    defaultSettingsCopy.enableCommonSystemPromptDefault = false;
                    defaultSettingsCopy.deepSeekApiKey = '';
                    defaultSettingsCopy.deepSeekModelName = DEFAULT_DEEPSEEK_MODEL;
                    defaultSettingsCopy.deepSeekAdditionalModels = '';
                    defaultSettingsCopy.deepSeekApiEndpoint = '';
                    defaultSettingsCopy.claudeApiKey = '';
                    defaultSettingsCopy.claudeModelName = DEFAULT_CLAUDE_MODEL;
                    defaultSettingsCopy.claudeAdditionalModels = '';
                    defaultSettingsCopy.openaiApiKey = '';
                    defaultSettingsCopy.openaiModelName = DEFAULT_OPENAI_MODEL;
                    defaultSettingsCopy.openaiAdditionalModels = '';
                    defaultSettingsCopy.xaiApiKey = '';
                    defaultSettingsCopy.xaiModelName = DEFAULT_XAI_MODEL;
                    defaultSettingsCopy.xaiAdditionalModels = '';
                    defaultSettingsCopy.llmAggregatorApiKey = '';
                    defaultSettingsCopy.llmAggregatorApiBackend = '';
                    defaultSettingsCopy.llmAggregatorModelName = DEFAULT_LLMAGGREGATOR_MODEL;
                    defaultSettingsCopy.llmAggregatorAdditionalModels = '';
                    defaultSettingsCopy.apiProvider = 'gemini';
                    defaultSettingsCopy.enterToSend = true;
                    defaultSettingsCopy.autoScrollOnNewMessage = DEFAULT_AUTO_SCROLL_ON_NEW_MESSAGE;
                    defaultSettingsCopy.autoScrollOnThought = false;
                    defaultSettingsCopy.historySortOrder = 'updatedAt';
                    defaultSettingsCopy.theme = window.matchMedia?.('(prefers-color-scheme: light)').matches ? 'dark' : 'light';
                    defaultSettingsCopy.backgroundImageBlob = null;
                    defaultSettingsCopy.fontFamily = '';
                    defaultSettingsCopy.messageBodyFontSize = DEFAULT_MESSAGE_BODY_FONT_SIZE;
                    defaultSettingsCopy.codeBlockFontSize = DEFAULT_CODE_BLOCK_FONT_SIZE;
                    defaultSettingsCopy.thoughtSummaryFontSize = DEFAULT_THOUGHT_SUMMARY_FONT_SIZE;
                    defaultSettingsCopy.enableSessionLinking = false;
                    defaultSettingsCopy.showSessionLinkingSettings = false;
                    defaultSettingsCopy.enableSwipeNavigation = true;
                    defaultSettingsCopy.preventZoom = true;
                    defaultSettingsCopy.minimizeHeaderFooter = false;
                    defaultSettingsCopy.showChatTitle = true;
                    defaultSettingsCopy.showNewChatButton = true;
                    defaultSettingsCopy.showDeleteSessionButton = false;
                    defaultSettingsCopy.showCopySessionButton = false;
                    defaultSettingsCopy.showScrollToTopButton = true;
                    defaultSettingsCopy.showScrollToBottomButton = true;
                    defaultSettingsCopy.showToggleAllContentButton = false;
                    defaultSettingsCopy.showBulkHistoryActions = true;
                    defaultSettingsCopy.showPasteButtonInFooter = false;
                    defaultSettingsCopy.showPasteButtonInEdit = false;
                    defaultSettingsCopy.showDiceButton = false;
                    defaultSettingsCopy.diceMinValue = DEFAULT_DICE_MIN_VALUE;
                    defaultSettingsCopy.diceMaxValue = DEFAULT_DICE_MAX_VALUE;
                    defaultSettingsCopy.showMemoButton = false;
                    defaultSettingsCopy.memoHeight = DEFAULT_MEMO_HEIGHT;
                    defaultSettingsCopy.showClipboardStackButton = false;
                    defaultSettingsCopy.clipboardStackHeight = DEFAULT_CLIPBOARD_STACK_HEIGHT;
                    defaultSettingsCopy.showUserIcon = false;
                    defaultSettingsCopy.userIconBlob = null;
                    defaultSettingsCopy.showUserName = false;
                    defaultSettingsCopy.userName = DEFAULT_USER_NAME;
                    defaultSettingsCopy.showAiIcon = false;
                    defaultSettingsCopy.aiIconBlob = null;
                    defaultSettingsCopy.showAiName = false;
                    defaultSettingsCopy.aiName = DEFAULT_AI_NAME;
                    defaultSettingsCopy.iconNameFontSize = DEFAULT_ICON_NAME_FONT_SIZE;
                    defaultSettingsCopy.iconNameOffsetY = DEFAULT_ICON_NAME_OFFSET_Y;
                    defaultSettingsCopy.messageIconSize = DEFAULT_MESSAGE_ICON_SIZE;
                    defaultSettingsCopy.messageIconOffsetY = DEFAULT_MESSAGE_ICON_OFFSET_Y;
                    defaultSettingsCopy.showUserNameBubble = false;
                    defaultSettingsCopy.userNameBubbleUseThemeColor = false;
                    defaultSettingsCopy.userNameBubbleColor = DEFAULT_USER_NAME_BUBBLE_COLOR;
                    defaultSettingsCopy.userNameBubbleOpacity = DEFAULT_USER_NAME_BUBBLE_OPACITY;
                    defaultSettingsCopy.showAiNameBubble = false;
                    defaultSettingsCopy.aiNameBubbleUseThemeColor = false;
                    defaultSettingsCopy.aiNameBubbleColor = DEFAULT_AI_NAME_BUBBLE_COLOR;
                    defaultSettingsCopy.aiNameBubbleOpacity = DEFAULT_AI_NAME_BUBBLE_OPACITY;
                    defaultSettingsCopy.disableRetryConfirmation = false;
                    defaultSettingsCopy.disableLoadChatConfirmationWhileSending = false;
                    defaultSettingsCopy.disableDeleteMessageConfirmation = false;
                    defaultSettingsCopy.disableAttachmentConfirmation = false;
                    defaultSettingsCopy.addPrefixOnImport = true;
                    defaultSettingsCopy.showMultiApiKeys = false;
                    defaultSettingsCopy.disableSaveSettingsConfirmation = false;
                    defaultSettingsCopy.autoSaveSettings = false;
                    defaultSettingsCopy.showTopCollapseButton = true;
                    defaultSettingsCopy.showBottomCollapseButton = true;
                    defaultSettingsCopy.persistMessageCollapseState = DEFAULT_PERSIST_MESSAGE_COLLAPSE_STATE;
                    defaultSettingsCopy.messageBubbleOpacity = DEFAULT_MESSAGE_BUBBLE_OPACITY;
                    defaultSettingsCopy.chatOverlayOpacity = DEFAULT_CHAT_OVERLAY_OPACITY;
                    defaultSettingsCopy.headerFooterOpacity = DEFAULT_HEADER_FOOTER_OPACITY;
                    defaultSettingsCopy.messageActionsBackgroundOpacity = DEFAULT_MESSAGE_ACTIONS_BACKGROUND_OPACITY;
                    defaultSettingsCopy.toggleButtonTopWidth = DEFAULT_TOGGLE_BUTTON_TOP_WIDTH;
                    defaultSettingsCopy.toggleButtonTopHeight = DEFAULT_TOGGLE_BUTTON_TOP_HEIGHT;
                    defaultSettingsCopy.toggleButtonTopFontSize = DEFAULT_TOGGLE_BUTTON_TOP_FONT_SIZE;
                    defaultSettingsCopy.toggleButtonTopOpacity = DEFAULT_TOGGLE_BUTTON_TOP_OPACITY;
                    defaultSettingsCopy.toggleButtonTopTextCollapse = DEFAULT_TOGGLE_BUTTON_TOP_TEXT_COLLAPSE;
                    defaultSettingsCopy.toggleButtonTopTextExpand = DEFAULT_TOGGLE_BUTTON_TOP_TEXT_EXPAND;
                    defaultSettingsCopy.toggleButtonBottomFontSize = DEFAULT_TOGGLE_BUTTON_BOTTOM_FONT_SIZE;
                    defaultSettingsCopy.toggleButtonBottomTextCollapse = DEFAULT_TOGGLE_BUTTON_BOTTOM_TEXT_COLLAPSE;
                    defaultSettingsCopy.toggleButtonBottomTextExpand = DEFAULT_TOGGLE_BUTTON_BOTTOM_TEXT_EXPAND;
                    defaultSettingsCopy.thoughtSummaryOpacity = DEFAULT_THOUGHT_SUMMARY_OPACITY;
                    defaultSettingsCopy.settingsUIDetailsOpenStates = {};
                    defaultSettingsCopy.showApiProviderToggleHeader = false;
                    defaultSettingsCopy.showApiProviderToggleFooter = true;
                    defaultSettingsCopy.apiProviderCycle = { gemini: true, deepseek: true, claude: true, openai: true, xai: true, llmaggregator: true, dummy: true };
                    defaultSettingsCopy.llmAggregatorTopK = null;
                    defaultSettingsCopy.dummyErrorDebugMode = false;
                    defaultSettingsCopy.dummyDummyModel = '';
                    defaultSettingsCopy.dummyEnableDummyModel = false;
                    defaultSettingsCopy.geminiApiKeys = [];
                    defaultSettingsCopy.geminiActiveApiKeyIndex = -1;
                    defaultSettingsCopy.deepseekApiKeys = [];
                    defaultSettingsCopy.deepseekActiveApiKeyIndex = -1;
                    defaultSettingsCopy.claudeApiKeys = [];
                    defaultSettingsCopy.claudeActiveApiKeyIndex = -1;
                    defaultSettingsCopy.openaiApiKeys = [];
                    defaultSettingsCopy.openaiActiveApiKeyIndex = -1;
                    defaultSettingsCopy.xaiApiKeys = [];
                    defaultSettingsCopy.xaiActiveApiKeyIndex = -1;
                    defaultSettingsCopy.llmaggregatorApiKeys = [];
                    defaultSettingsCopy.llmaggregatorActiveApiKeyIndex = -1;

                    state.settings = defaultSettingsCopy;

                    state.backgroundImageUrl = null;
                    state.userIconUrl = null;
                    state.aiIconUrl = null;
                    state.areAllMessagesHidden = false;
                    state.messageCollapsedStates.clear();
                    state.thoughtSummaryOpenStates.clear();

                    document.documentElement.style.setProperty('--chat-background-image', 'none');
                    uiUtils.applySettingsToUI();
                    uiUtils.updateAttachmentBadgeVisibility();
                    this.startNewChat();
                    uiUtils.showScreen('chat', true);
                } catch (error) {
                    await uiUtils.showCustomAlert(`データ削除中にエラーが発生しました: ${error}`);
                }
            }
        },
        async confirmClearAllHistory() {
            const confirmed = await uiUtils.showCustomConfirm("本当にすべてのチャット履歴を削除しますか？\nこの操作は元に戻せません。設定は保持されます。");
            if (confirmed) {
                try {
                    await dbUtils.clearAllChatsStore();
                    state.currentChatId = null;
                    state.currentMessages = [];
                    state.pendingAttachments = [];
                    state.isMemoVisible = false;
                    elements.memoArea.classList.add('hidden');
                    elements.memoEditor.value = '';
                    state.isClipboardStackVisible = false;
                    elements.clipboardStackArea.classList.add('hidden');
                    state.clipboardStackContent = '';
                    state.areAllMessagesHidden = false;
                    uiUtils.updateToggleAllContentButton();
                    state.messageCollapsedStates.clear();
                    state.thoughtSummaryOpenStates.clear();
                    state.linkedSessionIds = [];
                    uiUtils.updateSessionLinkingUI();

                    this.startNewChat();
                    await uiUtils.showCustomAlert("すべてのチャット履歴が削除されました。");

                    if (state.currentScreen === 'history') {
                        uiUtils.renderHistoryList();
                    }

                } catch (error) {
                    await uiUtils.showCustomAlert(`チャット履歴の削除中にエラーが発生しました: ${error}`);
                }
            }
        },
        async startEditMessage(index, messageElement) {
             if (state.isSending) {
                 await uiUtils.showCustomAlert("送信中は編集できません。");
                 return;
             }
             if (state.editingMessageIndex !== null && state.editingMessageIndex !== index) {
                 await uiUtils.showCustomAlert("他のメッセージを編集中です。");
                 return;
             }
             if (state.editingMessageIndex === index) {
                 messageElement.querySelector('.edit-textarea')?.focus();
                 return;
             }

             const message = state.currentMessages[index];
             if (!message) return;

             const rawContent = message.content;
             state.editingMessageIndex = index;

             const contentDiv = messageElement.querySelector('.message-content');
             const editArea = messageElement.querySelector('.message-edit-area');
             const cascadeControls = messageElement.querySelector('.message-cascade-controls');

             editArea.innerHTML = '';

             let horizontalPadding = 0;
             try {
                 const computedStyle = window.getComputedStyle(messageElement);
                 const paddingLeft = parseFloat(computedStyle.paddingLeft) || 0;
                 const paddingRight = parseFloat(computedStyle.paddingRight) || 0;
                 horizontalPadding = paddingLeft + paddingRight;
             } catch (e) {
             }
             messageElement.style.width = `calc(var(--message-max-width) + ${horizontalPadding}px + 17px)`;

             const textarea = document.createElement('textarea');
             textarea.value = rawContent;
             textarea.classList.add('edit-textarea');
             textarea.rows = 3;
             textarea.oninput = () => uiUtils.adjustTextareaHeight(textarea, 400);

             const actionsDiv = document.createElement('div');
             actionsDiv.classList.add('message-edit-actions');

             if (state.settings.showPasteButtonInEdit) {
                                 const pasteButton = document.createElement('button');
                pasteButton.textContent = '貼';
                pasteButton.title = 'テキストエリアに貼り付け';
                pasteButton.style.backgroundColor = 'var(--bg-button-paste)';
                pasteButton.style.marginRight = 'auto';
                pasteButton.onclick = async () => {
                    const originalText = pasteButton.textContent;
                    const originalTitle = pasteButton.title;
                    try {
                        if (!navigator.clipboard || !navigator.clipboard.readText) {
                            pasteButton.textContent = "!";
                            pasteButton.title = "クリップボードAPI非対応";
                            pasteButton.disabled = true;
                            setTimeout(() => {
                                pasteButton.textContent = originalText;
                                pasteButton.title = originalTitle;
                                pasteButton.disabled = false;
                            }, 2000);
                            return;
                        }
                        const textToPaste = await navigator.clipboard.readText();
                        if (textToPaste) {
                            const currentText = textarea.value;
                            const selectionStart = textarea.selectionStart;
                            const selectionEnd = textarea.selectionEnd;
                            textarea.value = currentText.substring(0, selectionStart) + textToPaste + currentText.substring(selectionEnd);
                            textarea.selectionStart = textarea.selectionEnd = selectionStart + textToPaste.length;
                            textarea.focus();
                            uiUtils.adjustTextareaHeight(textarea, 400);
                            pasteButton.textContent = "✓";
                            pasteButton.title = "貼り付け完了";
                            setTimeout(() => {
                                pasteButton.textContent = originalText;
                                pasteButton.title = originalTitle;
                            }, 1500);
                        } else {
                            pasteButton.textContent = "空";
                            pasteButton.title = "クリップボードは空です";
                            setTimeout(() => {
                                pasteButton.textContent = originalText;
                                pasteButton.title = originalTitle;
                            }, 1500);
                        }
                    } catch (err) {
                         if (err.name === 'NotAllowedError' || err.message.includes('Read permission denied')) {
                            pasteButton.textContent = "!";
                            pasteButton.title = "クリップボードの許可なし";
                         } else {
                            pasteButton.textContent = "X";
                            pasteButton.title = "貼り付け失敗";
                         }
                         pasteButton.disabled = true;
                         setTimeout(() => {
                            pasteButton.textContent = originalText;
                            pasteButton.title = originalTitle;
                            pasteButton.disabled = false;
                         }, 2000);
                    }
                };
                actionsDiv.appendChild(pasteButton);
             }

             const saveButton = document.createElement('button');
             saveButton.textContent = '保存';
             saveButton.classList.add('save-edit-btn');
             saveButton.onclick = () => this.saveEditMessage(index, messageElement);
             const cancelButton = document.createElement('button');
             cancelButton.textContent = 'キャンセル';
             cancelButton.classList.add('cancel-edit-btn');
             cancelButton.onclick = () => this.cancelEditMessage(index, messageElement);
             actionsDiv.appendChild(saveButton);
             actionsDiv.appendChild(cancelButton);

             editArea.appendChild(textarea);
             editArea.appendChild(actionsDiv);

             messageElement.classList.add('editing');
             if(contentDiv) contentDiv.classList.add('hidden');
             if(cascadeControls) cascadeControls.classList.add('hidden');
             editArea.classList.remove('hidden');

             uiUtils.adjustTextareaHeight(textarea, 400);
             textarea.focus();
             textarea.select();

             this.uncollapseMessage(index, messageElement);
        },
        async saveEditMessage(index, messageElement) {
            const textarea = messageElement.querySelector('.edit-textarea');
            if (!textarea) {
                this.cancelEditMessage(index, messageElement);
                return;
            }
            const newRawContent = textarea.value;
            const originalMessage = state.currentMessages[index];

            if (newRawContent === originalMessage.content) {
                this.cancelEditMessage(index, messageElement);
                return;
            }

            originalMessage.content = newRawContent;
            originalMessage.timestamp = Date.now();
            delete originalMessage.error;

            const contentDiv = messageElement.querySelector('.message-content');
            
            if (originalMessage.role === 'user') {
                contentDiv.innerHTML = '';
                if (originalMessage.attachments && originalMessage.attachments.length > 0) {
                    const details = document.createElement('details');
                    details.classList.add('attachment-details');
                    const summary = document.createElement('summary');
                    summary.textContent = `添付ファイル (${originalMessage.attachments.length}件)`;
                    details.appendChild(summary);

                    const list = document.createElement('ul');
                    list.classList.add('attachment-list');

                    originalMessage.attachments.forEach((att, attachmentIndex) => {
                        const listItem = document.createElement('li');
                        listItem.dataset.attachmentIndex = attachmentIndex;
                        const itemContainer = document.createElement('div');
                        itemContainer.classList.add('attachment-list-item-container');

                        const nameSpan = document.createElement('span');
                        nameSpan.classList.add('attachment-list-item-name');
                        nameSpan.textContent = sanitizeText(att.name);
                        nameSpan.title = `${sanitizeText(att.name)} (${sanitizeText(att.mimeType)})`;

                        const actionsDiv = document.createElement('div');
                        actionsDiv.classList.add('attachment-actions');

                        if (att.mimeType.startsWith('image/')) {
                            const previewBtn = document.createElement('button');
                            previewBtn.textContent = '表示';
                            previewBtn.classList.add('attachment-preview-btn');
                            previewBtn.onclick = (e) => { e.preventDefault(); appLogic.previewAttachment(index, attachmentIndex); };
                            actionsDiv.appendChild(previewBtn);
                        }

                        const editBtn = document.createElement('button');
                        editBtn.textContent = '編集';
                        editBtn.classList.add('attachment-edit-btn');
                        editBtn.onclick = (e) => { e.preventDefault(); appLogic.editAttachment(index, attachmentIndex); };

                        const removeBtn = document.createElement('button');
                        removeBtn.textContent = '削除';
                        removeBtn.classList.add('attachment-remove-btn');
                        removeBtn.onclick = (e) => { e.preventDefault(); appLogic.removeAttachment(index, attachmentIndex, listItem); };
                        
                        actionsDiv.appendChild(editBtn);
                        actionsDiv.appendChild(removeBtn);
                        itemContainer.appendChild(nameSpan);
                        itemContainer.appendChild(actionsDiv);
                        listItem.appendChild(itemContainer);
                        list.appendChild(listItem);
                    });
                    details.appendChild(list);
                    
                    const addMoreBtn = document.createElement('button');
                    addMoreBtn.textContent = 'ファイルを追加';
                    addMoreBtn.classList.add('add-more-attachments-btn');
                    addMoreBtn.onclick = (e) => { e.preventDefault(); appLogic.addMoreAttachments(index, list); };
                    details.appendChild(addMoreBtn);

                    contentDiv.appendChild(details);
                }

                if (newRawContent && newRawContent.trim() !== '') {
                    const pre = document.createElement('pre');
                    pre.textContent = newRawContent;
                    pre.style.marginTop = (originalMessage.attachments && originalMessage.attachments.length > 0) ? '8px' : '0';
                    contentDiv.appendChild(pre);
                }

            } else if (originalMessage.role === 'model') {
                if (contentDiv && typeof marked !== 'undefined') {
                    try {
                        const safeHtml = uiUtils._sanitizeAndParseMarkdown(newRawContent || '');
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = safeHtml;
                        uiUtils.processInteractivePlaceholders(tempDiv);
                        uiUtils.processInteractiveTitles(tempDiv);
                        contentDiv.innerHTML = tempDiv.innerHTML;
                        uiUtils.addCopyButtonsToCodeBlocks(contentDiv, false);
                        uiUtils.addImageClickListeners(contentDiv);
                    } catch (e) {
                        contentDiv.textContent = newRawContent;
                    }
                } else if (contentDiv) {
                    contentDiv.textContent = newRawContent;
                }
            }

            this.finishEditing(messageElement);

            const isFirstUserMessage = (index === state.currentMessages.findIndex(m => m.role === 'user'));
            let titleForSave = null;
            if (isFirstUserMessage) {
                titleForSave = newRawContent.substring(0, 50) || "無題のチャット";
            }

            try {
                await dbUtils.saveChat(titleForSave);
                if (isFirstUserMessage) {
                    uiUtils.updateChatTitle(titleForSave);
                }
            } catch (error) {
                await uiUtils.showCustomAlert("メッセージ編集後のチャット保存に失敗しました。");
            }
        },
        cancelEditMessage(index, messageElement = null) {
              if (!messageElement) {
                  messageElement = elements.messageContainer.querySelector(`.message[data-index="${index}"]`);
              }
              if (messageElement) {
                  this.finishEditing(messageElement);
              } else if (state.editingMessageIndex === index) {
                  state.editingMessageIndex = null;
              }
        },
        finishEditing(messageElement) {
            if (!messageElement) return;
            const editArea = messageElement.querySelector('.message-edit-area');
            const contentDiv = messageElement.querySelector('.message-content');
            const cascadeControls = messageElement.querySelector('.message-cascade-controls');
            const textarea = messageElement.querySelector('.edit-textarea');

            messageElement.style.removeProperty('width');
            messageElement.classList.remove('editing');
            if(contentDiv) contentDiv.classList.remove('hidden');
            if(cascadeControls) cascadeControls.classList.remove('hidden');
            if(editArea) {
                editArea.classList.add('hidden');
                editArea.innerHTML = '';
            }

            const index = parseInt(messageElement.dataset.index, 10);
            if (state.editingMessageIndex === index) {
                state.editingMessageIndex = null;
            }
        },
        async copyMessageText(index, buttonElement) {
            const message = state.currentMessages[index];
            if (!message) return;

            let textToCopy = message.content;
            if (!textToCopy && message.role === 'user' && message.attachments && message.attachments.length > 0) {
                textToCopy = `[添付ファイル: ${message.attachments.map(a => a.name).join(', ')}]`;
            } else if (!textToCopy) {
                textToCopy = "";
            }

            try {
                await navigator.clipboard.writeText(textToCopy);
                const originalText = buttonElement.textContent;
                buttonElement.textContent = '完了！';
                buttonElement.disabled = true;
                setTimeout(() => {
                    buttonElement.textContent = originalText;
                    buttonElement.disabled = false;
                }, 1500);
            } catch (err) {
                await uiUtils.showCustomAlert("OSクリップボードへのコピーに失敗しました。");
                const originalText = buttonElement.textContent;
                buttonElement.textContent = 'コピー失敗';
                buttonElement.disabled = true;
                setTimeout(() => {
                    buttonElement.textContent = originalText;
                    buttonElement.disabled = false;
                }, 2000);
            }

            const currentStackContent = elements.clipboardStackEditor.value;
            const separator = currentStackContent.length > 0 && !currentStackContent.endsWith('\n\n') ? "\n\n" : "";
            elements.clipboardStackEditor.value += separator + textToCopy;
            state.clipboardStackContent = elements.clipboardStackEditor.value;
            elements.clipboardStackEditor.scrollTop = elements.clipboardStackEditor.scrollHeight;
        },
        async deleteMessage(index) {
            if (state.editingMessageIndex === index) {
                this.cancelEditMessage(index);
            }
            if (state.isSending) {
                await uiUtils.showCustomAlert("送信中は削除できません。");
                return;
            }
            if (index < 0 || index >= state.currentMessages.length) {
                 return;
            }

            const messageToDelete = state.currentMessages[index];
            const messageContentPreview = messageToDelete.content.substring(0, 30) + "...";
            let confirmMessage = "";
            let indicesToDelete = [];

            if (messageToDelete.role === 'model' && messageToDelete.isCascaded && messageToDelete.siblingGroupId) {
                const groupId = messageToDelete.siblingGroupId;
                const siblings = state.currentMessages.filter(msg => msg.role === 'model' && msg.isCascaded && msg.siblingGroupId === groupId);
                indicesToDelete = state.currentMessages
                    .map((msg, i) => (msg.role === 'model' && msg.isCascaded && msg.siblingGroupId === groupId) ? i : -1)
                    .filter(i => i !== -1);
                confirmMessage = `「${messageContentPreview}」を含む応答グループ全体 (${siblings.length}件) を削除しますか？`;
            } else {
                indicesToDelete.push(index);
                confirmMessage = `メッセージ「${messageContentPreview}」(${messageToDelete.role}) を削除しますか？`;
            }

            let confirmedDelete = true;
            if (!state.settings.disableDeleteMessageConfirmation) {
                confirmedDelete = await uiUtils.showCustomConfirm(confirmMessage);
            }

            if (confirmedDelete) {
                const originalFirstUserMsgIndex = state.currentMessages.findIndex(m => m.role === 'user');

                indicesToDelete.sort((a, b) => b - a).forEach(idx => {
                    state.currentMessages.splice(idx, 1);
                    state.messageCollapsedStates.delete(idx);
                    state.thoughtSummaryOpenStates.delete(idx);
                });

                const oldCollapsedStates = new Map(state.messageCollapsedStates);
                state.messageCollapsedStates.clear();
                 state.currentMessages.forEach((msg, newIdx) => {
                    const oldIdxEquivalent = newIdx >= Math.min(...indicesToDelete) ? newIdx + indicesToDelete.filter(i => i <= newIdx).length : newIdx;
                    if (oldCollapsedStates.has(oldIdxEquivalent)) {
                        state.messageCollapsedStates.set(newIdx, oldCollapsedStates.get(oldIdxEquivalent));
                    } else {
                        state.messageCollapsedStates.set(newIdx, false);
                    }
                });
                const oldThoughtOpenStates = new Map(state.thoughtSummaryOpenStates);
                state.thoughtSummaryOpenStates.clear();
                 state.currentMessages.forEach((msg, newIdx) => {
                    const minDeletedIndex = Math.min(...indicesToDelete);
                    const oldIdxEquivalent = newIdx >= minDeletedIndex ? newIdx + indicesToDelete.filter(i => i <= newIdx).length : newIdx;
                    if (oldThoughtOpenStates.has(oldIdxEquivalent)) {
                        state.thoughtSummaryOpenStates.set(newIdx, oldThoughtOpenStates.get(oldIdxEquivalent));
                    } else {
                        const messageApiProvider = msg?.generatedByApiProvider || state.settings.apiProvider;
                        state.thoughtSummaryOpenStates.set(newIdx, (messageApiProvider === 'gemini' && state.settings.geminiExpandThoughtsByDefault) || 
                                                                   (messageApiProvider === 'deepseek' && state.settings.deepSeekExpandThoughtsByDefault) ||
                                                                   (messageApiProvider === 'claude' && state.settings.claudeExpandThoughtsByDefault) ||
                                                                   (messageApiProvider === 'xai' && state.settings.xaiExpandThoughtsByDefault) ||
                                                                   (messageApiProvider === 'llmaggregator' && state.settings.llmAggregatorExpandThoughtsByDefault));
                    }
                });

                uiUtils.renderChatMessages(true);

                const newFirstUserMsgIndex = state.currentMessages.findIndex(m => m.role === 'user');
                let requiresTitleUpdate = indicesToDelete.includes(originalFirstUserMsgIndex);

                try {
                    let newTitleForSave = null;
                    const currentChatData = state.currentChatId ? await dbUtils.getChat(state.currentChatId) : null;

                    if (requiresTitleUpdate) {
                        const newFirstUserMessage = newFirstUserMsgIndex !== -1 ? state.currentMessages[newFirstUserMsgIndex] : null;
                        newTitleForSave = newFirstUserMessage ? newFirstUserMessage.content.substring(0, 50) : "無題のチャット";
                    } else if (currentChatData) {
                        newTitleForSave = currentChatData.title;
                    }

                    await dbUtils.saveChat(newTitleForSave);
                    if (requiresTitleUpdate) {
                        uiUtils.updateChatTitle(newTitleForSave);
                    }
                    if (state.currentMessages.length === 0 && state.currentChatId) {
                        this.startNewChat();
                    }
                } catch (error) {
                    await uiUtils.showCustomAlert("メッセージ削除後のチャット保存に失敗しました。");
                }
            }
        },
        findPreviousUserIndex(modelMessageIndex) {
            for (let i = modelMessageIndex - 1; i >= 0; i--) {
                if (state.currentMessages[i].role === 'user') {
                    return i;
                }
            }
            return -1;
        },
        async retryFromMessage(index) {
            if (state.editingMessageIndex !== null) {
                await uiUtils.showCustomAlert("編集中はリトライできません。");
                return;
            }
            if (state.isSending) {
                await uiUtils.showCustomAlert("送信中です。");
                return;
            }

            const userMessage = state.currentMessages[index];
            if (!userMessage || userMessage.role !== 'user') return;

            let confirmed = true;
            if (!state.settings.disableRetryConfirmation) {
                const messageContentPreview = userMessage.content.substring(0, 30) + "...";
                confirmed = await uiUtils.showCustomConfirm(`「${messageContentPreview}」から再生成しますか？\n(この入力に対する既存の応答は保持されますが、**これより未来の会話履歴は削除されます**)`);
            }

            if (confirmed) {
                let deleteStartIndex = -1;
                let scanIndex = index + 1;
                let targetSiblingGroupId = null;

                if (scanIndex < state.currentMessages.length && state.currentMessages[scanIndex].role === 'model') {
                    targetSiblingGroupId = state.currentMessages[scanIndex].siblingGroupId || null;
                }

                if (targetSiblingGroupId !== null) {
                    while (
                        scanIndex < state.currentMessages.length &&
                        state.currentMessages[scanIndex].role === 'model' &&
                        state.currentMessages[scanIndex].siblingGroupId === targetSiblingGroupId
                    ) {
                        scanIndex++;
                    }
                } else {
                     if (scanIndex < state.currentMessages.length && state.currentMessages[scanIndex].role === 'model') {
                        scanIndex++;
                    }
                }

                if (scanIndex < state.currentMessages.length) {
                    deleteStartIndex = scanIndex;
                }

                if (deleteStartIndex !== -1) {
                    for(let i = deleteStartIndex; i < state.currentMessages.length; i++) {
                        state.messageCollapsedStates.delete(i);
                        state.thoughtSummaryOpenStates.delete(i);
                    }
                    state.currentMessages.splice(deleteStartIndex);
                }

                uiUtils.renderChatMessages();
                if (state.settings.autoScrollOnNewMessage) uiUtils.scrollToBottom();

                const elementsToHide = [];
                const messageContainer = elements.messageContainer;
                if (targetSiblingGroupId) {
                    messageContainer.querySelectorAll(`.message.model[data-index]`).forEach(el => {
                        const msgIndex = parseInt(el.dataset.index, 10);
                        const potentialMsg = state.currentMessages[msgIndex];
                        if (potentialMsg && potentialMsg.role === 'model' && potentialMsg.siblingGroupId === targetSiblingGroupId) {
                             el.classList.add('retrying-hidden');
                             elementsToHide.push(el);
                        }
                    });
                } else if (index + 1 < state.currentMessages.length && state.currentMessages[index + 1]?.role === 'model') {
                    const element = messageContainer.querySelector(`.message.model[data-index="${index + 1}"]`);
                    if (element) {
                        element.classList.add('retrying-hidden');
                        elementsToHide.push(element);
                    }
                }

                await this.handleSend(true, index);
            }
        },
        getCascadedSiblings(index, includeSelf = false) {
            const targetMsg = state.currentMessages[index];
            if (!targetMsg || !targetMsg.isCascaded || !targetMsg.siblingGroupId) {
                return [];
            }
            const groupId = targetMsg.siblingGroupId;
            const siblings = state.currentMessages.filter((msg, i) =>
                msg.role === 'model' &&
                msg.isCascaded &&
                msg.siblingGroupId === groupId &&
                (includeSelf || i !== index)
            );
            return siblings;
        },
        async navigateCascade(currentIndex, direction) {
            const currentMsg = state.currentMessages[currentIndex];
            if (!currentMsg || !currentMsg.isCascaded || !currentMsg.siblingGroupId) return;

            const groupId = currentMsg.siblingGroupId;
            const siblingsWithIndices = state.currentMessages
                .map((msg, i) => ({ msg, originalIndex: i }))
                                    .filter(item => item.msg.role === 'model' && item.msg.isCascaded && item.msg.siblingGroupId === groupId);

            const currentSiblingIndexInGroup = siblingsWithIndices.findIndex(item => item.originalIndex === currentIndex);
            if (currentSiblingIndexInGroup === -1) return;

            let targetSiblingIndexInGroup = -1;
            if (direction === 'prev' && currentSiblingIndexInGroup > 0) {
                targetSiblingIndexInGroup = currentSiblingIndexInGroup - 1;
            } else if (direction === 'next' && currentSiblingIndexInGroup < siblingsWithIndices.length - 1) {
                targetSiblingIndexInGroup = currentSiblingIndexInGroup + 1;
            }

            if (targetSiblingIndexInGroup !== -1) {
                currentMsg.isSelected = false;
                const newlySelectedMessage = siblingsWithIndices[targetSiblingIndexInGroup].msg;
                newlySelectedMessage.isSelected = true;
                const newlySelectedIndex = siblingsWithIndices[targetSiblingIndexInGroup].originalIndex;

                uiUtils.renderChatMessages();

                requestAnimationFrame(() => {
                    const newlySelectedElement = elements.messageContainer.querySelector(`.message[data-index="${newlySelectedIndex}"]`);
                    if (newlySelectedElement && !newlySelectedElement.classList.contains('editing')) {
                         const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                         if (currentlyShown && currentlyShown !== newlySelectedElement) {
                             currentlyShown.classList.remove('show-actions');
                         }
                         newlySelectedElement.classList.add('show-actions');
                    }
                });

                try {
                    await dbUtils.saveChat();
                } catch (error) {
                    await uiUtils.showCustomAlert("応答の切り替え状態の保存に失敗しました。");
                }
            }
        },
        async confirmDeleteCascadeResponse(indexToDelete) {
            const msgToDelete = state.currentMessages[indexToDelete];
            if (!msgToDelete || msgToDelete.role !== 'model' || !msgToDelete.isCascaded || !msgToDelete.siblingGroupId) {
                return;
            }
            if (state.editingMessageIndex !== null) { await uiUtils.showCustomAlert("編集中は削除できません。"); return; }
            if (state.isSending) { await uiUtils.showCustomAlert("送信中は削除できません。"); return; }

            const siblings = this.getCascadedSiblings(indexToDelete, true);
            const currentIndexInGroup = siblings.findIndex(m => m === msgToDelete) + 1;
            const totalSiblings = siblings.length;
            const contentPreview = msgToDelete.content.substring(0, 30) + "...";
            const confirmMsgText = `この応答 (${currentIndexInGroup}/${totalSiblings})「${contentPreview}」を削除しますか？\n(この応答のみが削除されます)`;

            let confirmed = true;
            if (!state.settings.disableDeleteMessageConfirmation) {
                confirmed = await uiUtils.showCustomConfirm(confirmMsgText);
            }

            if (confirmed) {
                const wasSelected = msgToDelete.isSelected;
                const groupId = msgToDelete.siblingGroupId;

                state.currentMessages.splice(indexToDelete, 1);
                state.messageCollapsedStates.delete(indexToDelete);
                state.thoughtSummaryOpenStates.delete(indexToDelete);

                const oldCollapsedStates = new Map(state.messageCollapsedStates);
                state.messageCollapsedStates.clear();
                 state.currentMessages.forEach((msg, newIdx) => {
                    const oldIdxEquivalent = newIdx >= indexToDelete ? newIdx + 1 : newIdx;
                    if (oldCollapsedStates.has(oldIdxEquivalent)) {
                        state.messageCollapsedStates.set(newIdx, oldCollapsedStates.get(oldIdxEquivalent));
                    } else {
                        state.messageCollapsedStates.set(newIdx, false);
                    }
                });
                const oldThoughtOpenStates = new Map(state.thoughtSummaryOpenStates);
                state.thoughtSummaryOpenStates.clear();
                 state.currentMessages.forEach((msg, newIdx) => {
                    const oldIdxEquivalent = newIdx >= indexToDelete ? newIdx + 1 : newIdx;
                    if (oldThoughtOpenStates.has(oldIdxEquivalent)) {
                        state.thoughtSummaryOpenStates.set(newIdx, oldThoughtOpenStates.get(oldIdxEquivalent));
                    } else {
                        const messageApiProvider = msg?.generatedByApiProvider || state.settings.apiProvider;
                        state.thoughtSummaryOpenStates.set(newIdx, (messageApiProvider === 'gemini' && state.settings.geminiExpandThoughtsByDefault) || 
                                                                   (messageApiProvider === 'deepseek' && state.settings.deepSeekExpandThoughtsByDefault) ||
                                                                   (messageApiProvider === 'claude' && state.settings.claudeExpandThoughtsByDefault));
                    }
                });

                let newlySelectedIndex = -1;
                const remainingSiblingsWithIndices = state.currentMessages.map((msg, i) => ({ msg, originalIndex: i }))
                .filter(item => item.msg.role === 'model' && item.msg.isCascaded && item.msg.siblingGroupId === groupId);

                if (remainingSiblingsWithIndices.length > 0) {
                    if (wasSelected) {
                        const lastSiblingItem = remainingSiblingsWithIndices[remainingSiblingsWithIndices.length - 1];
                        if (!lastSiblingItem.msg.isSelected) {
                            lastSiblingItem.msg.isSelected = true;
                        }
                        newlySelectedIndex = lastSiblingItem.originalIndex;
                    } else {
                         const stillSelectedItem = remainingSiblingsWithIndices.find(item => item.msg.isSelected);
                         if (stillSelectedItem) {
                             newlySelectedIndex = stillSelectedItem.originalIndex;
                         } else {
                            const lastSiblingItem = remainingSiblingsWithIndices[remainingSiblingsWithIndices.length - 1];
                            lastSiblingItem.msg.isSelected = true;
                            newlySelectedIndex = lastSiblingItem.originalIndex;
                         }
                    }
                }

                uiUtils.renderChatMessages(true);

                requestAnimationFrame(() => {
                     if (newlySelectedIndex !== -1) {
                         const elementToShowActions = elements.messageContainer.querySelector(`.message[data-index="${newlySelectedIndex}"]`);
                         if (elementToShowActions && !elementToShowActions.classList.contains('editing')) {
                              const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                              if (currentlyShown && currentlyShown !== elementToShowActions) {
                                  currentlyShown.classList.remove('show-actions');
                              }
                              elementToShowActions.classList.add('show-actions');
                         }
                     }
                });

                try {
                    await dbUtils.saveChat();
                } catch (error) {
                    await uiUtils.showCustomAlert("応答削除後のチャット状態の保存に失敗しました。");
                }
            }
        },
        async handleFileSelection(fileList) {
            if (!fileList || fileList.length === 0) return;
            const newFiles = Array.from(fileList);
            let currentTotalSize = state.selectedFilesForUpload.reduce((sum, item) => sum + item.file.size, 0);
            let addedCount = 0;
            let skippedCount = 0;
            let sizeError = false;

            elements.selectFilesBtn.disabled = true;
            elements.selectFilesBtn.textContent = '処理中...';

            for (const file of newFiles) {
                if (file.size > MAX_FILE_SIZE) {
                    await uiUtils.showCustomAlert(`ファイル "${file.name}" はサイズが大きすぎます (${formatFileSize(MAX_FILE_SIZE)}以下)。`);
                    skippedCount++;
                    continue;
                }
                if (currentTotalSize + file.size > MAX_TOTAL_ATTACHMENT_SIZE) {
                    sizeError = true;
                    skippedCount++;
                    continue;
                }
                if (state.selectedFilesForUpload.some(item => item.file.name === file.name)) {
                    skippedCount++;
                    continue;
                }

                state.selectedFilesForUpload.push({ file: file });
                currentTotalSize += file.size;
                addedCount++;
            }
            elements.selectFilesBtn.disabled = false;
            elements.selectFilesBtn.textContent = 'ファイルを選択';

            if (sizeError) {
                await uiUtils.showCustomAlert(`合計ファイルサイズの上限 (${formatFileSize(MAX_TOTAL_ATTACHMENT_SIZE)}) を超えるため、一部のファイルは追加されませんでした。`);
            }
            uiUtils.updateSelectedFilesUI();
        },
        removeSelectedFile(indexToRemove) {
            if (indexToRemove >= 0 && indexToRemove < state.selectedFilesForUpload.length) {
                const removedFile = state.selectedFilesForUpload.splice(indexToRemove, 1)[0];
                uiUtils.updateSelectedFilesUI();
            }
        },
        async confirmAttachment() {
            if (state.selectedFilesForUpload.length === 0) {
                state.pendingAttachments = [];
                elements.fileUploadDialog.close('ok');
                uiUtils.adjustTextareaHeight();
                uiUtils.updateAttachmentBadgeVisibility();
                return;
            }

            elements.confirmAttachBtn.disabled = true;
            elements.confirmAttachBtn.textContent = '処理中...';

            const attachmentsToAdd = [];
            let encodingError = false;

            for (const item of state.selectedFilesForUpload) {
                const file = item.file;
                try {
                    const fileName = file.name;
                    const fileExtension = fileName.slice(((fileName.lastIndexOf(".") - 1) >>> 0) + 2).toLowerCase();
                    let browserMimeType = file.type || '';
                    let guessedMimeType = extensionToMimeTypeMap[fileExtension] || browserMimeType || 'application/octet-stream';

                    if (guessedMimeType.startsWith('text/')) {
                        const textData = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result);
                            reader.onerror = (error) => reject(error);
                            reader.readAsText(file);
                        });
                        attachmentsToAdd.push({
                            file: file,
                            name: fileName,
                            mimeType: guessedMimeType,
                            textData: textData,
                            base64Data: null 
                        });
                    } else {
                        const base64Data = await fileToBase64(file);
                        attachmentsToAdd.push({
                            file: file,
                            name: fileName,
                            mimeType: guessedMimeType,
                            base64Data: base64Data,
                            textData: null
                        });
                    }
                } catch (error) {
                    encodingError = true;
                    await uiUtils.showCustomAlert(`ファイル "${item.file.name}" の処理中にエラーが発生しました。`);
                    break;
                }
            }

            elements.confirmAttachBtn.disabled = false;
            elements.confirmAttachBtn.textContent = '添付して閉じる';

            if (!encodingError) {
                state.pendingAttachments = attachmentsToAdd;
                elements.fileUploadDialog.close('ok');
                uiUtils.adjustTextareaHeight();
                uiUtils.updateAttachmentBadgeVisibility();
            }
        },
        cancelAttachment() {
            state.selectedFilesForUpload = [];
            elements.fileUploadDialog.close('cancel');
            uiUtils.updateAttachmentBadgeVisibility();
        },
        toggleMessageCollapse(index) {
            const messageElement = elements.messageContainer.querySelector(`.message[data-index="${index}"]`);
            const contentDiv = messageElement?.querySelector('.message-content');
            const toggleButtons = messageElement?.querySelectorAll('.message-toggle-button[data-action="toggle-collapse"]');

            if (contentDiv && toggleButtons && toggleButtons.length > 0) {
                const isCollapsed = contentDiv.classList.toggle('collapsed');
                messageElement.classList.toggle('message-content-collapsed-fully', isCollapsed);
                state.messageCollapsedStates.set(index, isCollapsed);
                if (state.settings.persistMessageCollapseState && state.currentChatId) {
                    dbUtils.saveChat();
                }

                toggleButtons.forEach(button => {
                    let textCollapse, textExpand, baseTitle;
                    if (button.classList.contains('top')) {
                        textCollapse = state.settings.toggleButtonTopTextCollapse;
                        textExpand = state.settings.toggleButtonTopTextExpand;
                    } else {
                        textCollapse = state.settings.toggleButtonBottomTextCollapse;
                        textExpand = state.settings.toggleButtonBottomTextExpand;
                    }
                    baseTitle = isCollapsed ? 'メッセージを展開' : 'メッセージを折りたたむ';
                    button.textContent = isCollapsed ? textExpand : textCollapse;
                    button.title = baseTitle;
                    button.setAttribute('aria-label', baseTitle);
                });
            }
        },
        uncollapseMessage(index, messageElement = null) {
             if (!messageElement) {
                 messageElement = elements.messageContainer.querySelector(`.message[data-index="${index}"]`);
             }
             const contentDiv = messageElement?.querySelector('.message-content');
             const toggleButtons = messageElement?.querySelectorAll('.message-toggle-button[data-action="toggle-collapse"]');

             if (contentDiv && contentDiv.classList.contains('collapsed')) {
                 contentDiv.classList.remove('collapsed');
                 messageElement.classList.remove('message-content-collapsed-fully');
                 state.messageCollapsedStates.set(index, false);
                 if (state.settings.persistMessageCollapseState && state.currentChatId) {
                    dbUtils.saveChat();
                 }

                 if (toggleButtons) {
                     toggleButtons.forEach(button => {
                        let textCollapse;
                        if (button.classList.contains('top')) {
                            textCollapse = state.settings.toggleButtonTopTextCollapse;
                        } else {
                            textCollapse = state.settings.toggleButtonBottomTextCollapse;
                        }
                        button.textContent = textCollapse;
                        button.title = 'メッセージを折りたたむ';
                        button.setAttribute('aria-label', 'メッセージを折りたたむ');
                     });
                 }
             }
        },
        toggleAllMessagesVisibility() {
            if (state.isSending) {
                uiUtils.showCustomAlert("送信中は操作できません。");
                return;
            }
            if (state.editingMessageIndex !== null) {
                 uiUtils.showCustomAlert("メッセージ編集中は操作できません。");
                 return;
             }

            state.areAllMessagesHidden = !state.areAllMessagesHidden;
            uiUtils.updateToggleAllContentButton();

            const messages = elements.messageContainer.querySelectorAll('.message:not(.message-error)');
            messages.forEach(msgElement => {
                                if (msgElement.id && msgElement.id.startsWith('streaming-message-')) {
                    msgElement.classList.remove('message-hidden-by-toggle');
                    return;
                }
                msgElement.classList.toggle('message-hidden-by-toggle', state.areAllMessagesHidden);
                if(state.areAllMessagesHidden){
                    msgElement.classList.remove('message-content-collapsed-fully');
                    msgElement.querySelector('.message-content')?.classList.remove('collapsed');
                }
            });

            requestAnimationFrame(() => {
                uiUtils.scrollToBottom();
            });
        },
        toggleSessionLink(sessionId) {
            if (!state.settings.enableSessionLinking) return;

            const index = state.linkedSessionIds.indexOf(sessionId);
            if (index > -1) {
                state.linkedSessionIds.splice(index, 1);
            } else {
                if (state.linkedSessionIds.length >= 2) {
                    state.linkedSessionIds.shift();
                }
                state.linkedSessionIds.push(sessionId);
            }
            uiUtils.updateSessionLinkingUI();
        },
        async initiateAiToAiStep() {
            if (state.isAiToAiChatProcessing || state.isSending) {
                await uiUtils.showCustomAlert("現在処理中です。");
                return;
            }
            if (state.linkedSessionIds.length !== 2 || !state.currentChatId || !state.linkedSessionIds.includes(state.currentChatId)) {
                await uiUtils.showCustomAlert("AI間会話を実行するには、現在のチャットを含む2つのセッションをリンクしてください。");
                return;
            }
            const selectedApiProvider = state.settings.apiProvider;
             if ((selectedApiProvider === 'gemini' && !state.settings.apiKey) ||
                 (selectedApiProvider === 'deepseek' && !state.settings.deepSeekApiKey) ||
                 (selectedApiProvider === 'claude' && !state.settings.claudeApiKey) ||
                 (selectedApiProvider === 'openai' && !state.settings.openaiApiKey) ||
                 (selectedApiProvider === 'xai' && !state.settings.xaiApiKey) ||
                 (selectedApiProvider === 'llmaggregator' && !state.settings.llmAggregatorApiKey)
                ) {
                await uiUtils.showCustomAlert("選択中のAPIプロバイダーのAPIキーが設定されていません。");
                uiUtils.showScreen('settings');
                return;
            }

            uiUtils.setAiToAiProcessingState(true, "AI間会話処理中 (ステップ1/2)...");

            const sessionA_Id = state.currentChatId;
            const sessionB_Id = state.linkedSessionIds.find(id => id !== sessionA_Id);

            try {
                const sessionA_Data = await dbUtils.getChat(sessionA_Id);
                if (!sessionA_Data || !sessionA_Data.messages || sessionA_Data.messages.length === 0) {
                    throw new Error(`セッションA (${sessionA_Id}) のデータが取得できませんでした。`);
                }

                const lastAiMessageA = [...sessionA_Data.messages].reverse().find(msg => msg.role === 'model' && (!msg.isCascaded || msg.isSelected));
                if (!lastAiMessageA || !lastAiMessageA.content) {
                    throw new Error(`セッションA (${sessionA_Id}) の最新のAI応答が見つかりません。`);
                }
                const inputForB = lastAiMessageA.content;

                const sessionB_Data = await dbUtils.getChat(sessionB_Id);
                if (!sessionB_Data) {
                    throw new Error(`セッションB (${sessionB_Id}) のデータが取得できませんでした。`);
                }

                let providerForSettingsB = state.settings.apiProvider;
                let systemPromptB, enableSystemPromptDefaultB, dummyUserB, enableDummyUserB, dummyModelB, enableDummyModelB,
                    temperatureB, maxTokensB, topPB,
                    streamingOutputB, streamingSpeedB, concatDummyModelB,
                    geminiTopKB, geminiThinkingBudgetB, geminiIncludeThoughtsB, geminiPseudoStreamingB, geminiEnableGroundingB,
                    deepSeekIncludeThoughtsB, presencePenaltyB, frequencyPenaltyB,
                    claudeTopKB, claudeIncludeThoughtsB, claudeThinkingBudgetB, claudeExpandThoughtsByDefaultB,
                    xaiVisionEnableB, xaiIncludeThoughtsB, xaiReasoningEffortB, llmAggregatorTopKB;

                if (providerForSettingsB === 'gemini') {
                    systemPromptB = state.settings.geminiSystemPrompt;
                    enableSystemPromptDefaultB = state.settings.geminiEnableSystemPromptDefault;
                    temperatureB = state.settings.geminiTemperature;
                    maxTokensB = state.settings.geminiMaxTokens;
                    geminiTopKB = state.settings.geminiTopK;
                    topPB = state.settings.geminiTopP;
                    presencePenaltyB = state.settings.geminiPresencePenalty;
                    frequencyPenaltyB = state.settings.geminiFrequencyPenalty;
                    geminiThinkingBudgetB = state.settings.geminiThinkingBudget;
                    geminiIncludeThoughtsB = state.settings.geminiIncludeThoughts;
                    streamingOutputB = state.settings.geminiStreamingOutput;
                    streamingSpeedB = state.settings.geminiStreamingSpeed;
                    dummyUserB = state.settings.geminiDummyUser;
                    enableDummyUserB = state.settings.geminiEnableDummyUser;
                    dummyModelB = state.settings.geminiDummyModel;
                    enableDummyModelB = state.settings.geminiEnableDummyModel;
                    concatDummyModelB = state.settings.geminiConcatDummyModel;
                    geminiPseudoStreamingB = state.settings.geminiPseudoStreaming;
                    geminiEnableGroundingB = state.settings.geminiEnableGrounding;
                } else if (providerForSettingsB === 'deepseek') {
                    systemPromptB = state.settings.deepSeekSystemPrompt;
                    enableSystemPromptDefaultB = state.settings.deepSeekEnableSystemPromptDefault;
                    temperatureB = state.settings.deepSeekTemperature;
                    maxTokensB = state.settings.deepSeekMaxTokens;
                    topPB = state.settings.deepSeekTopP;
                    presencePenaltyB = state.settings.deepSeekPresencePenalty;
                    frequencyPenaltyB = state.settings.deepSeekFrequencyPenalty;
                    contextDeepSeekIncludeThoughts = state.settings.deepSeekIncludeDeepSeekThoughts;
                    streamingOutputB = state.settings.deepSeekStreamingOutput;
                    streamingSpeedB = state.settings.deepSeekStreamingSpeed;
                    dummyUserB = state.settings.deepSeekDummyUser;
                    enableDummyUserB = state.settings.deepSeekEnableDummyUser;
                    dummyModelB = state.settings.deepSeekDummyModel;
                    enableDummyModelB = state.settings.deepSeekEnableDummyModel;
                    concatDummyModelB = state.settings.deepSeekConcatDummyModel;
                } else if (providerForSettingsB === 'llmaggregator') {
                    systemPromptB = state.settings.llmAggregatorSystemPrompt;
                    enableSystemPromptDefaultB = state.settings.llmAggregatorEnableSystemPromptDefault;
                    temperatureB = state.settings.llmAggregatorTemperature;
                    maxTokensB = state.settings.llmAggregatorMaxTokens;
                    topPB = state.settings.llmAggregatorTopP;
                    llmAggregatorTopKB = state.settings.llmAggregatorTopK;
                    presencePenaltyB = state.settings.llmAggregatorPresencePenalty;
                    frequencyPenaltyB = state.settings.llmAggregatorFrequencyPenalty;
                    contextDeepSeekIncludeThoughts = state.settings.llmAggregatorIncludeThoughts;
                    streamingOutputB = state.settings.llmAggregatorStreamingOutput;
                    streamingSpeedB = state.settings.llmAggregatorStreamingSpeed;
                    dummyUserB = state.settings.llmAggregatorDummyUser;
                    enableDummyUserB = state.settings.llmAggregatorEnableDummyUser;
                    dummyModelB = state.settings.llmAggregatorDummyModel;
                    enableDummyModelB = state.settings.llmAggregatorEnableDummyModel;
                    concatDummyModelB = state.settings.llmAggregatorConcatDummyModel;
                } else if (providerForSettingsB === 'claude') {
                    systemPromptB = state.settings.claudeSystemPrompt;
                    enableSystemPromptDefaultB = state.settings.claudeEnableSystemPromptDefault;
                    temperatureB = state.settings.claudeTemperature;
                    maxTokensB = state.settings.claudeMaxTokens;
                    claudeTopKB = state.settings.claudeTopK;
                    topPB = state.settings.claudeTopP;
                    streamingOutputB = state.settings.claudeStreamingOutput;
                    streamingSpeedB = state.settings.claudeStreamingSpeed;
                    dummyUserB = state.settings.claudeDummyUser;
                    enableDummyUserB = state.settings.claudeEnableDummyUser;
                    dummyModelB = state.settings.claudeDummyModel;
                    enableDummyModelB = state.settings.claudeEnableDummyModel;
                    concatDummyModelB = state.settings.claudeConcatDummyModel;
                    claudeIncludeThoughtsB = state.settings.claudeIncludeThoughts;
                    claudeThinkingBudgetB = state.settings.claudeThinkingBudget;
                    claudeExpandThoughtsByDefaultB = state.settings.claudeExpandThoughtsByDefault;
                } else if (providerForSettingsB === 'openai') {
                    systemPromptB = state.settings.openaiSystemPrompt;
                    enableSystemPromptDefaultB = state.settings.openaiEnableSystemPromptDefault;
                    temperatureB = state.settings.openaiTemperature;
                    maxTokensB = state.settings.openaiMaxTokens;
                    topPB = state.settings.openaiTopP;
                    presencePenaltyB = state.settings.openaiPresencePenalty;
                    frequencyPenaltyB = state.settings.openaiFrequencyPenalty;
                    streamingOutputB = state.settings.openaiStreamingOutput;
                    streamingSpeedB = state.settings.openaiStreamingSpeed;
                    dummyUserB = state.settings.openaiDummyUser;
                    enableDummyUserB = state.settings.openaiEnableDummyUser;
                    dummyModelB = state.settings.openaiDummyModel;
                    enableDummyModelB = state.settings.openaiEnableDummyModel;
                    concatDummyModelB = state.settings.openaiConcatDummyModel;
                } else if (providerForSettingsB === 'xai') {
                    systemPromptB = state.settings.xaiSystemPrompt;
                    enableSystemPromptDefaultB = state.settings.xaiEnableSystemPromptDefault;
                    temperatureB = state.settings.xaiTemperature;
                    maxTokensB = state.settings.xaiMaxTokens;
                    topPB = state.settings.xaiTopP;
                    presencePenaltyB = state.settings.xaiPresencePenalty;
                    frequencyPenaltyB = state.settings.xaiFrequencyPenalty;
                    streamingOutputB = state.settings.xaiStreamingOutput;
                    streamingSpeedB = state.settings.xaiStreamingSpeed;
                    dummyUserB = state.settings.xaiDummyUser;
                    enableDummyUserB = state.settings.xaiEnableDummyUser;
                    dummyModelB = state.settings.xaiDummyModel;
                    enableDummyModelB = state.settings.xaiEnableDummyModel;
                    concatDummyModelB = state.settings.xaiConcatDummyModel;
                    xaiVisionEnableB = state.settings.xaiVisionEnable;
                    xaiIncludeThoughtsB = state.settings.xaiIncludeThoughts;
                    xaiReasoningEffortB = state.settings.xaiReasoningEffort;
                }

                const contextForB = {
                    sessionId: sessionB_Id,
                    messages: sessionB_Data.messages ? [...sessionB_Data.messages] : [],
                    systemPrompt: systemPromptB,
                    enableSystemPromptDefault: enableSystemPromptDefaultB,
                    temperature: temperatureB, maxTokens: maxTokensB, topP: topPB,
                    presencePenalty: presencePenaltyB, frequencyPenalty: frequencyPenaltyB,
                    streamingOutput: streamingOutputB, streamingSpeed: streamingSpeedB,
                    dummyUser: dummyUserB, enableDummyUser: enableDummyUserB,
                    dummyModel: dummyModelB, enableDummyModelB: enableDummyModelB, concatDummyModel: concatDummyModelB,
                    topK: providerForSettingsB === 'gemini' ? geminiTopKB :
                          providerForSettingsB === 'claude' ? claudeTopKB :
                          providerForSettingsB === 'llmaggregator' ? llmAggregatorTopKB : undefined,
                    thinkingBudget: providerForSettingsB === 'gemini' ? geminiThinkingBudgetB : 
                                    providerForSettingsB === 'claude' ? claudeThinkingBudgetB : undefined,
                    includeThoughts: providerForSettingsB === 'gemini' ? geminiIncludeThoughtsB : 
                                     (providerForSettingsB === 'deepseek' || providerForSettingsB === 'llmaggregator') ? contextDeepSeekIncludeThoughts : 
                                     providerForSettingsB === 'claude' ? claudeIncludeThoughtsB :
                                     providerForSettingsB === 'xai' ? xaiIncludeThoughtsB : undefined,
                    expandThoughtsByDefault: (providerForSettingsB === 'gemini' && state.settings.geminiExpandThoughtsByDefault) ||
                                             (providerForSettingsB === 'deepseek' && state.settings.deepSeekExpandThoughtsByDefault) ||
                                             (providerForSettingsB === 'claude' ? claudeExpandThoughtsByDefaultB : undefined) ||
                                             (providerForSettingsB === 'xai' && state.settings.xaiExpandThoughtsByDefault) ||
                                             (providerForSettingsB === 'llmaggregator' && state.settings.llmAggregatorExpandThoughtsByDefault),
                    reasoningEffort: providerForSettingsB === 'xai' ? xaiReasoningEffortB : undefined,
                    pseudoStreaming: providerForSettingsB === 'gemini' ? geminiPseudoStreamingB : undefined,
                    enableGrounding: providerForSettingsB === 'gemini' ? geminiEnableGroundingB : undefined,
                    visionEnable: providerForSettingsB === 'xai' ? xaiVisionEnableB : undefined,
                    inputText: inputForB,
                    attachments: [],
                    apiProvider: providerForSettingsB
                };

                const responseFromB = await this.handleSend(false, -1, contextForB);
                if (responseFromB === "APIキー未設定") throw new Error("APIキーが設定されていません。");
                if (!responseFromB || !responseFromB.content) {
                    throw new Error(`セッションB (${sessionB_Id}) からの応答がありませんでした。`);
                }
                const inputForA = responseFromB.content;

                uiUtils.setAiToAiProcessingState(true, "AI間会話処理中 (ステップ2/2)...");

                elements.userInput.value = inputForA;
                uiUtils.adjustTextareaHeight();

                await this.handleSend();

            } catch (error) {
                await uiUtils.showCustomAlert(`AI間会話処理中にエラーが発生しました: ${error.message}`);
                if (state.currentChatId === sessionA_Id && elements.chatScreen.classList.contains('active')) {
                     uiUtils.displayError(`AI間会話エラー: ${error.message}`, false);
                }
            } finally {
                uiUtils.setAiToAiProcessingState(false);
            }
        },
        removeAttachment: async function(messageIndex, attachmentIndex, listItemElement) {
            const message = state.currentMessages[messageIndex];
            if (!message || !message.attachments || !message.attachments[attachmentIndex]) return;

            const attachmentName = message.attachments[attachmentIndex].name;
            
            let confirmed = true;
            if (!state.settings.disableAttachmentConfirmation) {
                confirmed = await uiUtils.showCustomConfirm(`添付ファイル「${attachmentName}」を削除しますか？`);
            }
            
            if (confirmed) {
                message.attachments.splice(attachmentIndex, 1);
                
                const list = listItemElement.parentElement;
                listItemElement.remove();

                const summary = list.closest('.attachment-details').querySelector('summary');
                summary.textContent = `添付ファイル (${message.attachments.length}件)`;

                try {
                    await dbUtils.saveChat();
                } catch(e) {
                    await uiUtils.showCustomAlert('添付ファイルの削除状態の保存に失敗しました。');
                }
            }
        },
        editAttachment: function(messageIndex, attachmentIndex) {
            const hiddenInput = document.createElement('input');
            hiddenInput.type = 'file';
            hiddenInput.accept = "image/*,text/*,application/pdf,video/*,audio/*,.txt,.md,.csv,.json,.html,.css,.js,.py";
            hiddenInput.style.display = 'none';

            hiddenInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                if (file.size > MAX_FILE_SIZE) {
                    await uiUtils.showCustomAlert(`ファイルサイズが大きすぎます (${formatFileSize(MAX_FILE_SIZE)}以下)。`);
                    return;
                }

                try {
                    let textData = null;
                    let base64Data = null;
                    const fileName = file.name;
                    const fileExtension = fileName.slice(((fileName.lastIndexOf(".") - 1) >>> 0) + 2).toLowerCase();
                    let browserMimeType = file.type || '';
                    let guessedMimeType = extensionToMimeTypeMap[fileExtension] || browserMimeType || 'application/octet-stream';

                    if (guessedMimeType.startsWith('text/')) {
                        textData = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result);
                            reader.onerror = (error) => reject(error);
                            reader.readAsText(file);
                        });
                    } else {
                        base64Data = await fileToBase64(file);
                    }

                    const message = state.currentMessages[messageIndex];
                    message.attachments[attachmentIndex] = {
                        file: file,
                        name: fileName,
                        mimeType: guessedMimeType,
                        base64Data: base64Data,
                        textData: textData,
                    };
                    
                    const messageElement = elements.messageContainer.querySelector(`.message[data-index="${messageIndex}"]`);
                    if(messageElement) {
                        const listItem = messageElement.querySelector(`li[data-attachment-index="${attachmentIndex}"] .attachment-list-item-name`);
                        if(listItem) {
                            listItem.textContent = sanitizeText(fileName);
                            listItem.title = `${sanitizeText(fileName)} (${sanitizeText(guessedMimeType)})`;
                        }
                    }

                    await dbUtils.saveChat();

                } catch (error) {
                    await uiUtils.showCustomAlert(`ファイルの処理中にエラーが発生しました: ${error.message}`);
                }
                document.body.removeChild(hiddenInput);
            };
            
            document.body.appendChild(hiddenInput);
            hiddenInput.click();
        },
        addMoreAttachments: function(messageIndex, listElement) {
            const hiddenInput = document.createElement('input');
            hiddenInput.type = 'file';
            hiddenInput.multiple = true;
            hiddenInput.accept = "image/*,text/*,application/pdf,video/*,audio/*,.txt,.md,.csv,.json,.html,.css,.js,.py";
            hiddenInput.style.display = 'none';

            hiddenInput.onchange = async (event) => {
                const files = event.target.files;
                if (!files || files.length === 0) return;

                const message = state.currentMessages[messageIndex];
                let currentTotalSize = message.attachments.reduce((sum, att) => sum + (att.file?.size || 0), 0);
                let encodingError = false;

                for (const file of files) {
                    if (file.size > MAX_FILE_SIZE) {
                        await uiUtils.showCustomAlert(`ファイル "${file.name}" はサイズが大きすぎます。`);
                        continue;
                    }
                    if (currentTotalSize + file.size > MAX_TOTAL_ATTACHMENT_SIZE) {
                        await uiUtils.showCustomAlert('合計ファイルサイズの上限を超えたため、一部のファイルは追加されませんでした。');
                        break;
                    }
                    
                    try {
                        let textData = null;
                        let base64Data = null;
                        const fileName = file.name;
                        const fileExtension = fileName.slice(((fileName.lastIndexOf(".") - 1) >>> 0) + 2).toLowerCase();
                        let browserMimeType = file.type || '';
                        let guessedMimeType = extensionToMimeTypeMap[fileExtension] || browserMimeType || 'application/octet-stream';
                        
                        if (guessedMimeType.startsWith('text/')) {
                            textData = await new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                reader.onload = () => resolve(reader.result);
                                reader.onerror = (error) => reject(error);
                                reader.readAsText(file);
                            });
                        } else {
                            base64Data = await fileToBase64(file);
                        }

                        const newAttachment = {
                            file: file,
                            name: fileName,
                            mimeType: guessedMimeType,
                            base64Data: base64Data,
                            textData: textData,
                        };
                        message.attachments.push(newAttachment);
                        currentTotalSize += file.size;

                        const newAttachmentIndex = message.attachments.length - 1;
                        const listItem = document.createElement('li');
                        listItem.dataset.attachmentIndex = newAttachmentIndex;
                        const itemContainer = document.createElement('div');
                        itemContainer.classList.add('attachment-list-item-container');

                        const nameSpan = document.createElement('span');
                        nameSpan.classList.add('attachment-list-item-name');
                        nameSpan.textContent = sanitizeText(fileName);
                        nameSpan.title = `${sanitizeText(fileName)} (${sanitizeText(guessedMimeType)})`;

                        const actionsDiv = document.createElement('div');
                        actionsDiv.classList.add('attachment-actions');

                        if (guessedMimeType.startsWith('image/')) {
                            const previewBtn = document.createElement('button');
                            previewBtn.textContent = '表示';
                            previewBtn.classList.add('attachment-preview-btn');
                            previewBtn.onclick = (e) => { e.preventDefault(); appLogic.previewAttachment(messageIndex, newAttachmentIndex); };
                            actionsDiv.appendChild(previewBtn);
                        }

                        const editBtn = document.createElement('button');
                        editBtn.textContent = '編集';
                        editBtn.classList.add('attachment-edit-btn');
                        editBtn.onclick = (e) => { e.preventDefault(); appLogic.editAttachment(messageIndex, newAttachmentIndex); };

                        const removeBtn = document.createElement('button');
                        removeBtn.textContent = '削除';
                        removeBtn.classList.add('attachment-remove-btn');
                        removeBtn.onclick = (e) => { e.preventDefault(); appLogic.removeAttachment(messageIndex, newAttachmentIndex, listItem); };

                        actionsDiv.appendChild(editBtn);
                        actionsDiv.appendChild(removeBtn);
                        itemContainer.appendChild(nameSpan);
                        itemContainer.appendChild(actionsDiv);
                        listItem.appendChild(itemContainer);
                        listElement.appendChild(listItem);

                    } catch (error) {
                        encodingError = true;
                        await uiUtils.showCustomAlert(`ファイル "${file.name}" の処理中にエラーが発生しました。`);
                        break;
                    }
                }

                if (!encodingError) {
                    const summary = listElement.closest('.attachment-details').querySelector('summary');
                    summary.textContent = `添付ファイル (${message.attachments.length}件)`;
                    await dbUtils.saveChat();
                }
                
                document.body.removeChild(hiddenInput);
            };

            document.body.appendChild(hiddenInput);
            hiddenInput.click();
        },
        
        previewAttachment: async function(messageIndex, attachmentIndex) {
            const message = state.currentMessages[messageIndex];
            const attachment = message?.attachments?.[attachmentIndex];
            if (!attachment || !attachment.mimeType.startsWith('image/')) return;
            
            const dialog = elements.imagePreviewDialog;
            const img = dialog.querySelector('img');
            const okBtn = dialog.querySelector('.dialog-ok-btn');
            
            img.src = `data:${attachment.mimeType};base64,${attachment.base64Data}`;
            img.alt = attachment.name;
            
            okBtn.onclick = () => dialog.close();
            
            dialog.showModal();
        },
    };

    const apiUtils = {
        async callGeminiApi(messagesForApi, generationConfig, systemInstruction, useStreaming, usePseudo, enableGrounding) {
            let apiKey;
            if (state.settings.showMultiApiKeys) {
                apiKey = multiApiKeyUtils.getActiveApiKey('gemini');
            } else {
                apiKey = state.settings.apiKey;
            }
            
            let baseUrl = GEMINI_API_BASE_URL;
            
            if (!apiKey) {
                throw new Error("APIキーが設定されていません。");
            }
            state.abortController = new AbortController();
            const { signal } = state.abortController;

            const model = state.settings.modelName || DEFAULT_MODEL;
            
            let endpointMethod = useStreaming
                ? (usePseudo ? 'generateContent?alt=sse&' : 'streamGenerateContent?alt=sse&')
                : 'generateContent?';

            const endpoint = `${baseUrl}${model}:${endpointMethod}key=${apiKey}`;

            const finalGenerationConfig = { ...generationConfig };

            if (state.settings.geminiThinkingBudget !== null || state.settings.geminiIncludeThoughts) {
                finalGenerationConfig.thinkingConfig = finalGenerationConfig.thinkingConfig || {};
                if (state.settings.geminiThinkingBudget !== null && Number.isInteger(state.settings.geminiThinkingBudget) && state.settings.geminiThinkingBudget >= 0) {
                    finalGenerationConfig.thinkingConfig.thinkingBudget = state.settings.geminiThinkingBudget;
                }
                if (state.settings.geminiIncludeThoughts) {
                    finalGenerationConfig.thinkingConfig.includeThoughts = true;
                }
                 if (Object.keys(finalGenerationConfig.thinkingConfig).length === 0) delete finalGenerationConfig.thinkingConfig;
            }

            const requestBody = {
                contents: messagesForApi,
                ...(Object.keys(finalGenerationConfig).length > 0 && { generationConfig: finalGenerationConfig }),
                ...(systemInstruction && systemInstruction.parts && systemInstruction.parts.length > 0 && systemInstruction.parts[0].text && { systemInstruction }),
                 safetySettings : [
                     { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
                     { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
                                              { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },                         { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }
                 ]
            };

            const tools = [];
            if (enableGrounding) {
                tools.push({ "google_search": {} });
            }

            if (tools.length > 0) {
                requestBody.tools = tools;
            }

            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal
                });

                if (!response.ok) {
                    let errorMsg = `APIエラー (${response.status}): ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.error && errorData.error.message) {
                            errorMsg = `APIエラー (${response.status}): ${errorData.error.message}`;
                        }
                    } catch (e) {  }
                    throw new Error(errorMsg);
                }
                return response;
            } catch (error) {
                if (error.name === 'AbortError') {
                     throw new Error("リクエストがキャンセルされました。");
                }
                throw error;
            }
        },
        async *handleGeminiStreamingResponse(response) {
             if (!response.body) {
                 throw new Error("レスポンスボディがありません。");
             }
             const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
             let buffer = '';
             let lastCandidateInfo = null;
             let isCancelled = false;
             let groundingMetadata = null;
             let finalUsageMetadata = null;

             try {
                 while (true) {
                     if (state.abortController?.signal.aborted && !isCancelled) {
                         isCancelled = true;
                         await reader.cancel("User aborted");
                         throw new Error("リクエストがキャンセルされました。");
                     }

                     let readResult;
                     try {
                         readResult = await reader.read();
                     } catch (readError) {
                         if (readError.name === 'AbortError' || readError.message === "User aborted" || readError.message.includes("aborted")) {
                             if (!isCancelled) {
                                 isCancelled = true;
                                 throw new Error("リクエストがキャンセルされました。");
                             }
                             break;
                         }
                         throw readError;
                     }

                     const { value, done } = readResult;

                     if (done) {
                         if (buffer.trim()) {
                             const finalData = parseSseDataForYield(buffer.trim().substring(6));
                             if (finalData) yield finalData;
                         }
                         break;
                     }

                     buffer += value;
                     let remainingBuffer = buffer;
                     while (true) {
                         const newlineIndex = remainingBuffer.indexOf('\n');
                         if (newlineIndex === -1) {
                             buffer = remainingBuffer;
                             break;
                         }
                         const line = remainingBuffer.substring(0, newlineIndex).trim();
                         remainingBuffer = remainingBuffer.substring(newlineIndex + 1);

                         if (line.startsWith('data: ')) {
                             const chunkData = parseSseDataForYield(line.substring(6));
                             if (chunkData) {
                                 if (chunkData.groundingMetadata) groundingMetadata = chunkData.groundingMetadata;
                                 if (chunkData.usageMetadata) finalUsageMetadata = chunkData.usageMetadata;
                                 yield chunkData;
                             }
                         } else if (line !== '') {
                         }
                         if (remainingBuffer === '') {
                            buffer = '';
                            break;
                         }
                     }
                 }
                 const finishReason = lastCandidateInfo?.finishReason;
                 const safetyRatings = lastCandidateInfo?.safetyRatings;

                 yield {
                     type: 'metadata',
                     finishReason: isCancelled ? 'ABORTED' : finishReason,
                     safetyRatings,
                     groundingMetadata: groundingMetadata,
                     usageMetadata: finalUsageMetadata
                 };

             } catch (error) {
                 throw new Error(`${error.message || error}`, { cause: { originalError: error } });
             } finally {
                 if (!reader.closed && !isCancelled) {
                     try { await reader.cancel("Cleanup cancellation"); } catch(e) {  }
                 }
             }

             function parseSseDataForYield(jsonString) {
                 try {
                     const chunkJson = JSON.parse(jsonString);
                     if (chunkJson.error) {
                         const errorMsg = `モデルエラー: ${chunkJson.error.message || JSON.stringify(chunkJson.error)}`;
                         lastCandidateInfo = { error: chunkJson.error, finishReason: 'ERROR' };
                         return { type: 'error', error: chunkJson.error, message: errorMsg };
                     }

                     let contentText = null;
                     let thoughtText = null;
                     let currentGroundingMetadata = null;
                     let currentUsageMetadata = null;

                     if (chunkJson.candidates && chunkJson.candidates.length > 0) {
                         lastCandidateInfo = chunkJson.candidates[0];
                         if (lastCandidateInfo?.content?.parts) {
                             lastCandidateInfo.content.parts.forEach(part => {
                                 if (typeof part.text === 'string') {
                                     if (part.thought === true) {
                                         thoughtText = (thoughtText || '') + part.text;
                                     } else {
                                         contentText = (contentText || '') + part.text;
                                     }
                                 }
                             });
                         }
                         if (lastCandidateInfo.groundingMetadata) {
                             currentGroundingMetadata = lastCandidateInfo.groundingMetadata;
                         }
                     } else if (chunkJson.promptFeedback) {
                         lastCandidateInfo = { finishReason: 'SAFETY', safetyRatings: chunkJson.promptFeedback.safetyRatings };
                         return null;
                     }

                     if (chunkJson.usageMetadata) {
                         currentUsageMetadata = chunkJson.usageMetadata;
                     }

                     if (contentText !== null || thoughtText !== null || currentGroundingMetadata || currentUsageMetadata) {
                         return {
                             type: 'chunk',
                             contentText,
                             thoughtText,
                             groundingMetadata: currentGroundingMetadata,
                             usageMetadata: currentUsageMetadata
                         };
                     }
                     return null;
                 } catch (parseError) {
                     return null;
                 }
             }
        },
        async callDeepSeekApi(messagesForApi, generationConfig, systemInstruction, useStreaming, provider = 'deepseek') {
            let apiKey, model, baseUrl, topK;
            if (provider === 'llmaggregator') {
                if (state.settings.showMultiApiKeys) {
                    apiKey = multiApiKeyUtils.getActiveApiKey('llmaggregator');
                } else {
                    apiKey = state.settings.llmAggregatorApiKey;
                }
                model = state.settings.llmAggregatorModelName;
                baseUrl = state.settings.llmAggregatorApiBackend;
                topK = state.settings.llmAggregatorTopK;
                if (!baseUrl) {
                    throw new Error("LLM AggregatorのAPIバックエンドURLが設定されていません。");
                }
            } else {
                if (state.settings.showMultiApiKeys) {
                    apiKey = multiApiKeyUtils.getActiveApiKey('deepseek');
                } else {
                    apiKey = state.settings.deepSeekApiKey;
                }
                model = state.settings.deepSeekModelName || DEFAULT_DEEPSEEK_MODEL;
                baseUrl = state.settings.deepSeekApiEndpoint || DEEPSEEK_API_DEFAULT_BASE_URL;
            }

            if (!apiKey) {
                throw new Error(`${provider.toUpperCase()} APIキーが設定されていません。`);
            }
            state.abortController = new AbortController();
            const { signal } = state.abortController;

            const endpoint = `${baseUrl.replace(/\/$/, '')}/chat/completions`;

            const dsMessages = [];
            if (systemInstruction && systemInstruction.content) {
                dsMessages.push({ role: "system", content: systemInstruction.content });
            }

            messagesForApi.forEach(msg => {
                const contentParts = msg.parts.filter(p => p.text).map(p => p.text.trim());
                const fullContent = contentParts.join('\n').trim();

                if (fullContent) {
                    dsMessages.push({
                        role: msg.role === 'model' ? 'assistant' : msg.role,
                        content: fullContent
                    });
                }
            });

            const dsRequestBody = {
                model: model,
                messages: dsMessages,
                stream: useStreaming,
                ...(generationConfig.temperature !== undefined && { temperature: generationConfig.temperature }),
                ...(generationConfig.maxOutputTokens !== undefined && { max_tokens: generationConfig.maxOutputTokens }),
                ...(generationConfig.topP !== undefined && { top_p: generationConfig.topP }),
                ...(generationConfig.presencePenalty !== undefined && { presence_penalty: generationConfig.presencePenalty }),
                ...(generationConfig.frequencyPenalty !== undefined && { frequency_penalty: generationConfig.frequencyPenalty }),
            };
            
            if (provider === 'llmaggregator' && topK !== null) {
                dsRequestBody.top_k = topK;
            }

            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(dsRequestBody),
                    signal
                });

                if (!response.ok) {
                    let errorMsg = `${provider.toUpperCase()} APIエラー (${response.status}): ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.error && errorData.error.message) {
                            errorMsg = `${provider.toUpperCase()} APIエラー (${response.status}): ${errorData.error.message} (Type: ${errorData.error.type || 'N/A'})`;
                        }
                    } catch (e) {  }
                    throw new Error(errorMsg);
                }
                if (!useStreaming) {
                    const data = await response.json();
                    let reasoningContent = null;
                    const choice = data.choices?.[0];
                    if (choice && choice.message && choice.message.reasoning_content) {
                        reasoningContent = choice.message.reasoning_content;
                    }
                    response.json = async () => ({ ...data, parsedReasoningContent: reasoningContent });
                }
                return response;
            } catch (error) {
                if (error.name === 'AbortError') {
                    throw new Error("リクエストがキャンセルされました。");
                }
                throw error;
            }
        },
        async *handleDeepSeekStreamingResponse(response) {
            if (!response.body) {
                throw new Error("DeepSeekレスポンスボディがありません。");
            }
            const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
            let buffer = '';
            let finalUsage = null;
            let finalFinishReason = null;
            let isCancelled = false;
            let accumulatedFullReasoningContent = "";

            try {
                while (true) {
                    if (state.abortController?.signal.aborted && !isCancelled) {
                        isCancelled = true;
                        await reader.cancel("User aborted");
                        throw new Error("リクエストがキャンセルされました。");
                    }

                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += value;
                    let eolIndex;
                    while ((eolIndex = buffer.indexOf('\n')) >= 0) {
                        const line = buffer.substring(0, eolIndex).trim();
                        buffer = buffer.substring(eolIndex + 1);

                        if (line.startsWith('data: ')) {
                            const jsonData = line.substring(6);
                            if (jsonData.trim() === '[DONE]') {
                                finalFinishReason = finalFinishReason || 'stop';
                                break;
                            }
                            try {
                                const chunk = JSON.parse(jsonData);
                                let contentTextChunk = null;
                                let reasoningTextChunk = null;
                                
                                if (chunk.choices && chunk.choices[0] && chunk.choices[0].delta) {
                                    const delta = chunk.choices[0].delta;
                                    if (delta.reasoning_content) {
                                        reasoningTextChunk = delta.reasoning_content;
                                        accumulatedFullReasoningContent += reasoningTextChunk;
                                    } else if (delta.content) {
                                        contentTextChunk = delta.content;
                                    }
                                }

                                if (chunk.choices && chunk.choices[0] && chunk.choices[0].finish_reason) {
                                    finalFinishReason = chunk.choices[0].finish_reason;
                                }
                                if (chunk.usage) {
                                    finalUsage = chunk.usage;
                                }

                                if (contentTextChunk !== null || reasoningTextChunk !== null) {
                                    yield { type: 'chunk', contentText: contentTextChunk, thoughtText: reasoningTextChunk };
                                }
                            } catch (e) {}
                        }
                    }
                     if (finalFinishReason && finalFinishReason !== 'null') break;
                }

                yield {
                    type: 'metadata',
                    finishReason: isCancelled ? 'ABORTED' : finalFinishReason || 'stop',
                    safetyRatings: null,
                    groundingMetadata: null,
                    usageMetadata: finalUsage ? {
                        candidatesTokenCount: finalUsage.completion_tokens,
                        totalTokenCount: finalUsage.total_tokens,
                    } : null,
                    fullReasoningContent: accumulatedFullReasoningContent || null
                };
            } catch (error) {
                 yield { type: 'error', error: { message: error.message }, message: error.message };
            } finally {
                if (!reader.closed && !isCancelled) {
                    try { await reader.cancel("Stream processing ended."); } catch (e) { }
                }
            }
        },
        async callClaudeApi(messagesForApi, generationConfig, systemInstruction, useStreaming) {
            const apiKey = state.settings.showMultiApiKeys ? multiApiKeyUtils.getActiveApiKey('claude') : state.settings.claudeApiKey;
            if (!apiKey) {
                throw new Error("Claude APIキーが設定されていません。");
            }
            state.abortController = new AbortController();
            const { signal } = state.abortController;

            const model = state.settings.claudeModelName || DEFAULT_CLAUDE_MODEL;
            const baseUrl = CLAUDE_API_BASE_URL;
            
            const anthropicRequest = this.convertToClaudeRequest(messagesForApi, systemInstruction);

            const requestBody = {
                model: model,
                messages: anthropicRequest.messages,
                stream: useStreaming,
                max_tokens: generationConfig.maxOutputTokens || state.settings.claudeMaxTokens || DEFAULT_CLAUDE_MAX_TOKENS
            };
            if(anthropicRequest.system) requestBody.system = anthropicRequest.system;
            if (generationConfig.temperature !== undefined && generationConfig.temperature !== null) {
                requestBody.temperature = generationConfig.temperature;
            } else if (state.settings.claudeTemperature !== null) {
                requestBody.temperature = state.settings.claudeTemperature;
            } else {
                requestBody.temperature = DEFAULT_CLAUDE_TEMPERATURE;
            }

            if (generationConfig.topK !== undefined && generationConfig.topK !== null) {
                requestBody.top_k = generationConfig.topK;
            } else if (state.settings.claudeTopK !== null) {
                requestBody.top_k = state.settings.claudeTopK;
            }

            if (generationConfig.topP !== undefined && generationConfig.topP !== null) {
                requestBody.top_p = generationConfig.topP;
            } else if (state.settings.claudeTopP !== null) {
                requestBody.top_p = state.settings.claudeTopP;
            } else {
                requestBody.top_p = DEFAULT_CLAUDE_TOP_P;
            }
                            if (state.settings.claudeIncludeThoughts) {
                requestBody.thinking = { "type": "enabled" };
                const budget = state.settings.claudeThinkingBudget;
                if (budget !== null && Number.isInteger(budget) && budget >= 1024) {
                    requestBody.thinking.budget_tokens = budget;
                }
            }

            try {
                const response = await fetch(baseUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify(requestBody),
                    signal
                });

                if (!response.ok) {
                    let errorMsg = `Claude APIエラー (${response.status}): ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.error && errorData.error.message) {
                            errorMsg = `Claude APIエラー (${response.status}): ${errorData.error.message} (Type: ${errorData.error.type || 'N/A'})`;
                        }
                    } catch (e) {}
                    throw new Error(errorMsg);
                }
                return response;
            } catch (error) {
                if (error.name === 'AbortError') {
                    throw new Error("リクエストがキャンセルされました。");
                }
                throw error;
            }
        },
        convertToClaudeRequest(messagesForApi, systemInstruction) {
            const claudeMessages = [];
            let systemContent = '';

            if (systemInstruction && systemInstruction.content) {
                systemContent = systemInstruction.content;
            } else if (systemInstruction && systemInstruction.parts && systemInstruction.parts.length > 0 && systemInstruction.parts[0].text) {
                systemContent = systemInstruction.parts[0].text;
            }

            for (const msg of messagesForApi) {
                const claudeRole = msg.role === 'model' ? 'assistant' : 'user';
                const contentParts = [];
                msg.parts.forEach(part => {
                    if (part.text) {
                        contentParts.push({ type: 'text', text: part.text });
                    } else if (part.inlineData && part.inlineData.mimeType && part.inlineData.data && part.inlineData.mimeType.startsWith('image/')) {
                         contentParts.push({
                            type: 'image',
                            source: {
                                type: 'base64',
                                media_type: part.inlineData.mimeType,
                                data: part.inlineData.data
                            }
                        });
                    }
                });

                if (contentParts.length > 0) {
                    claudeMessages.push({
                        role: claudeRole,
                        content: contentParts
                    });
                }
            }
            return {
                messages: claudeMessages,
                system: systemContent || undefined
            };
        },
        async *handleClaudeStreamingResponse(response) {
            if (!response.body) {
                throw new Error("Claudeレスポンスボディがありません。");
            }
            const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
            let buffer = '';
            let finalUsage = null;
            let finalFinishReason = null;
            let isCancelled = false;

            try {
                while (true) {
                    if (state.abortController?.signal.aborted && !isCancelled) {
                        isCancelled = true;
                        await reader.cancel("User aborted");
                        throw new Error("リクエストがキャンセルされました。");
                    }

                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += value;
                    let eolIndex;
                    while ((eolIndex = buffer.indexOf('\n')) >= 0) {
                        const line = buffer.substring(0, eolIndex).trim();
                        buffer = buffer.substring(eolIndex + 1);

                        if (line.startsWith('data: ')) {
                            const jsonData = line.substring(6);
                            if (jsonData.trim() === '[DONE]') {
                                break;
                            }
                            try {
                                const chunk = JSON.parse(jsonData);
                                if (chunk.type === 'content_block_delta' && chunk.delta && chunk.delta.type === 'text_delta') {
                                    yield { type: 'chunk', contentText: chunk.delta.text || '', thoughtText: null };
                                } else if (chunk.type === 'content_block_start' && chunk.content_block && chunk.content_block.type === 'thinking') {
                                } else if (chunk.type === 'content_block_delta' && chunk.delta && chunk.delta.type === 'thinking_delta') {
                                    yield { type: 'chunk', contentText: null, thoughtText: chunk.delta.thinking || '' };
                                } else if (chunk.type === 'message_stop') {
                                    finalFinishReason = chunk.message?.stop_reason || 'stop';
                                    if (chunk["amazon-bedrock-invocationMetrics"]) {
                                        finalUsage = {
                                            input_tokens: chunk["amazon-bedrock-invocationMetrics"].inputTokenCount,
                                            output_tokens: chunk["amazon-bedrock-invocationMetrics"].outputTokenCount
                                        };
                                    } else if (chunk.usage) {
                                        finalUsage = chunk.usage;
                                    }
                                } else if (chunk.type === 'message_delta' && chunk.usage) {
                                    finalUsage = chunk.usage;
                                }
                            } catch (e) {
                            }
                        }
                    }
                                        if (finalFinishReason && finalFinishReason !== 'null') break;
                }
                yield {
                    type: 'metadata',
                    finishReason: isCancelled ? 'ABORTED' : finalFinishReason || 'stop',
                    safetyRatings: null,
                                            usageMetadata: finalUsage ? {
                        candidatesTokenCount: finalUsage.output_tokens,
                        totalTokenCount: finalUsage.input_tokens + finalUsage.output_tokens
                    } : null
                };
            } catch (error) {
                 yield { type: 'error', error: { message: error.message }, message: error.message };
            } finally {
                if (!reader.closed && !isCancelled) {
                    try { await reader.cancel("Stream processing ended."); } catch (e) { }
                }
            }
        },
        _createOpenAICompatibleRequestBody(model, messagesForApi, systemInstruction, generationConfig, useStreaming, enableVision) {
            const oaMessages = [];
            if (systemInstruction && systemInstruction.parts?.[0]?.text) {
                oaMessages.push({ role: "system", content: systemInstruction.parts[0].text });
            }

            messagesForApi.forEach(m => {
                const role = m.role === "model" ? "assistant" : m.role;
                const contentParts = [];
                let hasTextPart = false;

                m.parts.forEach(p => {
                    if (p.text) {
                        if (hasTextPart) {
                            contentParts[contentParts.length - 1].text += `\n${p.text}`;
                        } else {
                            contentParts.push({ type: "text", text: p.text });
                            hasTextPart = true;
                        }
                    }
                    if (p.textData) {
                         if (hasTextPart) {
                            contentParts[contentParts.length - 1].text += `\n\n--- ファイル内容 ---\n${p.textData}`;
                        } else {
                            contentParts.push({ type: "text", text: p.textData });
                            hasTextPart = true;
                        }
                    }
                    if (enableVision && p.inlineData && p.inlineData.mimeType && p.inlineData.data && p.inlineData.mimeType.startsWith('image/')) {
                        contentParts.push({
                            type: "image_url",
                            image_url: { url: `data:${p.inlineData.mimeType};base64,${p.inlineData.data}` }
                        });
                    }
                });

                if (contentParts.length > 0) {
                    oaMessages.push({ role: role, content: contentParts });
                }
            });

            const body = {
                model: model,
                messages: oaMessages,
                stream: useStreaming,
            };
            if (generationConfig.temperature != null) body.temperature = generationConfig.temperature;
            if (generationConfig.maxOutputTokens != null) body.max_tokens = generationConfig.maxOutputTokens;
            if (generationConfig.topP != null) body.top_p = generationConfig.topP;
            if (generationConfig.presencePenalty != null) body.presence_penalty = generationConfig.presencePenalty;
            if (generationConfig.frequencyPenalty != null) body.frequency_penalty = generationConfig.frequencyPenalty;

            return body;
        },
        async callOpenAICompatibleApi(provider, messagesForApi, generationConfig, systemInstruction, useStreaming, enableVision) {
            let apiKey, model, baseUrl;
            
            if (provider === 'openai') {
                apiKey = state.settings.showMultiApiKeys ? multiApiKeyUtils.getActiveApiKey('openai') : state.settings.openaiApiKey;
                model = state.settings.openaiModelName || DEFAULT_OPENAI_MODEL;
                baseUrl = OPENAI_API_BASE_URL;
            } else if (provider === 'llmaggregator') {
                apiKey = state.settings.showMultiApiKeys ? multiApiKeyUtils.getActiveApiKey('llmaggregator') : state.settings.llmAggregatorApiKey;
                model = state.settings.llmAggregatorModelName || DEFAULT_LLMAGGREGATOR_MODEL;
                baseUrl = state.settings.llmAggregatorApiBackend;
                if (!baseUrl) {
                    throw new Error("LLM AggregatorのAPIバックエンドURLが設定されていません。");
                }
            } else {
                throw new Error(`Unsupported provider for callOpenAICompatibleApi: ${provider}`);
            }
            
            if (!apiKey) {
                throw new Error(`${provider} のAPIキーが設定されていません。`);
            }

            state.abortController = new AbortController();
            const { signal } = state.abortController;

            const headers = {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${apiKey}`
            };

            const body = this._createOpenAICompatibleRequestBody(
                model,
                messagesForApi,
                systemInstruction,
                generationConfig,
                useStreaming,
                enableVision
            );
            
            if (provider === 'llmaggregator' && generationConfig.topK !== null) {
                body.top_k = generationConfig.topK;
            }
            
            const response = await fetch(baseUrl, { method: "POST", headers, body: JSON.stringify(body), signal });
            if (!response.ok) {
                let msg = `${provider} API error ${response.status}`;
                try {
                    const je = await response.json();
                    msg = je.error?.message || msg;
                } catch {}
                throw new Error(msg);
            }
            return response;
        },
        async *handleOpenAICompatibleStreamingResponse(response, providerName) {
            if (!response.body) {
                throw new Error(`${providerName}レスポンスボディがありません。`);
            }
            const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
            let buffer = '';
            let usage = null;
            let finishReason = null;
            let isCancelled = false;

            try {
                while (true) {
                    if (state.abortController?.signal.aborted) {
                        isCancelled = true;
                        await reader.cancel();
                        throw new Error("リクエストがキャンセルされました。");
                    }

                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += value;
                    let eolIndex;
                    while ((eolIndex = buffer.indexOf('\n')) >= 0) {
                        const line = buffer.slice(0, eolIndex).trim();
                        buffer = buffer.slice(eolIndex + 1);

                        if (!line.startsWith('data:')) continue;
                        const data = line.slice(5).trim();

                        if (data === '[DONE]') {
                            finishReason = 'stop';
                            break;
                        }
                        try {
                            const chunk = JSON.parse(data);
                            if (chunk.choices?.[0]) {
                                const delta = chunk.choices[0].delta;
                                let contentText = null;
                                let thoughtText = null;

                                if (delta?.content) {
                                    contentText = delta.content;
                                }
                                if (delta?.reasoning_content) {
                                    thoughtText = delta.reasoning_content;
                                }

                                if (contentText !== null || thoughtText !== null) {
                                    yield { type: "chunk", contentText: contentText, thoughtText: thoughtText };
                                }
                                
                                if (chunk.choices[0].finish_reason) {
                                    finishReason = chunk.choices[0].finish_reason;
                                }
                            }
                            if (chunk.usage) {
                                usage = chunk.usage;
                                if (usage.completion_tokens_details?.reasoning_tokens) {
                                    usage.completion_tokens += usage.completion_tokens_details.reasoning_tokens;
                                }
                            }
                        } catch (e) {}
                    }
                    if (finishReason) break;
                }
                yield {
                    type: "metadata",
                    finishReason: isCancelled ? "ABORTED" : finishReason || 'stop',
                    usageMetadata: usage ? {
                        candidatesTokenCount: usage.completion_tokens,
                        totalTokenCount: usage.prompt_tokens + usage.completion_tokens
                    } : null,
                    safetyRatings: null,
                    groundingMetadata: null
                };
            } catch (error) {
                 yield { type: 'error', error: { message: error.message }, message: error.message };
            } finally {
                if (!reader.closed && !isCancelled) {
                    try { await reader.cancel(); } catch (e) {}
                }
            }
        },
        async callXaiApi(messagesForApi, generationConfig, systemInstruction, useStreaming, enableVision) {
            const apiKey = state.settings.showMultiApiKeys ? multiApiKeyUtils.getActiveApiKey('xai') : state.settings.xaiApiKey;
            if (!apiKey) {
                throw new Error("xAI APIキーが設定されていません。");
            }
            state.abortController = new AbortController();
            const { signal } = state.abortController;

            const headers = {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${apiKey}`
            };
            
            const body = this._createOpenAICompatibleRequestBody(
                state.settings.xaiModelName || DEFAULT_XAI_MODEL,
                messagesForApi,
                systemInstruction,
                generationConfig,
                useStreaming,
                enableVision
            );

            const reasoningModels = ['grok-3-mini', 'grok-3-mini-fast'];
            if (state.settings.xaiIncludeThoughts && reasoningModels.includes(body.model)) {
                body.reasoning_effort = state.settings.xaiReasoningEffort;
            }
            
            const baseUrl = XAI_API_BASE_URL;
            const response = await fetch(baseUrl, { 
                method: "POST", 
                headers, 
                body: JSON.stringify(body), 
                signal 
            });
            
            if (!response.ok) {
                let msg = `xAI API error ${response.status}`;
                try {
                    const je = await response.json();
                    msg = je.error?.message || msg;
                } catch {}
                throw new Error(msg);
            }

            if (!useStreaming) {
                const data = await response.json();
                let reasoningContent = null;
                const choice = data.choices?.[0];
                if (choice && choice.message && choice.message.reasoning_content) {
                    reasoningContent = choice.message.reasoning_content;
                }
                if (data.usage?.completion_tokens_details?.reasoning_tokens) {
                    data.usage.completion_tokens += data.usage.completion_tokens_details.reasoning_tokens;
                }
                response.json = async () => ({ ...data, xaiThoughtSummary: reasoningContent });
            }
            return response;
        },
    };

    const errorRecovery = {
        errorCount: 0,
        errorTimeWindow: 60000,
        maxErrors: 3,
        lastErrorTime: 0,
        isRecovering: false,
        errorLog: [],
        maxLogSize: 20,

        logError(type, errorInfo) {
            const now = new Date();
            const logEntry = {
                timestamp: now.toISOString(),
                type: type,
                info: this.serializeErrorInfo(errorInfo)
            };
            this.errorLog.unshift(logEntry);
            if (this.errorLog.length > this.maxLogSize) {
                this.errorLog.pop();
            }
        },

        serializeErrorInfo(errorInfo) {
            try {
                const cache = new Set();
                return JSON.stringify(errorInfo, (key, value) => {
                    if (typeof value === 'object' && value !== null) {
                        if (value instanceof Window) return '[Window Object]';
                        if (cache.has(value)) {
                            return '[Circular Reference]';
                        }
                        cache.add(value);
                    }
                    return value;
                }, 2);
            } catch (e) {
                if (errorInfo instanceof Error) {
                    return JSON.stringify({ message: errorInfo.message, stack: errorInfo.stack, name: errorInfo.name }, null, 2);
                }
                return `Failed to serialize error: ${e.message}`;
            }
        },

        getErrorLogAsString() {
            if (this.errorLog.length === 0) {
                return "これまでに記録されたエラーはありません。";
            }
            return this.errorLog.map(log => 
                `Timestamp: ${log.timestamp}\nType: ${log.type}\nInfo:\n${log.info}`
            ).join('\n\n====================\n\n');
        },
        
        init() {
            window.addEventListener('error', (event) => {
                this.handleError('JavaScript Error', {
                    message: event.message,
                    filename: event.filename,
                    lineno: event.lineno,
                    colno: event.colno,
                    error: event.error
                });
            });

            window.addEventListener('unhandledrejection', (event) => {
                this.handleError('Unhandled Promise Rejection', {
                    reason: event.reason,
                    promise: event.promise
                });
            });

            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.addEventListener('error', (event) => {
                    this.handleError('Service Worker Error', event);
                });
            }
        },

        handleError(type, errorInfo) {
            if (this.isRecovering) return;

            const now = Date.now();
                            if (now - this.lastErrorTime > this.errorTimeWindow) {
                this.errorCount = 0;
            }
            
            this.errorCount++;
            this.lastErrorTime = now;
            
            this.logError(type, errorInfo);
            
            const isCriticalError = this.isCriticalError(errorInfo);
            
            if (this.errorCount >= this.maxErrors || isCriticalError) {
                this.triggerForceReload(type, errorInfo, isCriticalError);
            }
        },

        isCriticalError(errorInfo) {
            const criticalPatterns = [
                /Cannot read prop/i,
                /Cannot access before initialization/i,
                /is not defined/i,
                /IndexedDB/i,
                /QuotaExceededError/i,
                /localStorage/i,
                /sessionStorage/i,
                /Service Worker/i,
                /Failed to fetch/i,
                /NetworkError/i
            ];
                        const errorMessage = JSON.stringify(errorInfo).toLowerCase();
            return criticalPatterns.some(pattern => pattern.test(errorMessage));
        },

        async triggerForceReload(errorType, errorInfo, isCritical) {
            if (this.isRecovering) return;
            this.isRecovering = true;

            const reason = isCritical ? '致命的なエラー' : `連続エラー(${this.errorCount}回)`;
            
            try {
                await this.showRecoveryNotification(reason, errorType);
                
                await this.clearCacheAndReload();
                
            } catch (recoveryError) {
                window.location.reload(true);
            }
        },

        async showRecoveryNotification(reason, errorType) {
            if (typeof uiUtils !== 'undefined' && uiUtils.showCustomAlert) {
                try {
                    await uiUtils.showCustomAlert(
                        `アプリで${reason}が発生しました。\n` +
                        `安定性を保つため、キャッシュをクリアして再起動します。\n\n` +
                        `エラータイプ: ${errorType}\n` +
                        `この操作は自動で実行されます。`
                    );
                } catch (e) {
                    alert(`アプリで${reason}が発生しました。キャッシュをクリアして再起動します。`);
                }
            } else {
                alert(`アプリで${reason}が発生しました。キャッシュをクリアして再起動します。`);
            }
        },

        async clearCacheAndReload() {
            try {
                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    await new Promise((resolve, reject) => {
                        const timeoutId = setTimeout(() => reject(new Error('Service Worker timeout')), 5000);
                        
                        const messageHandler = (event) => {
                            if (event.data && event.data.action === 'cacheCleared') {
                                clearTimeout(timeoutId);
                                navigator.serviceWorker.removeEventListener('message', messageHandler);
                                resolve();
                            }
                        };
                        
                        navigator.serviceWorker.addEventListener('message', messageHandler);
                        navigator.serviceWorker.controller.postMessage({ action: 'clearCache' });
                    });
                }
                
                if ('caches' in window) {
                    const cacheNames = await caches.keys();
                    await Promise.all(cacheNames.map(name => caches.delete(name)));
                }
                
                this.clearStorageSelectively();
                
                window.location.reload(true);
                
            } catch (error) {
                window.location.href = window.location.href + '?recovery=' + Date.now();
            }
                        },

        clearStorageSelectively() {
            try {
                const protectedKeys = [
                    'GeminiPWA_DB',
                ];
                
                if (typeof Storage !== 'undefined' && sessionStorage) {
                    sessionStorage.clear();
                }
                
                if (typeof Storage !== 'undefined' && localStorage) {
                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && !protectedKeys.some(protected => key.includes(protected))) {
                            keysToRemove.push(key);
                        }
                    }
                    keysToRemove.forEach(key => localStorage.removeItem(key));
                }
            } catch (error) {
            }
        },

        manualRecovery() {
            this.triggerForceReload('Manual Recovery', { reason: 'User triggered' }, true);
        }
    };
            const multiApiKeyUtils = {
        MAX_API_KEYS: 10,

        initializeMultiApiKeys() {
            elements.addGeminiApiKeyBtn.addEventListener('click', () => this.addApiKey('gemini'));
            elements.addDeepseekApiKeyBtn.addEventListener('click', () => this.addApiKey('deepseek'));
            elements.addClaudeApiKeyBtn.addEventListener('click', () => this.addApiKey('claude'));
            elements.addOpenaiApiKeyBtn.addEventListener('click', () => this.addApiKey('openai'));
            elements.addXaiApiKeyBtn.addEventListener('click', () => this.addApiKey('xai'));
            elements.addLlmaggregatorApiKeyBtn.addEventListener('click', () => this.addApiKey('llmaggregator'));

            this.renderAllApiKeyLists();
        },

        addApiKey(provider) {
            const keys = this.getApiKeysArray(provider);
            if (keys.length >= this.MAX_API_KEYS) {
                uiUtils.showCustomAlert(`最大${this.MAX_API_KEYS}個までのAPIキーを設定できます。`);
                return;
            }

            const newKey = {
                id: Date.now().toString(),
                label: `キー ${keys.length + 1}`,
                value: '',
                isActive: keys.length === 0
            };

            keys.push(newKey);
            
            if (newKey.isActive) {
                this.setActiveApiKeyIndex(provider, keys.length - 1);
            }

            this.renderApiKeyList(provider);
            this.updateMainApiKeyInput(provider);
        },

        async deleteApiKey(provider, keyId) {
            const keys = this.getApiKeysArray(provider);
            const keyIndex = keys.findIndex(key => key.id === keyId);
            if (keyIndex === -1) return;

            const keyToDelete = keys[keyIndex];
            const confirmed = await uiUtils.showCustomConfirm(
                `APIキー「${keyToDelete.label}」を削除しますか？`
            );
            
            if (!confirmed) return;

            const wasActive = keyToDelete.isActive;
            keys.splice(keyIndex, 1);

            if (wasActive && keys.length > 0) {
                const newActiveIndex = Math.min(keyIndex, keys.length - 1);
                keys[newActiveIndex].isActive = true;
                this.setActiveApiKeyIndex(provider, newActiveIndex);
            } else if (keys.length === 0) {
                this.setActiveApiKeyIndex(provider, -1);
            }

            this.renderApiKeyList(provider);
            this.updateMainApiKeyInput(provider);
        },

        selectApiKey(provider, keyId) {
            const keys = this.getApiKeysArray(provider);
            const selectedIndex = keys.findIndex(key => key.id === keyId);
            if (selectedIndex === -1) return;

            keys.forEach((key, index) => {
                key.isActive = index === selectedIndex;
            });

            this.setActiveApiKeyIndex(provider, selectedIndex);
            this.renderApiKeyList(provider);
            this.updateMainApiKeyInput(provider);
        },

        updateApiKeyValue(provider, keyId, newValue) {
            const keys = this.getApiKeysArray(provider);
            const key = keys.find(k => k.id === keyId);
            if (key) {
                key.value = newValue.trim();
                if (key.isActive) {
                    this.updateMainApiKeyInput(provider);
                }
            }
        },

        updateApiKeyLabel(provider, keyId, newLabel) {
            const keys = this.getApiKeysArray(provider);
            const key = keys.find(k => k.id === keyId);
            if (key) {
                key.label = newLabel.trim() || `キー ${keys.indexOf(key) + 1}`;
            }
        },

        getApiKeysArray(provider) {
            switch (provider) {
                case 'gemini': return state.settings.geminiApiKeys;
                case 'deepseek': return state.settings.deepseekApiKeys;
                case 'claude': return state.settings.claudeApiKeys;
                case 'openai': return state.settings.openaiApiKeys;
                case 'xai': return state.settings.xaiApiKeys;
                case 'llmaggregator': return state.settings.llmaggregatorApiKeys;
                default: return [];
            }
        },

        setActiveApiKeyIndex(provider, index) {
            switch (provider) {
                case 'gemini': state.settings.geminiActiveApiKeyIndex = index; break;
                case 'deepseek': state.settings.deepseekActiveApiKeyIndex = index; break;
                case 'claude': state.settings.claudeActiveApiKeyIndex = index; break;
                case 'openai': state.settings.openaiActiveApiKeyIndex = index; break;
                case 'xai': state.settings.xaiActiveApiKeyIndex = index; break;
                case 'llmaggregator': state.settings.llmaggregatorActiveApiKeyIndex = index; break;
            }
        },

        getActiveApiKey(provider) {
            const keys = this.getApiKeysArray(provider);
            const activeKey = keys.find(key => key.isActive);
            return activeKey ? activeKey.value : '';
        },

        updateMainApiKeyInput(provider) {
            if (!state.settings.showMultiApiKeys) {
                return;
            }
            const activeKey = this.getActiveApiKey(provider);
            switch (provider) {
                case 'gemini':
                    elements.geminiApiKeyInput.value = activeKey;
                    break;
                case 'deepseek':
                    elements.deepSeekApiKeyInput.value = activeKey;
                    break;
                case 'claude':
                    elements.claudeApiKeyInput.value = activeKey;
                    break;
                                    case 'openai':
                    elements.openaiApiKeyInput.value = activeKey;
                    break;
                case 'xai':
                    elements.xaiApiKeyInput.value = activeKey;
                    break;
                case 'llmaggregator':
                    elements.llmAggregatorApiKeyInput.value = activeKey;
                    break;
            }
        },

        renderApiKeyList(provider) {
            const keys = this.getApiKeysArray(provider);
            const container = this.getListContainer(provider);
                            const addButton = this.getAddButton(provider);

            container.innerHTML = '';

            if (keys.length === 0) {
                const emptyMsg = document.createElement('p');
                emptyMsg.textContent = 'APIキーが設定されていません。';
                emptyMsg.style.color = 'var(--text-secondary)';
                emptyMsg.style.fontSize = '13px';
                emptyMsg.style.textAlign = 'center';
                emptyMsg.style.margin = '10px 0';
                container.appendChild(emptyMsg);
            } else {
                keys.forEach((key, index) => {
                    const item = this.createApiKeyItem(provider, key, index);
                    container.appendChild(item);
                });
            }

            addButton.disabled = keys.length >= this.MAX_API_KEYS;
            addButton.textContent = keys.length >= this.MAX_API_KEYS 
                ? `最大${this.MAX_API_KEYS}個まで` 
                : '新しいAPIキーを追加';
        },

        createApiKeyItem(provider, key, index) {
            const item = document.createElement('div');
            item.className = `api-key-item ${key.isActive ? 'active' : ''}`;

            const labelInput = document.createElement('input');
            labelInput.type = 'text';
            labelInput.className = 'api-key-item-label';
            labelInput.value = key.label;
            labelInput.placeholder = `キー ${index + 1}`;
            labelInput.addEventListener('change', (e) => {
                                this.updateApiKeyLabel(provider, key.id, e.target.value);
            });

            const keyInput = document.createElement('input');
            keyInput.type = 'password';
            keyInput.className = 'api-key-item-input';
            keyInput.value = key.value;
            keyInput.placeholder = 'APIキーを入力...';
            keyInput.addEventListener('input', (e) => {
                this.updateApiKeyValue(provider, key.id, e.target.value);
            });

            const actions = document.createElement('div');
            actions.className = 'api-key-item-actions';

            const selectBtn = document.createElement('button');
            selectBtn.className = `api-key-select-btn ${key.isActive ? 'active' : ''}`;
            selectBtn.textContent = key.isActive ? '使用中' : '未選択';
            selectBtn.disabled = key.isActive;
            selectBtn.addEventListener('click', () => {
                this.selectApiKey(provider, key.id);
            });

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'api-key-delete-btn';
            deleteBtn.textContent = '削';
            deleteBtn.addEventListener('click', () => {
                this.deleteApiKey(provider, key.id);
            });

            actions.appendChild(selectBtn);
            actions.appendChild(deleteBtn);

            item.appendChild(labelInput);
            item.appendChild(keyInput);
            item.appendChild(actions);

            return item;
        },

        getListContainer(provider) {
            switch (provider) {
                case 'gemini': return elements.geminiApiKeysList;
                case 'deepseek': return elements.deepseekApiKeysList;
                case 'claude': return elements.claudeApiKeysList;
                case 'openai': return elements.openaiApiKeysList;
                case 'xai': return elements.xaiApiKeysList;
                case 'llmaggregator': return elements.llmaggregatorApiKeysList;
                default: return null;
            }
        },

        getAddButton(provider) {
            switch (provider) {
                case 'gemini': return elements.addGeminiApiKeyBtn;
                case 'deepseek': return elements.addDeepseekApiKeyBtn;
                case 'claude': return elements.addClaudeApiKeyBtn;
                case 'openai': return elements.addOpenaiApiKeyBtn;
                case 'xai': return elements.addXaiApiKeyBtn;
                case 'llmaggregator': return elements.addLlmaggregatorApiKeyBtn;
                default: return null;
            }
        },

        renderAllApiKeyLists() {
            this.renderApiKeyList('gemini');
            this.renderApiKeyList('deepseek');
            this.renderApiKeyList('claude');
            this.renderApiKeyList('openai');
            this.renderApiKeyList('xai');
                        this.renderApiKeyList('llmaggregator');
        },

        syncMainApiKeyInput(provider) {
            if (!state.settings.showMultiApiKeys) {
                return;
            }
            let mainValue = '';
            switch (provider) {
                case 'gemini': mainValue = elements.geminiApiKeyInput.value.trim(); break;
                case 'deepseek': mainValue = elements.deepSeekApiKeyInput.value.trim(); break;
                case 'claude': mainValue = elements.claudeApiKeyInput.value.trim(); break;
                case 'openai': mainValue = elements.openaiApiKeyInput.value.trim(); break;
                case 'xai': mainValue = elements.xaiApiKeyInput.value.trim(); break;
                case 'llmaggregator': mainValue = elements.llmAggregatorApiKeyInput.value.trim(); break;
            }

            const keys = this.getApiKeysArray(provider);
            const activeKey = keys.find(key => key.isActive);
            
            if (activeKey && activeKey.value !== mainValue) {
                activeKey.value = mainValue;
                this.renderApiKeyList(provider);
            }
        }
    };

    errorRecovery.init();

    window.errorRecovery = errorRecovery;

    appLogic.initializeApp();
</script>
</body>
</html>
